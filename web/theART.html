<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Thought Collections + Core Thought Pipeline</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <!-- === Scribble Styles (mostly unchanged, only .page height tweaked) === -->
  <style>
    :root {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "SF Pro Text", sans-serif;

      /* --- LIGHT THEME VARIABLES --- */
      --bg: #ffffff;
      --bg-elevated: #f7f7f9;
      --bg-soft: #fafafa;
      --border-subtle: #dddddd;

      --accent: #6a4dff;
      --accent-soft: rgba(106, 77, 255, 0.12);
      --accent-strong: rgba(106, 77, 255, 0.28);

      --text: #111111;
      --text-soft: #666666;

      --danger: #d93650;
    }

    * { box-sizing: border-box; }

    body {
      margin: 0;
      background: radial-gradient(circle at top, #ffffff 0, #f5f5f7 55%, #e9e9ef 100%);
      color: var(--text);
      display: flex;
      flex-direction: column;
      min-height: 100vh;
    }

    .page {
      display: flex;
      flex-direction: column;
      /* was height: 100vh; â†’ allow scrolling for think section below */
      min-height: 100vh;
      max-width: 1400px;
      margin: 0 auto;
      padding: 12px 16px 24px;
      gap: 10px;
    }

    header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 10px 14px;
      border-radius: 16px;
      background: linear-gradient(120deg, rgba(106, 77, 255, 0.16), rgba(255, 255, 255, 0.8));
      border: 1px solid var(--accent-strong);
      box-shadow: 0 12px 28px rgba(0, 0, 0, 0.06);
    }

    header .subtitle {
      color: var(--text-soft);
    }

    .pill {
      padding: 4px 10px;
      border-radius: 999px;
      background: rgba(255, 255, 255, 0.8);
      border: 1px solid rgba(0, 0, 0, 0.06);
      color: var(--text-soft);
    }

    .pill strong { color: var(--accent); }

    main {
      flex: 1;
      display: grid;
      grid-template-columns: 240px minmax(0, 1.4fr) minmax(0, 1.3fr);
      gap: 10px;
      min-height: 0;
    }

    .panel {
      background: var(--bg-elevated);
      border-radius: 16px;
      border: 1px solid var(--border-subtle);
      box-shadow: 0 10px 22px rgba(0, 0, 0, 0.07);
      padding: 10px;
      display: flex;
      flex-direction: column;
      min-height: 0;
    }

    .panel-header h2 {
      color: var(--text-soft);
    }

    button, .ghost-btn {
      border-radius: 999px;
      border: none;
      font-size: 12px;
      padding: 6px 12px;
      cursor: pointer;
      background: var(--accent);
      color: #fff;
      display: inline-flex;
      align-items: center;
      gap: 6px;
      box-shadow: 0 6px 14px rgba(106, 77, 255, 0.28);
      transition: transform 0.08s ease, box-shadow 0.08s ease, background 0.08s ease;
    }

    .ghost-btn {
      background: rgba(0, 0, 0, 0.02);
      color: var(--text-soft);
      border: 1px solid rgba(0, 0, 0, 0.08);
      box-shadow: none;
    }

    .ghost-btn.primary-soft {
      border-color: var(--accent-soft);
      background: rgba(106, 77, 255, 0.08);
      color: var(--accent);
    }

    .ghost-btn.danger {
      background: rgba(217, 54, 80, 0.08);
      color: var(--danger);
      border-color: rgba(217, 54, 80, 0.3);
      box-shadow: none;
    }

    .input, textarea, select {
      width: 100%;
      padding: 7px 10px;
      border-radius: 10px;
      border: 1px solid #cccccc;
      background: #ffffff;
      color: var(--text);
      font-size: 13px;
      resize: vertical;
    }

    .input:focus, textarea:focus, select:focus {
      outline: 1px solid var(--accent);
      box-shadow: 0 0 0 1px var(--accent-soft);
    }

    .label {
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.12em;
      color: var(--text-soft);
      margin-bottom: 4px;
    }

    #collections-list li {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 6px 8px;
      border-radius: 10px;
      cursor: pointer;
      margin-bottom: 3px;
      color: var(--text-soft);
      border: 1px solid transparent;
    }

    #collections-list li.active {
      background: var(--accent-soft);
      color: var(--accent);
      border-color: var(--accent-strong);
    }

    #collections-list {
      flex: 1;
      min-height: 0;
      overflow-y: auto;
      margin: 6px 0 8px;
      padding: 0;
      list-style: none;
      padding-right: 4px;
    }

    .chip {
      border: 1px solid #ddd;
      color: var(--text-soft);
      background: #f4f4f7;
    }

    .thought-item {
      border-radius: 10px;
      padding: 7px 9px;
      border: 1px solid #e6e6e6;
      margin-bottom: 5px;
      cursor: pointer;
      background: #ffffff;
    }

    .thought-item:hover {
      border-color: var(--accent-soft);
      background: linear-gradient(135deg, rgba(106, 77, 255, 0.05), #ffffff);
    }

    .thought-item.active {
      border-color: var(--accent);
      background: linear-gradient(135deg, rgba(106, 77, 255, 0.18), #ffffff);
    }

    .thought-item-title {
      font-size: 13px;
      font-weight: 600;
      color: var(--text);
    }

    .thought-item-preview {
      color: var(--text-soft);
    }

    .meta-row span {
      background: rgba(0, 0, 0, 0.04);
      border: 1px solid rgba(0, 0, 0, 0.08);
    }

    .status-pill {
      padding: 2px 8px;
      border-radius: 999px;
      background: rgba(0, 0, 0, 0.05);
      border: 1px solid rgba(0, 0, 0, 0.06);
      font-size: 11px;
    }

    .status-pill.idle { }
    .status-pill.error { color: var(--danger); }

    .thought-item-meta {
      font-size: 11px;
      color: var(--text-soft);
      display: flex;
      gap: 8px;
      align-items: center;
      justify-content: space-between;
    }

    .thought-item-actions {
      display: inline-flex;
      gap: 4px;
    }

    .ghost-btn.tiny {
      font-size: 10px;
      padding: 2px 6px;
      box-shadow: none;
    }

    section.panel.collections {
      display: flex;
      flex-direction: column;
      min-height: 0;
    }

    .collection-form {
      margin-top: auto;
      display: flex;
      gap: 6px;
    }

    .collection-form .input {
      flex: 1;
    }

    .collection-form button {
      flex: 0 0 auto;
      padding-inline: 10px;
    }

    .chips {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      margin-bottom: 4px;
    }

    .thought-list-container {
      flex: 1;
      min-height: 0;
      overflow-y: auto;
      margin-top: 4px;
      padding-right: 4px;
    }

    .detail-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 8px;
    }

    .detail-collection {
      font-size: 11px;
      color: var(--text-soft);
      text-transform: uppercase;
      letter-spacing: 0.08em;
    }

    .detail-title {
      font-size: 14px;
      font-weight: 600;
    }

    .detail-body .row {
      margin-bottom: 8px;
    }

    .row-inline {
      display: flex;
      gap: 8px;
      margin-bottom: 8px;
    }

    .row-inline > div {
      flex: 1;
    }

    .meta-row {
      display: flex;
      gap: 6px;
      margin-top: 8px;
      font-size: 11px;
      color: var(--text-soft);
    }

    .detail-footer {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-top: 10px;
      gap: 8px;
    }

    .detail-footer .right {
      display: flex;
      gap: 6px;
    }

    /* === Think Section Styles (scoped under #think-section) === */
    #think-section {
      width: 100%;
      box-sizing: border-box;
      padding: 16px;
      margin: 0 auto 24px;
      max-width: 1200px;
    }

    #think-section .think-container {
      max-width: 1200px;
      margin: 0 auto;
      padding: 24px 16px 40px;
      background: #f5f5f5;
      border-radius: 16px;
      box-shadow: 0 4px 18px rgba(0, 0, 0, 0.08);
      color: #111827;
    }

    #think-section h1 {
      margin-bottom: 4px;
    }

    #think-section .subtitle {
      font-size: 0.95rem;
      color: #4b5563;
      margin-bottom: 20px;
    }

    #think-section textarea {
      width: 100%;
      min-height: 100px;
      padding: 10px;
      border-radius: 8px;
      border: 1px solid #d1d5db;
      font-family: inherit;
      font-size: 0.95rem;
      resize: vertical;
      box-sizing: border-box;
    }

    #think-section button {
      border: none;
      padding: 8px 16px;
      border-radius: 999px;
      cursor: pointer;
      font-size: 0.9rem;
      margin: 4px 6px 4px 0;
      background: #111827;
      color: #f9fafb;
    }

    #think-section button.secondary {
      background: #e5e7eb;
      color: #111827;
    }

    #think-section button:disabled {
      opacity: 0.5;
      cursor: default;
    }

    #think-section label {
      font-size: 0.85rem;
      font-weight: 500;
      display: block;
      margin-bottom: 4px;
      color: #374151;
    }

    #think-section .status {
      margin-top: 8px;
      font-size: 0.85rem;
      color: #374151;
    }

    #think-section .status.error {
      color: #b91c1c;
    }

    #think-section .row {
      display: flex;
      flex-wrap: wrap;
      gap: 16px;
      margin-top: 24px;
    }

    #think-section .card {
      background: #ffffff;
      border-radius: 12px;
      padding: 12px 14px;
      box-shadow: 0 1px 3px rgba(0,0,0,0.08);
      flex: 1 1 280px;
      min-width: 280px;
      max-height: 360px;
      display: flex;
      flex-direction: column;
    }

    #think-section .card h2 {
      font-size: 0.95rem;
      margin: 0 0 6px;
      display: flex;
      align-items: center;
      justify-content: space-between;
    }

    #think-section .badge {
      display: inline-block;
      font-size: 0.65rem;
      text-transform: uppercase;
      letter-spacing: 0.06em;
      padding: 1px 7px;
      border-radius: 999px;
      background: #e5e7eb;
      color: #4b5563;
      margin-left: 8px;
    }

    #think-section .card pre {
      white-space: pre-wrap;
      word-wrap: break-word;
      font-size: 0.8rem;
      line-height: 1.35;
      margin: 4px 0 0;
      overflow: auto;
      flex: 1;
    }

    #think-section .card-controls {
      margin-bottom: 4px;
    }

    #think-section .card-controls button {
      margin-right: 4px;
      margin-bottom: 4px;
    }

    #think-section .small-input {
      font-size: 0.8rem;
      padding: 4px 6px;
      border-radius: 6px;
      border: 1px solid #d1d5db;
      width: 100%;
      box-sizing: border-box;
      margin-top: 4px;
    }

    #think-section .top-controls {
      margin-top: 8px;
      margin-bottom: 12px;
    }
  </style>
</head>
<body>

  <!-- === TOP: Scribble / Thought Collections === -->
  <div class="page">
    <header>
      <div class="title">
        <h1>Thought Collections</h1>
        <div class="subtitle">Capture, orbit, and recombine thoughts across domains.</div>
      </div>
      <div class="right-controls">
        <div class="pill"><strong>Collection</strong>: <span id="header-current-collection">none selected</span></div>
        <div class="pill" id="header-count-pill">0 thoughts</div>
      </div>
    </header>

    <main>
      <!-- LEFT: Collections -->
      <section class="panel collections">
        <div class="panel-header">
          <h2>Collections</h2>
        </div>

        <ul id="collections-list"></ul>

        <form class="collection-form" id="new-collection-form">
          <input
            class="input"
            id="new-collection-input"
            type="text"
            placeholder="Add collection (e.g. money, beauty_depth)"
            autocomplete="off"
          />
          <button type="submit" title="Create collection">+</button>
        </form>
      </section>

      <!-- CENTER: Thought list -->
      <section class="panel">
        <div class="panel-header">
          <h2>Thoughts</h2>
          <div class="actions">
            <button type="button" class="ghost-btn primary-soft" id="btn-random">
              ðŸŽ² Random in collection
            </button>
          </div>
        </div>

        <div class="chips">
          <span class="chip">
            <strong>Filter</strong>:
            <select id="filter-length" class="input" style="width:auto;padding:2px 6px;font-size:11px;">
              <option value="all">All lengths</option>
              <option value="short">Short (â‰¤ 140 chars)</option>
              <option value="medium">Medium (â‰¤ 500 chars)</option>
              <option value="long">Long excerpts</option>
            </select>
          </span>
          <span class="chip">
            <strong>Search</strong>:
            <input
              id="search-input"
              class="input"
              type="text"
              placeholder="grep this collection..."
              style="width:150px;padding:2px 6px;font-size:11px;"
            />
          </span>
        </div>

        <div class="thought-list-container" id="thought-list"></div>
      </section>

      <!-- RIGHT: Detail / editor -->
      <section class="panel">
        <div class="detail-header">
          <div class="detail-header-left">
            <div class="detail-collection" id="detail-collection-label">No collection selected</div>
            <div class="detail-title" id="detail-title-label">Start a new thought or select one.</div>
          </div>
          <div class="actions">
            <button type="button" class="ghost-btn" id="btn-new-thought">New</button>
          </div>
        </div>

        <div class="detail-body">
          <div class="row">
            <div class="label">Title (optional)</div>
            <input id="detail-title" class="input" type="text" placeholder="e.g. Money as Flow">
          </div>

          <div class="row">
            <div class="label">Thought</div>
            <textarea
              id="detail-text"
              placeholder="Drop the raw thought here. It can be a single phrase or an entire excerpt."
            ></textarea>
          </div>

          <div class="row-inline">
            <div>
              <div class="label">Collection</div>
              <input id="detail-collection" class="input" type="text" placeholder="e.g. money">
            </div>
            <div>
              <div class="label">Order index</div>
              <input id="detail-order" class="input" type="number" step="1" placeholder="0">
            </div>
          </div>

          <div class="row-inline">
            <div>
              <div class="label">Author / Source label</div>
              <input id="detail-author" class="input" type="text" placeholder="Boris, Marshall, etc.">
            </div>
            <div>
              <div class="label">Context / Citation</div>
              <input id="detail-context" class="input" type="text" placeholder="Book, page, link, notes">
            </div>
          </div>

          <div class="row">
            <div class="label">Tags (comma-separated or JSON fragment)</div>
            <input id="detail-tags" class="input" type="text" placeholder="fluid_dynamics, competition, money_field">
          </div>

          <div class="meta-row" id="detail-meta">
            <span id="detail-id-pill">New thought (no id)</span>
            <span id="detail-created-pill">created: â€”</span>
            <span id="detail-updated-pill">updated: â€”</span>
          </div>
        </div>

        <div class="detail-footer">
          <div class="status-pill idle" id="status-pill">idle</div>
          <div class="right">
            <button type="button" class="ghost-btn danger" id="btn-delete" style="display:none;">
              Delete
            </button>
            <button type="button" class="ghost-btn primary-soft" id="btn-save-world">
              Save + world
            </button>
            <!-- NEW: Send the current thought into the think pipeline -->
            <button type="button" class="ghost-btn primary-soft" id="btn-send-to-think">
              â†§ To pipeline
            </button>
            <button type="button" id="btn-save">
              Save
            </button>
          </div>
        </div>

      </section>
    </main>
  </div>

  <!-- === BOTTOM: Think / Core Thought Pipeline === -->
  <section id="think-section">
    <div class="think-container">
      <h1>Core Thought Pipeline</h1>
      <div class="subtitle">
        Start with a seed thought. You can step through each stage (adjacent â†’ core thoughts â†’ expansion â†’ core ideas â†’ world â†’ bridges), or run the full pipeline in one shot.
      </div>

      <label for="thought-input">Seed thought</label>
      <textarea id="thought-input" placeholder="Example: a symphony of a thousand pianos"></textarea>

      <div class="top-controls">
        <button id="adjacent-btn" class="secondary">1 Â· Adjacent thoughts</button>
        <button id="core-thoughts-btn" class="secondary">2 Â· Core thoughts</button>
        <button id="expand-btn" class="secondary">3 Â· Expand core thought</button>
        <button id="core-ideas-btn" class="secondary">4 Â· Core ideas from expansion</button>
        <button id="world-context-btn" class="secondary">5 Â· World context</button>
        <button id="bridges-btn" class="secondary">6 Â· Bridges</button>
        <button id="pipeline-btn">Run full pipeline</button>
      </div>

      <div id="status" class="status"></div>

      <div class="row">
        <div class="card">
          <h2>
            Adjacent thoughts
            <span class="badge">neighborhood</span>
          </h2>
          <div class="card-controls">
            <small>POST /think/adjacent</small>
          </div>
          <pre id="adjacent-output"></pre>
        </div>

        <div class="card">
          <h2>
            Core thoughts architecture
            <span class="badge">structure</span>
          </h2>
          <div class="card-controls">
            <small>POST /think/core_thoughts</small>
          </div>
          <pre id="core-thoughts-output"></pre>
        </div>

        <div class="card">
          <h2>
            Expanded core thought
            <span class="badge">deep dive</span>
          </h2>
          <div class="card-controls">
            <small>POST /think/expand_core_thought</small>
            <div>
              <label for="core-thought-manual" style="margin-top:4px;">
                Core thought to expand (optional)
              </label>
              <input id="core-thought-manual" class="small-input"
                     placeholder="If empty, uses first core thought above">
            </div>
          </div>
          <pre id="expansion-output"></pre>
        </div>
      </div>

      <div class="row">
        <div class="card">
          <h2>
            Core ideas
            <span class="badge">distilled seeds</span>
          </h2>
          <div class="card-controls">
            <small>POST /think/core_ideas</small>
          </div>
          <pre id="core-ideas-output"></pre>
        </div>

        <div class="card">
          <h2>
            World context
            <span class="badge">imagined world</span>
          </h2>
          <div class="card-controls">
            <small>POST /think/world_context</small>
          </div>
          <pre id="world-context-output"></pre>
        </div>

        <div class="card">
          <h2>
            Bridges
            <span class="badge">into your world</span>
          </h2>
          <div class="card-controls">
            <small>POST /think/bridges</small>
          </div>
          <pre id="bridges-output"></pre>
        </div>
      </div>
    </div>
  </section>

  <!-- === Scribble JS (unchanged except for integration button) === -->
  <script>
    // --- State ---
    let collections = [];   // [{ name, count }]
    let thoughts = [];      // current collection thoughts
    let currentCollection = null;
    let currentThought = null; // full object from DB
    let statusTimer = null;
    const API_BASE = "/scribble/api";
    const THINK_BASE = "/think";

    function setStatus(text, mode = "idle") {
      const pill = document.getElementById("status-pill");
      pill.textContent = text;
      pill.className = "status-pill " + mode;
      if (statusTimer) {
        clearTimeout(statusTimer);
        statusTimer = null;
      }
      if (mode !== "error" && mode !== "idle") {
        statusTimer = setTimeout(() => {
          pill.textContent = "idle";
          pill.className = "status-pill idle";
        }, 2000);
      }
    }

    // --- Collections UI ---
    function renderCollections() {
      const ul = document.getElementById("collections-list");
      ul.innerHTML = "";
      collections.forEach(c => {
        const li = document.createElement("li");
        li.dataset.collection = c.name;
        if (c.name === currentCollection) li.classList.add("active");
        li.innerHTML = `
          <span>${c.name}</span>
          <span class="count">${c.count ?? 0}</span>
        `;
        li.addEventListener("click", () => selectCollection(c.name));
        ul.appendChild(li);
      });
    }

    function updateHeaderCounts() {
      document.getElementById("header-current-collection").textContent =
        currentCollection || "none selected";
      document.getElementById("header-count-pill").textContent =
        (thoughts.length || 0) + " thoughts";
      document.getElementById("detail-collection-label").textContent =
        currentCollection ? "Collection: " + currentCollection : "No collection selected";
    }

    async function loadCollections() {
      try {
        const res = await fetch(`${API_BASE}/thoughts/collections`);
        if (!res.ok) throw new Error("HTTP " + res.status);
        const data = await res.json();
        collections = (data || []).map(row => ({
          name: row.collection,
          count: row.count,
          last_ts: row.last_created_at || row.last_updated_at || null
        }));

        collections.sort((a, b) => {
          if (a.last_ts && b.last_ts) {
            return new Date(b.last_ts) - new Date(a.last_ts);
          }
          if (a.last_ts) return -1;
          if (b.last_ts) return 1;
          return a.name.localeCompare(b.name);
        });

        renderCollections();
      } catch (err) {
        console.error("Failed to load collections", err);
        setStatus("Error loading collections", "error");
      }
    }

    async function selectCollection(name) {
      currentCollection = name;
      currentThought = null;
      await loadThoughts(name);
      renderThoughtList();
      updateHeaderCounts();
      clearDetailForm();
    }

    // --- Thoughts list UI ---
    function lengthBucket(text) {
      const len = (text || "").length;
      if (len <= 140) return "short";
      if (len <= 500) return "medium";
      return "long";
    }

    function renderThoughtList() {
      const container = document.getElementById("thought-list");
      container.innerHTML = "";

      const filter = document.getElementById("filter-length").value;
      const query = document.getElementById("search-input").value.trim().toLowerCase();

      let filtered = thoughts.slice();

      if (filter !== "all") {
        filtered = filtered.filter(t => lengthBucket(t.text) === filter);
      }
      if (query) {
        filtered = filtered.filter(
          t =>
            (t.title || "").toLowerCase().includes(query) ||
            (t.text || "").toLowerCase().includes(query)
        );
      }

      filtered.forEach(t => {
        const div = document.createElement("div");
        div.className = "thought-item";
        if (currentThought && t.id === currentThought.id) div.classList.add("active");

        const preview =
          (t.text || "").length > 160
            ? (t.text || "").slice(0, 160) + "â€¦"
            : (t.text || "");

        const createdShort = t.created_at
          ? new Date(t.created_at).toLocaleDateString()
          : "â€”";

        div.innerHTML = `
          <div class="thought-item-title">${t.title || "(untitled thought)"}</div>
          <div class="thought-item-preview">${(preview || "").replace(/\n/g, " ")}</div>
          <div class="thought-item-meta">
            <span>${createdShort}</span>
            <span>${lengthBucket(t.text)} Â· ${t.collection}</span>
            <div class="thought-item-actions">
              <button type="button" class="ghost-btn tiny primary-soft btn-open">Open</button>
              <button type="button" class="ghost-btn tiny btn-edit">Edit</button>
            </div>
          </div>
        `;

        div.addEventListener("click", () => {
          currentThought = t;
          fillDetailForm(t);
          renderThoughtList();
        });

        const openBtn = div.querySelector(".btn-open");
        openBtn.addEventListener("click", (ev) => {
          ev.stopPropagation();
          const url = `thought.html?id=${encodeURIComponent(t.id)}`;
          window.open(url, "_blank");
        });

        const editBtn = div.querySelector(".btn-edit");
        editBtn.addEventListener("click", (ev) => {
          ev.stopPropagation();
          currentThought = t;
          fillDetailForm(t);
          renderThoughtList();
        });

        container.appendChild(div);
      });

      updateHeaderCounts();
    }

    async function loadThoughts(collectionName) {
      if (!collectionName) return;
      try {
        setStatus("Loading thoughtsâ€¦", "busy");
        const res = await fetch(
          `${API_BASE}/thoughts?collection=` + encodeURIComponent(collectionName)
        );
        if (!res.ok) throw new Error("HTTP " + res.status);
        const data = await res.json();
        thoughts = data || [];
        setStatus("Loaded " + thoughts.length + " thoughts", "success");
      } catch (err) {
        console.error("Failed to load thoughts", err);
        setStatus("Error loading thoughts", "error");
      }
    }

    // --- Detail / form ---
    function clearDetailForm() {
      currentThought = null;
      document.getElementById("detail-title").value = "";
      document.getElementById("detail-text").value = "";
      document.getElementById("detail-collection").value = currentCollection || "";
      document.getElementById("detail-order").value = "";
      document.getElementById("detail-author").value = "";
      document.getElementById("detail-context").value = "";
      document.getElementById("detail-tags").value = "";
      document.getElementById("detail-id-pill").textContent = "New thought (no id)";
      document.getElementById("detail-created-pill").textContent = "created: â€”";
      document.getElementById("detail-updated-pill").textContent = "updated: â€”";
      document.getElementById("detail-title-label").textContent = "Start a new thought or select one.";
      document.getElementById("btn-delete").style.display = "none";
    }

    function fillDetailForm(t) {
      document.getElementById("detail-title").value = t.title || "";
      document.getElementById("detail-text").value = t.text || "";
      document.getElementById("detail-collection").value = t.collection || "";
      document.getElementById("detail-order").value =
        t.order_index !== null && t.order_index !== undefined ? t.order_index : "";
      document.getElementById("detail-author").value = t.author || "";
      document.getElementById("detail-context").value = t.context || "";
      document.getElementById("detail-tags").value = t.tags || "";
      document.getElementById("detail-title-label").textContent = t.title || "(untitled thought)";
      document.getElementById("detail-id-pill").textContent = "id: " + t.id;

      document.getElementById("detail-created-pill").textContent = t.created_at
        ? "created: " + t.created_at
        : "created: â€”";
      document.getElementById("detail-updated-pill").textContent = t.updated_at
        ? "updated: " + t.updated_at
        : "updated: â€”";

      document.getElementById("btn-delete").style.display = "inline-flex";
    }

    function readDetailForm() {
      const payload = {
        title: document.getElementById("detail-title").value.trim() || null,
        text: document.getElementById("detail-text").value.trim(),
        collection: document.getElementById("detail-collection").value.trim() || null,
        order_index: document.getElementById("detail-order").value
          ? parseInt(document.getElementById("detail-order").value, 10)
          : null,
        author: document.getElementById("detail-author").value.trim() || null,
        context: document.getElementById("detail-context").value.trim() || null,
        tags: document.getElementById("detail-tags").value.trim() || null
      };
      return payload;
    }

    async function saveThought() {
      const payload = readDetailForm();
      if (!payload.collection) {
        alert("Collection is required.");
        return;
      }
      if (!payload.text) {
        alert("Thought text is required.");
        return;
      }

      const isNew = !currentThought || !currentThought.id;
      const url = isNew
          ? `${API_BASE}/thoughts`
          : `${API_BASE}/thoughts/` + encodeURIComponent(currentThought.id);
      const method = isNew ? "POST" : "PUT";

      try {
        setStatus(isNew ? "Creating thoughtâ€¦" : "Saving changesâ€¦", "busy");
        const res = await fetch(url, {
          method,
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(payload)
        });
        if (!res.ok) throw new Error("HTTP " + res.status);
        const saved = await res.json();
        currentThought = saved;

        currentCollection = saved.collection;
        await loadCollections();
        await loadThoughts(currentCollection);
        renderCollections();
        renderThoughtList();
        fillDetailForm(saved);
        setStatus("Saved", "success");
      } catch (err) {
        console.error("Failed to save thought", err);
        setStatus("Error saving thought", "error");
      }
    }

    async function deleteThought() {
      if (!currentThought || !currentThought.id) return;
      if (!confirm("Delete this thought permanently?")) return;
      try {
        setStatus("Deletingâ€¦", "busy");
        const res = await fetch(
          `${API_BASE}/thoughts/` + encodeURIComponent(currentThought.id),
          { method: "DELETE" }
        );
        if (!res.ok) throw new Error("HTTP " + res.status);
        currentThought = null;
        await loadCollections();
        await loadThoughts(currentCollection);
        renderCollections();
        renderThoughtList();
        clearDetailForm();
        setStatus("Deleted", "success");
      } catch (err) {
        console.error("Failed to delete thought", err);
        setStatus("Error deleting thought", "error");
      }
    }

    async function saveThoughtAndGenerateWorld() {
      const payload = readDetailForm();
      if (!payload.collection) {
        alert("Collection is required.");
        return;
      }
      if (!payload.text) {
        alert("Thought text is required.");
        return;
      }

      const isNew = !currentThought || !currentThought.id;
      const url = isNew
        ? `${API_BASE}/thoughts`
        : `${API_BASE}/thoughts/` + encodeURIComponent(currentThought.id);
      const method = isNew ? "POST" : "PUT";

      try {
        setStatus("Saving thoughtâ€¦", "busy");
        const res = await fetch(url, {
          method,
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(payload),
        });
        if (!res.ok) {
          const text = await res.text();
          console.error("Failed to save thought:", text);
          setStatus("Error saving thought", "error");
          return;
        }
        const saved = await res.json();
        currentThought = saved;
        currentCollection = saved.collection;

        await loadCollections();
        await loadThoughts(currentCollection);
        renderCollections();
        renderThoughtList();
        fillDetailForm(saved);

        setStatus("Generating core ideas + worldâ€¦", "busy");

        const thinkPayload = {
          thought_id: saved.id,
          thought: saved.text,
          email: saved.email || null,
        };

        const resThink = await fetch(`${THINK_BASE}/queue_core_world`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(thinkPayload),
        });

        if (!resThink.ok) {
          const txt = await resThink.text();
          console.error("THINK /queue_core_world error:", txt);
          setStatus("Error generating world", "error");
          return;
        }

        const job = await resThink.json();
        if (job.status === "error") {
          console.error("THINK job failed:", job.error);
          setStatus("Error generating world", "error");
          return;
        }

        setStatus("Core ideas + world generated", "success");
      } catch (err) {
        console.error("saveThoughtAndGenerateWorld failed", err);
        setStatus("Error generating world", "error");
      }
    }

    async function randomThought() {
      if (!currentCollection) {
        alert("Select a collection first.");
        return;
      }
      // NOTE: your original random endpoint looked off (DELETE); leaving as-is here.
      try {
        setStatus("Sampling random thoughtâ€¦", "busy");
        const res = await fetch(
          `${API_BASE}/thoughts/` + encodeURIComponent(currentThought?.id || ""),
          { method: "DELETE" }
        );
        if (!res.ok) throw new Error("HTTP " + res.status);
        const t = await res.json();
        if (!t || !t.id) {
          setStatus("No thoughts in this collection", "idle");
          return;
        }
        currentThought = t;
        if (!thoughts.find(x => x.id === t.id)) {
          thoughts.unshift(t);
        }
        renderThoughtList();
        fillDetailForm(t);
        setStatus("Random thought loaded", "success");
      } catch (err) {
        console.error("Failed to load random thought", err);
        setStatus("Error loading random thought", "error");
      }
    }

    async function createCollection(name) {
      name = (name || "").trim();
      if (!name) return;
      if (!collections.find(c => c.name === name)) {
        collections.push({ name, count: 0 });
        renderCollections();
      }
      selectCollection(name);
    }

    document.addEventListener("DOMContentLoaded", async () => {
      await loadCollections();
      renderCollections();
      updateHeaderCounts();

      document
        .getElementById("new-collection-form")
        .addEventListener("submit", e => {
          e.preventDefault();
          const input = document.getElementById("new-collection-input");
          createCollection(input.value);
          input.value = "";
        });

      document
        .getElementById("filter-length")
        .addEventListener("change", () => renderThoughtList());

      document
        .getElementById("search-input")
        .addEventListener("input", () => renderThoughtList());

      document
        .getElementById("btn-new-thought")
        .addEventListener("click", () => clearDetailForm());

      document
        .getElementById("btn-save")
        .addEventListener("click", () => saveThought());

      document
        .getElementById("btn-save-world")
        .addEventListener("click", () => saveThoughtAndGenerateWorld());

      document
        .getElementById("btn-delete")
        .addEventListener("click", () => deleteThought());

      document
        .getElementById("btn-random")
        .addEventListener("click", () => randomThought());

      // Integration: send current scribble thought down into the think pipeline
      const sendBtn = document.getElementById("btn-send-to-think");
      if (sendBtn) {
        sendBtn.addEventListener("click", () => {
          const text = document.getElementById("detail-text").value.trim();
          if (!text) {
            alert("Enter a thought first.");
            return;
          }
          const thinkInput = document.getElementById("thought-input");
          if (thinkInput) {
            thinkInput.value = text;
            const thinkSection = document.getElementById("think-section");
            if (thinkSection && thinkSection.scrollIntoView) {
              thinkSection.scrollIntoView({ behavior: "smooth", block: "start" });
            }
          } else {
            alert("Think pipeline UI not found on this page.");
          }
        });
      }
    });
  </script>

  <!-- === Think JS (same logic, but setStatus â†’ setThinkStatus to avoid name clash) === -->
  <script>
    const statusEl = document.getElementById("status");

    const adjacentOutput = document.getElementById("adjacent-output");
    const coreThoughtsOutput = document.getElementById("core-thoughts-output");
    const expansionOutput = document.getElementById("expansion-output");
    const coreIdeasOutput = document.getElementById("core-ideas-output");
    const worldContextOutput = document.getElementById("world-context-output");
    const bridgesOutput = document.getElementById("bridges-output");

    const adjacentBtn = document.getElementById("adjacent-btn");
    const coreThoughtsBtn = document.getElementById("core-thoughts-btn");
    const expandBtn = document.getElementById("expand-btn");
    const coreIdeasBtn = document.getElementById("core-ideas-btn");
    const worldContextBtn = document.getElementById("world-context-btn");
    const bridgesBtn = document.getElementById("bridges-btn");
    const pipelineBtn = document.getElementById("pipeline-btn");

    const coreThoughtManualInput = document.getElementById("core-thought-manual");

    // State for iterative testing
    let lastThought = "";
    let lastAdjacent = null;
    let lastCoreThoughts = null;
    let lastCoreThoughtExpanded = null;
    let lastExpansion = "";
    let lastCoreIdeas = null;
    let lastWorldContext = "";

    function setThinkStatus(msg, isError = false) {
      statusEl.textContent = msg;
      if (isError) {
        statusEl.classList.add("error");
      } else {
        statusEl.classList.remove("error");
      }
    }

    function disableAllButtons(disabled) {
      [
        adjacentBtn,
        coreThoughtsBtn,
        expandBtn,
        coreIdeasBtn,
        worldContextBtn,
        bridgesBtn,
        pipelineBtn
      ].forEach(btn => btn.disabled = disabled);
    }

    async function callEndpoint(path, payload) {
      const res = await fetch(path, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(payload)
      });
      if (!res.ok) {
        let err = {};
        try {
          err = await res.json();
        } catch (_) {}
        throw new Error(err.error || res.statusText);
      }
      return res.json();
    }

    async function runAdjacent() {
      const thought = document.getElementById("thought-input").value.trim();
      if (!thought) {
        setThinkStatus("Enter a seed thought first.", true);
        return;
      }
      lastThought = thought;
      setThinkStatus("Generating adjacent thoughts...");
      disableAllButtons(true);
      try {
        const data = await callEndpoint("/think/adjacent", { thought });
        lastAdjacent = data;
        if (data.adjacent_thoughts) {
          const lines = data.adjacent_thoughts.map(t => `${t.id}. ${t.text}`);
          adjacentOutput.textContent = lines.join("\n");
        } else {
          adjacentOutput.textContent = JSON.stringify(data, null, 2);
        }
        setThinkStatus("Adjacent thoughts generated.");
      } catch (e) {
        setThinkStatus(e.message, true);
      } finally {
        disableAllButtons(false);
      }
    }

    async function runCoreThoughts() {
      const thought = (lastThought || document.getElementById("thought-input").value.trim());
      if (!thought) {
        setThinkStatus("Enter a seed thought first.", true);
        return;
      }
      lastThought = thought;
      setThinkStatus("Generating core thoughts (THINK text block)â€¦");
      disableAllButtons(true);
      try {
        const data = await callEndpoint("/think/core_thoughts", { thought });
        const block = (data.core_thoughts_text || "").trim();
        lastCoreThoughts = { core_thoughts_text: block };

        coreThoughtsOutput.textContent = block || "(empty core thoughts text)";
        setThinkStatus("Core thoughts generated as a single text block.");
      } catch (e) {
        setThinkStatus(e.message, true);
      } finally {
        disableAllButtons(false);
      }
    }

    async function runExpansion() {
      setThinkStatus("Expanding core thought...");
      disableAllButtons(true);
      try {
        let coreThought = coreThoughtManualInput.value.trim();
        if (!coreThought) {
          if (!lastCoreThoughts || !lastCoreThoughts.core_thoughts || lastCoreThoughts.core_thoughts.length === 0) {
            setThinkStatus("No core thoughts available. Generate core thoughts or provide a core thought manually.", true);
            return;
          }
          coreThought = lastCoreThoughts.core_thoughts[0].text;
        }

        const data = await callEndpoint("/think/expand_core_thought", { core_thought: coreThought });
        lastCoreThoughtExpanded = data;
        lastExpansion = data.expansion || "";
        expansionOutput.textContent = "Core thought:\n" + data.core_thought + "\n\nExpansion:\n" + data.expansion;
        setThinkStatus("Core thought expanded.");
      } catch (e) {
        setThinkStatus(e.message, true);
      } finally {
        disableAllButtons(false);
      }
    }

    async function runCoreIdeas() {
      const block =
        (lastCoreThoughts && lastCoreThoughts.core_thoughts_text) ||
        coreThoughtsOutput.textContent.trim();

      if (!block) {
        setThinkStatus("No core thoughts available. Generate core thoughts first.", true);
        return;
      }

      setThinkStatus("Distilling core ideas from core thoughts blockâ€¦");
      disableAllButtons(true);
      try {
        const data = await callEndpoint("/think/core_ideas", { thought: block });
        const text = (data.core_ideas_text || "").trim();

        lastCoreIdeas = { core_ideas_text: text };
        coreIdeasOutput.textContent = text || "(empty core ideas text)";

        setThinkStatus("Core ideas distilled as a text block.");
      } catch (e) {
        setThinkStatus(e.message, true);
      } finally {
        disableAllButtons(false);
      }
    }

    async function runWorldContext() {
      const block =
        (lastCoreIdeas && lastCoreIdeas.core_ideas_text) ||
        coreIdeasOutput.textContent.trim();

      if (!block) {
        setThinkStatus("No core ideas available. Distill core ideas first.", true);
        return;
      }

      setThinkStatus("Generating world context from core ideas text blockâ€¦");
      disableAllButtons(true);
      try {
        const data = await callEndpoint("/think/world_context", {
          core_ideas_text: block
        });
        const wc = (data.world_context || "").trim();

        lastWorldContext = wc;
        worldContextOutput.textContent = wc || "(empty world context)";

        setThinkStatus("World context generated from core ideas block.");
      } catch (e) {
        setThinkStatus(e.message, true);
      } finally {
        disableAllButtons(false);
      }
    }

    async function runBridges() {
      const ctx = lastWorldContext || worldContextOutput.textContent;
      if (!ctx) {
        setThinkStatus("No world context available. Generate world context first.", true);
        return;
      }
      setThinkStatus("Generating bridges...");
      disableAllButtons(true);
      try {
        const data = await callEndpoint("/think/bridges", { world_context: ctx });
        bridgesOutput.textContent = data.bridges || JSON.stringify(data, null, 2);
        setThinkStatus("Bridges generated.");
      } catch (e) {
        setThinkStatus(e.message, true);
      } finally {
        disableAllButtons(false);
      }
    }

    async function runPipeline() {
      const thought = document.getElementById("thought-input").value.trim();
      if (!thought) {
        setThinkStatus("Enter a seed thought first.", true);
        return;
      }
      lastThought = thought;
      setThinkStatus("Running full pipeline (no expansion step)â€¦");
      disableAllButtons(true);
      try {
        const data = await callEndpoint("/think/pipeline", { thought });

        lastAdjacent = data.adjacent || null;
        lastCoreThoughts = { core_thoughts_text: data.core_thoughts_text || "" };
        lastCoreIdeas = { core_ideas_text: data.core_ideas_text || "" };
        lastWorldContext = data.world_context || "";

        if (data.adjacent && data.adjacent.adjacent_thoughts) {
          const lines = data.adjacent.adjacent_thoughts.map(t => `${t.id}. ${t.text}`);
          adjacentOutput.textContent = lines.join("\n");
        } else if (data.adjacent) {
          adjacentOutput.textContent = JSON.stringify(data.adjacent, null, 2);
        } else {
          adjacentOutput.textContent = "(no adjacent thoughts)";
        }

        coreThoughtsOutput.textContent =
          data.core_thoughts_text || "(no core thoughts text)";

        expansionOutput.textContent =
          "(expansion step skipped in pipeline; use the Expand control manually if you still want to experiment with expansions.)";

        coreIdeasOutput.textContent =
          data.core_ideas_text || "(no core ideas text)";

        worldContextOutput.textContent =
          data.world_context || "(no world context)";

        bridgesOutput.textContent =
          data.bridges || "(no bridges)";

        setThinkStatus("Full pipeline complete (thought â†’ adjacent â†’ core thoughts â†’ core ideas â†’ world context â†’ bridges). Stored with id " + data.id + ".");
      } catch (e) {
        setThinkStatus(e.message, true);
      } finally {
        disableAllButtons(false);
      }
    }

    adjacentBtn.addEventListener("click", runAdjacent);
    coreThoughtsBtn.addEventListener("click", runCoreThoughts);
    expandBtn.addEventListener("click", runExpansion);
    coreIdeasBtn.addEventListener("click", runCoreIdeas);
    worldContextBtn.addEventListener("click", runWorldContext);
    bridgesBtn.addEventListener("click", runBridges);
    pipelineBtn.addEventListener("click", runPipeline);
  </script>
</body>
</html>
