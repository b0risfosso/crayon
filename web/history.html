<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Narratives (Sticky Notes)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    :root{
      --bg:#f5f5f5; --note:#fff8a6; --note-border:#d4c96b; --line:#888;
      --font: system-ui, sans-serif;
    }
    html,body{height:100%;margin:0;background:var(--bg);font-family:var(--font);}    
    body{display:flex;flex-direction:column;}
    nav{padding:8px 16px;background:#222;color:#eee;font-size:14px}
    nav a{color:#9fd3ff;margin-right:12px;text-decoration:none}

    /* the whole infinite board is inside a pan/zoom viewport */
    #viewport{position:relative;flex:1;overflow:hidden;background:var(--bg);}
    #board-wrapper{position:absolute;inset:0;transform-origin:0 0;}
    #board{position:relative;min-height:2000px;min-width:2000px;}

    .note{
      position:absolute;width:260px;min-height:120px;box-sizing:border-box;
      background:var(--note);border:2px solid var(--note-border);border-radius:6px;
      box-shadow:0 3px 6px rgba(0,0,0,.2);padding:8px 8px 28px 8px;cursor:grab;user-select:none;
      transition:height .15s ease;
    }
    .note.dragging{opacity:.85;cursor:grabbing;box-shadow:0 8px 16px rgba(0,0,0,.35);}    
    .note-header{font-weight:600;margin-bottom:6px;font-size:14px;cursor:pointer;}
    .note.collapsed .note-body{display:none;}
    .note-body{white-space:pre-wrap;font-size:13px;line-height:1.25;max-height:400px;overflow:auto;}
    .note-actions{position:absolute;right:6px;bottom:4px;font-size:11px;color:#333;}
    .note-actions button{background:none;border:none;padding:0 4px;cursor:pointer;color:#333}
    .note-actions button:hover{text-decoration:underline;}

    svg#edges{position:absolute;inset:0;overflow:visible;pointer-events:none;}
    path.edge{stroke:var(--line);stroke-width:2;fill:none;marker-end:url(#arrowhead);} 

    #status{position:fixed;bottom:8px;left:8px;background:#0008;color:#fff;padding:4px 8px;border-radius:4px;font-size:12px;}
    #toolbar{position:fixed;top:70px;right:12px;background:#fff;border:1px solid #ccc;border-radius:6px;padding:8px;box-shadow:0 3px 8px rgba(0,0,0,.2);font-size:12px}
    #toolbar label{display:block;margin-bottom:4px}
    #toolbar input[type="checkbox"]{vertical-align:middle}
  </style>
</head>
<body>
  <nav>
    <a href="prompt.html">Imagine</a> |
    <a href="history.html">Narratives</a> |
    <a href="organize.html">Organize</a>
  </nav>

  <div id="viewport">
    <div id="board-wrapper">
      <svg id="edges"></svg>
      <div id="board"></div>
    </div>
  </div>

  <div id="toolbar">
    <label><input id="toggle-arrows" type="checkbox" checked> show arrows</label>
    <button id="auto-layout">Auto layout</button>
    <button id="save-pos">Save positions</button>
    <button id="reset-pos">Reset positions</button>
    <button id="zoom-in">+</button>
    <button id="zoom-out">‚àí</button>

    <div style="margin-top:6px">Zoom: <span id="zoom-level">100%</span></div>
  </div>

  <div id="status" hidden></div>

<script>
let DATA = [];
const board      = document.getElementById('board');
const edgesSvg   = document.getElementById('edges');
const wrapper    = document.getElementById('board-wrapper');
const zoomLabel  = document.getElementById('zoom-level');
let scale = 1, origin = {x:0,y:0};

async function loadData(){
  const r = await fetch('/api/history');
  DATA = await r.json();
  buildTree();
}

function buildTree(){
  const byId = Object.fromEntries(DATA.map(x=>[x.id,x]));
  DATA.forEach(x=>x.children=[]);
  const roots=[];
  DATA.forEach(x=>{ if(x.parent && byId[x.parent]) byId[x.parent].children.push(x); else roots.push(x); });
  render();
}

function render(){
  board.innerHTML='';
  const saved = JSON.parse(localStorage.getItem('notePositions')||'{}');
  DATA.forEach((node,i)=>{
    const div = document.createElement('div');
    div.className='note';
    div.dataset.id = node.id;
    const pos = saved[node.id] || {x: 80 + (i%4)*300, y: 80 + Math.floor(i/4)*220};
    div.style.left = pos.x + 'px';
    div.style.top  = pos.y + 'px';

    div.innerHTML = `
      <div class="note-header">üó®Ô∏è ${escapeHtml(node.user.slice(0,80))}</div>
      <div class="note-body">${escapeHtml(node.answer)}</div>
      <div class="note-actions">
        <button data-action="focus">focus</button>
        <button data-action="edit">edit</button>
        <button data-action="collapse">toggle</button>
      </div>`;

    board.appendChild(div);
  });

  drawEdges();
  enableDrag();
  enableCollapse();
}

// ---------- edges ----------
function drawEdges(){
  edgesSvg.innerHTML = `
    <defs>
      <marker id="arrowhead" markerWidth="8" markerHeight="6" refX="8" refY="3" orient="auto">
        <polygon points="0 0, 8 3, 0 6" fill="var(--line)"></polygon>
      </marker>
    </defs>`;

  if(!document.getElementById('toggle-arrows').checked) return;

  const cache = {};
  const getCenter = id => {
    if(cache[id]) return cache[id];
    const el = document.querySelector(`.note[data-id="${id}"]`);
    const r = el.getBoundingClientRect();
    const wb = board.getBoundingClientRect();
    return cache[id] = { x:(r.left-wb.left + r.width/2)/scale, y:(r.top-wb.top + r.height/2)/scale };
  };

  DATA.forEach(n=>{
    if(!n.parent) return;
    const a=getCenter(n.parent), b=getCenter(n.id);
    edgesSvg.insertAdjacentHTML('beforeend', edgePath(a,b));
  });
}

function edgePath(a,b){
  const dx=(b.x-a.x)*0.3;
  return `<path class="edge" d="M ${a.x},${a.y} C ${a.x+dx},${a.y} ${b.x-dx},${b.y} ${b.x},${b.y}" />`;
}

// ---------- drag ----------
let dragState=null;
function enableDrag(){
  document.querySelectorAll('.note').forEach(n=>{
    n.addEventListener('mousedown', startDrag);
    n.addEventListener('touchstart', startDrag, {passive:false});
  });
}
function startDrag(e){
  if(e.target.closest('.note-actions')) return;
  e.preventDefault();
  const el=e.currentTarget;
  const pt = pointerPos(e);
  dragState={el, offX:pt.x-parseInt(el.style.left), offY:pt.y-parseInt(el.style.top)};
  el.classList.add('dragging');
  window.addEventListener('mousemove', onDrag);
  window.addEventListener('mouseup', endDrag);
  window.addEventListener('touchmove', onDrag, {passive:false});
  window.addEventListener('touchend', endDrag);
}
function onDrag(e){
  if(!dragState) return;
  e.preventDefault();
  const pt = pointerPos(e);
  dragState.el.style.left = (pt.x-dragState.offX) + 'px';
  dragState.el.style.top  = (pt.y-dragState.offY) + 'px';
  drawEdges();
}
function endDrag(){
  if(!dragState) return;
  dragState.el.classList.remove('dragging');
  savePositions();
  dragState=null;
  window.removeEventListener('mousemove', onDrag);
  window.removeEventListener('mouseup', endDrag);
  window.removeEventListener('touchmove', onDrag);
  window.removeEventListener('touchend', endDrag);
}
function pointerPos(e){
  const clientX = e.touches?e.touches[0].clientX:e.clientX;
  const clientY = e.touches?e.touches[0].clientY:e.clientY;
  const rect = board.getBoundingClientRect();
  return { x:(clientX-rect.left)/scale, y:(clientY-rect.top)/scale };
}

// ---------- collapse / expand ----------
function enableCollapse(){
  document.querySelectorAll('.note-header').forEach(h=>{
    h.addEventListener('click', ()=>{
      const n = h.parentElement; n.classList.toggle('collapsed');
      drawEdges(); savePositions();
    });
  });
  document.querySelectorAll('.note-actions [data-action="collapse"]').forEach(btn=>{
    btn.addEventListener('click', (e)=>{
      const n = e.target.closest('.note'); n.classList.toggle('collapsed');
      drawEdges(); savePositions();
    });
  });
}

// ---------- save / restore ----------
function savePositions(){
  const pos={};
  document.querySelectorAll('.note').forEach(n=>{
    pos[n.dataset.id]={x:parseInt(n.style.left), y:parseInt(n.style.top), collapsed:n.classList.contains('collapsed')};
  });
  localStorage.setItem('notePositions', JSON.stringify(pos));
  flash('saved');
}
function resetPositions(){
  localStorage.removeItem('notePositions');
  render();
  flash('reset');
}

// ---------- auto layout ----------
function autoLayout(){
  const byId = Object.fromEntries(DATA.map(x=>[x.id,x]));
  const roots = DATA.filter(x=>!x.parent || !byId[x.parent]);
  const depth={};
  function dfs(n,d){depth[n.id]=d;n.children.forEach(c=>dfs(c,d+1));}
  roots.forEach(r=>dfs(r,0));
  const cols={}; Object.entries(depth).forEach(([id,d])=>{(cols[d]||=[]).push(id);});
  const gapX=320,gapY=220; const pos={};
  Object.entries(cols).forEach(([d,ids])=>{ids.forEach((id,i)=>{pos[id]={x:80+d*gapX,y:80+i*gapY};});});
  localStorage.setItem('notePositions', JSON.stringify(pos));
  render(); flash('auto layout');
}

// ---------- zoom / pan ----------
let isPanning=false, panStart={x:0,y:0}, originStart={x:0,y:0};
wrapper.addEventListener('mousedown', e=>{
  if(e.target.closest('.note')) return; // don't pan when grabbing notes
  isPanning=true; panStart={x:e.clientX,y:e.clientY}; originStart={...origin};
  document.body.style.cursor='grab';
});
window.addEventListener('mouseup', ()=>{isPanning=false;document.body.style.cursor='';});
window.addEventListener('mousemove', e=>{
  if(!isPanning) return;
  origin.x = originStart.x + (e.clientX-panStart.x)/scale;
  origin.y = originStart.y + (e.clientY-panStart.y)/scale;
  applyTransform();
});

// wheel to zoom (Ctrl/Meta for precision NOT required)
window.addEventListener('wheel', e=>{
  if(e.target.closest('.note')) return; // avoid accidental zoom while scrolling note text
  const delta = e.deltaY>0 ? -0.1 : 0.1;
  const newScale = clamp(scale + delta*scale, 0.2, 2.5);
  // zoom to mouse position
  const rect = wrapper.getBoundingClientRect();
  const mx = (e.clientX - rect.left)/scale + origin.x;
  const my = (e.clientY - rect.top)/scale + origin.y;
  scale = newScale;
  origin.x = mx - (e.clientX - rect.left)/scale;
  origin.y = my - (e.clientY - rect.top)/scale;
  applyTransform();
  drawEdges();
  zoomLabel.textContent = Math.round(scale*100)+'%';
}, {passive:false});

function applyTransform(){
  wrapper.style.transform = `translate(${-origin.x*scale}px, ${-origin.y*scale}px) scale(${scale})`;
}

function clamp(v,min,max){return v<min?min:v>max?max:v;}

// ---------- utils ----------
function escapeHtml(str){
  return String(str).replace(/[&<>"']/g, s=>({"&":"&amp;","<":"&lt;",">":"&gt;","\"":"&quot;","'":"&#39;"}[s]));
}
function flash(msg){
  const box=document.getElementById('status');
  box.textContent=msg; box.hidden=false;
  clearTimeout(box._t); box._t=setTimeout(()=>box.hidden=true,1200);
}

// toolbar events
 document.getElementById('toggle-arrows').addEventListener('change', drawEdges);
 document.getElementById('save-pos').addEventListener('click', savePositions);
 document.getElementById('reset-pos').addEventListener('click', resetPositions);
 document.getElementById('auto-layout').addEventListener('click', autoLayout);
 document.getElementById('zoom-in').onclick  = ()=> setZoom(scale*1.15);
 document.getElementById('zoom-out').onclick = ()=> setZoom(scale/1.15);

function setZoom(newScale){
  const rect = wrapper.getBoundingClientRect();
  const cx = rect.width/2, cy = rect.height/2; // zoom toward center
  const mx = cx/scale + origin.x;
  const my = cy/scale + origin.y;
  scale = clamp(newScale, 0.2, 2.5);
  origin.x = mx - cx/scale;
  origin.y = my - cy/scale;
  applyTransform();
  drawEdges();
  zoomLabel.textContent = Math.round(scale*100)+'%';
}


loadData();
</script>
</body>
</html>
