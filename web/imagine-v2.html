<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Fantasiagenesis · Imagine v2</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root { color-scheme: light dark; }
    body { font-family: system-ui, sans-serif; margin: 2rem; max-width: 1200px; }
    header h1 { font-size: 1.6rem; margin-bottom: .4rem; }
    .muted { opacity:.85; font-size:.9rem; }
    .row { display:flex; align-items:center; gap:.6rem; flex-wrap:wrap; }
    textarea { padding:.6rem .7rem; min-width: 28rem; width: min(92vw, 50rem); border:1px solid #ccc; border-radius:.5rem; }
    input[type="email"] { padding:.55rem .65rem; min-width: 24rem; border:1px solid #ccc; border-radius:.5rem; }
    button { padding:.6rem .9rem; border:0; border-radius:.5rem; cursor:pointer; background:#0b5cff; color:#fff; }
    button.secondary { background:#444; }
    .chip { display:inline-flex; align-items:center; gap:.35rem; padding:.35rem .55rem; border:1px solid #ccc; border-radius:.6rem; background: rgba(0,0,0,.02); }
    .providers { display:flex; gap:.6rem; flex-wrap:wrap; }
    .badge { font-size:.8rem; padding:.15rem .45rem; border:1px solid #ddd; border-radius:.4rem; }
    .panel { border:1px solid color-mix(in oklab, CanvasText 20%, transparent); border-radius:.6rem; padding: .75rem 1rem; background: color-mix(in oklab, Canvas 92%, CanvasText 8%); }
    .panel.blue { border-color: color-mix(in oklab, dodgerblue 40%, CanvasText 20%); background: color-mix(in oklab, Canvas 88%, dodgerblue 12%); box-shadow: 0 1px 0 rgba(30,144,255,.12) inset; }
    .meta { font-size:.9rem; opacity:.9; margin:.25rem 0 .8rem; }
    .grid { display:grid; gap:.8rem; }
    details { border:1px solid #d0d0d0; border-radius:.6rem; padding:.75rem 1rem; background: rgba(0,0,0,.02); }
    summary { cursor:pointer; font-weight:600; }
    .thesis { margin:.4rem 0 .3rem; font-style: italic; white-space: pre-wrap; }
    .targets { margin:.25rem 0 .5rem 1.25rem; }
    .provider-block { border:1px solid #e2e2e2; border-radius:.6rem; padding:.6rem .8rem; background: rgba(0,0,0,.02); }
    .provider-head { display:flex; align-items:center; gap:.5rem; margin-bottom:.4rem; }
    .provider-name { font-weight:600; }
    .provider-status { font-size:.9rem; opacity:.8; }
    .seedbox { border-top:1px dashed #c8c8c8; margin-top:.5rem; padding-top:.5rem; }
    .seed { margin:.35rem 0; padding:.5rem .6rem; border:1px solid #e0e0e0; border-radius:.5rem; background:#fff; }
    a.seedlink { text-decoration:none; color:inherit; display:block; }
    a.seedlink:hover .seed { outline:2px solid #9bbcff; outline-offset:2px; }
    .error, .seed-error, .dim-error { color:#b00020; white-space: pre-wrap; }
    pre { background:#f6f6f6; padding:.75rem; border-radius:.5rem; overflow-x:auto; }
    .group-title { font-size:1.05rem; font-weight:600; display:flex; align-items:center; gap:.4rem; }
    .domain-card { border:1px solid #e3e3e3; border-radius:.6rem; padding:.6rem .8rem; background: rgba(0,0,0,.02); }
    .domain-head { display:flex; align-items:center; gap:.6rem; }
    .columns { display:grid; gap:1rem; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); }
    .pro-sep { height:.5rem; }
  </style>
</head>
<body>
    <header>
        <h1>Fantasiagenesis · Imagine v2</h1>
        <div style="display:flex; gap:.5rem; align-items:center; font-size:.85rem; opacity:.85;">
        <a href="garden.html"
        style="padding:.45rem .7rem; border:1px solid color-mix(in oklab, CanvasText 18%, transparent);
        background:color-mix(in oklab, Canvas 92%, CanvasText 8%); border-radius:.5rem; text-decoration:none; color:inherit;">See Your Garden</a>
        <a href="dirt.html"
        style="padding:.45rem .7rem; border:1px solid color-mix(in oklab, CanvasText 18%, transparent);
        background:color-mix(in oklab, Canvas 92%, CanvasText 8%); border-radius:.5rem; text-decoration:none; color:inherit;">Build Boxes of Dirt</a>
        </div>
        </header>
        
        <section class="panel blue" aria-labelledby="h-instructions">
        <header><p id="h-instructions">Instructions</p></header>
        <div class="content" style="font-size:.9rem; line-height:1.45;">
        <ul style="margin:0; padding-left:1.1rem; display:grid; gap:.4rem;">
        <li>Enter one or more <strong>core stories</strong> (one per line) - things you imagine, want to create, or understand.</li>
        <li>Optionally enter your email to save outputs to your private garden.</li>
        <li>Click <em>Generate</em> to run with the default provider (OpenAI).</li>
        </ul>
        <p class="muted" style="margin-top:.6rem;">Email is required if you want results saved & deep‑linked.</p>
        </div>
        </section>
        
        <form id="form" autocomplete="off" style="display:grid; gap:.7rem; margin:1rem 0; align-items:start;">
        <textarea id="coreStories" rows="4" placeholder="Enter one or more core stories — one per line (e.g., oceans, holding the sun, Chicago microgrids)"></textarea>
        
        <div class="row">
        <span class="muted">Provider:</span>
        <label class="chip"><input id="providerOpenAI" type="checkbox" value="openai" checked disabled> openai</label>
        </div>
        
        <div class="row">
        <input type="email" id="emailInput" placeholder="Enter email to save results to your personal garden (optional)" />
        <button type="button" id="saveEmailBtn" class="secondary" title="Save email locally">Save email</button>
        </div>
        
        <div class="row">
        <button type="submit">Generate</button>
        <span id="hint" class="muted">Runs: Core stories → domain architecture → dimensions → seeds using OpenAI.</span>
        </div>
        </form>
        
        <div id="globalStatus" class="meta"></div>
        <div id="container"></div>

  <script>
    // --- Config ---
    const CORE_API_BASE = ''; // domain_architect lives here
    const DIM_API_BASE = ''; // same-origin (''), override if needed

    const PROVIDER = 'openai';
    const MAX_SEED_CONCURRENCY = 4;
    const EMAIL_KEY = 'fg_user_email';

    // --- Elements ---
    const form = document.getElementById('form');
    const storiesInput = document.getElementById('coreStories');
    const globalStatus = document.getElementById('globalStatus');
    const container = document.getElementById('container');
    const saveEmailBtn = document.getElementById('saveEmailBtn');

    // --- Email storage helpers ---
    function saveEmailToStorage(email){ const v = String(email||'').trim().toLowerCase(); if(v) localStorage.setItem(EMAIL_KEY, v); else localStorage.removeItem(EMAIL_KEY); }
    function readEmailFromStorage(){ return (localStorage.getItem(EMAIL_KEY)||'').trim().toLowerCase(); }
    function prefillEmailFromStorage(){ const input = document.getElementById('emailInput'); const v = readEmailFromStorage(); if(input && v && !input.value) input.value = v; }
    function currentEmail(){ const typed = (document.getElementById('emailInput')?.value||'').trim().toLowerCase(); return typed || readEmailFromStorage(); }

    saveEmailBtn?.addEventListener('click', ()=>{ const em=(document.getElementById('emailInput')?.value||'').trim().toLowerCase(); if(!em){ alert('Enter an email to save.'); return; } saveEmailToStorage(em); const old=saveEmailBtn.textContent; saveEmailBtn.textContent='Saved'; setTimeout(()=> saveEmailBtn.textContent=old, 1200); });

    // --- Net utils ---
    function el(tag, opts={}){ const node=document.createElement(tag); if(opts.className) node.className=opts.className; if('text' in opts) node.textContent=opts.text; if('html' in opts) node.innerHTML=opts.html; if(opts.attrs) Object.entries(opts.attrs).forEach(([k,v])=> node.setAttribute(k,v)); return node; }
    function escapeHtml(s){ return String(s).replaceAll('&','&amp;').replaceAll('<','&lt;').replaceAll('>','&gt;').replaceAll('"','&quot;').replaceAll("'",'&#39;'); }
    const sleep = ms => new Promise(r=> setTimeout(r, ms));

    async function fetchWithTimeout(url, options={}, timeoutMs=180000){ const controller=new AbortController(); const id=setTimeout(()=> controller.abort(), timeoutMs); try{ return await fetch(url, { ...options, signal: controller.signal }); } finally{ clearTimeout(id); } }
    async function postJSON(url, body, timeoutMs=180000){ const resp = await fetchWithTimeout(url, { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify(body) }, timeoutMs); let data; try{ data=await resp.json(); } catch{ throw new Error(`Non-JSON response from ${url} (status ${resp.status})`); } if(!resp.ok){ const msg=(data && (data.error||data.detail))? `${data.error||''} ${data.detail||''}`.trim() : `HTTP ${resp.status}`; throw new Error(msg); } return data; }
    async function getJSON(url, timeoutMs=180000){ const resp = await fetchWithTimeout(url, {}, timeoutMs); let data; try{ data=await resp.json(); } catch{ throw new Error(`Non-JSON response from ${url} (status ${resp.status})`); } if(!resp.ok){ const msg=(data && (data.error||data.detail))? `${data.error||''} ${data.detail||''}`.trim() : `HTTP ${resp.status}`; throw new Error(msg); } return data; }

    // --- Narrative cache for deep-links ---
    const narrativeIdByTitle = new Map();
    async function ensureNarrativesCache(email){ if(narrativeIdByTitle.size) return; if(!email) return; const rows = await getJSON(`/api/narratives?email=${encodeURIComponent(email)}`); rows.forEach(r=>{ if(r && r.title) narrativeIdByTitle.set(r.title, r.id); }); }
    function getNarrativeIdForTitle(title){ return narrativeIdByTitle.get(title) || null; }

    async function runProviderForDomain(domainName,email,container){ const status=el('div',{className:'muted',text:'Generating dimensions…'}); container.append(status); try{ const dimData=await postJSON(`${DIM_API_BASE}/api/narrative-dimensions`,{domain:domainName,provider:PROVIDER,email},180000); const dims=Array.isArray(dimData?.dimensions)?dimData.dimensions:[]; status.textContent=`Dimensions: ${dims.length}`; if(!dims.length)return; const narrativeId=getNarrativeIdForTitle(dimData.domain||domainName); for(const dim of dims){ const card=el('details'); card.append(el('summary',{text:dim.title||dim.name||'Untitled'})); const thesis=el('div',{className:'thesis',text:dim.description||dim.thesis||''}); card.append(thesis); const seedStatus=el('div',{className:'muted',text:'Generating seeds…'}); card.append(seedStatus); container.append(card); const data=await postJSON(`/api/narrative-seeds`,{domain:domainName,dimension:dim.name||dim.title||'',description:dim.description||dim.thesis||'',targets:dim.targets||[],provider:PROVIDER,email}); seedStatus.textContent=''; if(Array.isArray(data.seeds)){ data.seeds.forEach(s=>{ const a=el('a',{className:'seedlink',attrs:{href:linkHref(narrativeId,dim.id,s.id||null),target:'_blank',rel:'noopener'}}); const seed=el('div',{className:'seed'}); seed.innerHTML=`<strong>A (Problem):</strong> ${escapeHtml(s.problem||'')}<br><strong>B (Objective):</strong> ${escapeHtml(s.objective||'')}<br><strong>Solution (Link):</strong> ${escapeHtml(s.solution||'')}`; a.append(seed); card.append(a); }); } else { seedStatus.textContent='No seeds returned.'; } } }catch(e){ status.textContent=`Failed: ${e.message||e}`; } }


    // --- Rendering helpers ---
    function linkHref(nid, did, sid){ const p=new URLSearchParams(); if(nid) p.set('nid', String(nid)); if(did) p.set('did', String(did)); if(sid) p.set('sid', String(sid)); return `dirt.html${p.toString()?`?${p.toString()}`:''}`; }
    function norm(s){ return String(s||'').replace(/\s+/g,' ').trim().toLowerCase(); }

    async function reconcileSeedLinks(email, narrativeId, dimensionId, anchors){ try{ const data= await getJSON(`/api/dimensions/${encodeURIComponent(dimensionId)}/seeds?email=${encodeURIComponent(email)}`); const list = Array.isArray(data?.seeds)? data.seeds : []; const byKey = new Map(list.map(row=>{ const k=[row.problem,row.objective,row.solution].map(norm).join('||'); return [k, row.id]; })); anchors.forEach(a=>{ const seed = a.firstChild; if(!seed || seed.dataset.hasId==='1') return; const k=[seed.dataset.problem, seed.dataset.objective, seed.dataset.solution].map(norm).join('||'); const sid = byKey.get(k); if(sid){ a.setAttribute('href', linkHref(narrativeId, dimensionId, sid)); seed.dataset.hasId='1'; } }); } catch {/* non-fatal */} }

    function makeCoreStorySection(core){ const section=el('section'); const h2=el('h2', { text: core }); section.appendChild(h2); const meta=el('div', { className:'meta' }); const err=el('div', { className:'error' }); section.append(meta, err); container.appendChild(section); return { section, meta, err }; }

    function makeDomainGroupBlock(title){ const wrap=el('div', { className:'panel' }); const head=el('div', { className:'group-title', html: `${escapeHtml(title)} <span class="badge">group</span>` }); const cols=el('div', { className:'columns' }); wrap.append(head, cols); return { wrap, cols }; }

    function makeDomainCard(domain){ const card=el('div', { className:'domain-card' }); const head=el('div', { className:'domain-head' }); head.append(el('span', { text: domain.name||'Untitled domain' }), el('span',{ className:'badge', text:'domain'})); const desc=el('div', { className:'muted', text: domain.description||'' }); const providerWrap=el('div', { className:'grid' }); card.append(head, desc, providerWrap); return { card, providerWrap }; }

    function renderDimensionCard(idx, dim, domainName, provider, email){ const card=el('details'); const title = dim.title || dim.name || 'Untitled'; const sum=el('summary', { text: `${idx+1}. ${title}` }); const thesisText = dim.description || dim.thesis || ''; const thesis=el('div', { className:'thesis', text: thesisText }); const targetsList=el('ul', { className:'targets' }); (Array.isArray(dim.targets)? dim.targets: []).forEach(t=> targetsList.appendChild(el('li', { text: t })));
      const seedBox=el('div', { className:'seedbox' }); const seedHeader=el('div', { className:'seed-title', html:`Seeds <span class="badge">${provider}</span>` }); const seedStatus=el('div', { className:'muted', text:'Waiting…' }); const seedWrap=el('div'); seedBox.append(seedHeader, seedStatus, seedWrap); card.append(sum, thesis, targetsList, seedBox);
      card._seedPayload = { domain: domainName, dimension: dim.name || dim.title || '', description: thesisText, targets: Array.isArray(dim.targets)? dim.targets: [], provider, email };
      card._seedUI = { seedStatus, seedWrap }; card._dimId = dim.id || null; card._narrativeId = null; return card; }

    async function createSeedsForDimension(payload, ui, extras, tries=2){ const { seedStatus, seedWrap } = ui; const { email, narrativeId, dimensionId } = extras || {}; const anchors=[]; try{ seedStatus.textContent='Generating seeds…'; const data = await postJSON(`${DIM_API_BASE}/api/narrative-seeds`, payload, 180000); seedStatus.textContent=''; if(Array.isArray(data.seeds)){
          if(!data.seeds.length){ seedStatus.textContent='No seeds returned.'; return; }
          data.seeds.forEach(s=>{ const href = linkHref(narrativeId, dimensionId, s.id||null); const a=el('a', { className:'seedlink', attrs:{ href, target:'_blank', rel:'noopener' } }); const seed=el('div', { className:'seed' }); seed.innerHTML = `<strong>A (Problem):</strong> ${escapeHtml(s.problem||'')}<br>` +
              `<strong>B (Objective):</strong> ${escapeHtml(s.objective||'')}<br>` +
              `<strong>Solution (Link):</strong> ${escapeHtml(s.solution||'')}` +
              (s.provider? `<br><small>provider: ${escapeHtml(s.provider)}</small>`:'') +
              (s.created_at? `<br><small>${escapeHtml(s.created_at)}</small>`:'');
            seed.dataset.problem = (s.problem||''); seed.dataset.objective=(s.objective||''); seed.dataset.solution=(s.solution||''); seed.dataset.hasId = s.id? '1':'0'; a.appendChild(seed); seedWrap.appendChild(a); anchors.push(a); });
          if(email && dimensionId && anchors.some(a=> a.firstChild?.dataset?.hasId==='0')){ await reconcileSeedLinks(email, narrativeId, dimensionId, anchors); }
        } else if(data.raw){ const pre=el('pre'); pre.textContent=data.raw; seedWrap.appendChild(pre); seedStatus.textContent='Model returned raw text; parsing failed upstream.'; } else { const pre=el('pre'); pre.textContent=JSON.stringify(data,null,2); seedWrap.appendChild(pre); seedStatus.textContent='Unexpected response shape.'; }
      } catch(e){ if(tries>0){ seedStatus.textContent='Retrying…'; await sleep(1200); return createSeedsForDimension(payload, ui, extras, tries-1); } seedStatus.className='seed-error'; seedStatus.textContent=`Seed request failed: ${e.message||e}`; }
    }

      const dims = Array.isArray(dimData?.dimensions)? dimData.dimensions : []; status.textContent = `Dimensions: ${dims.length}`; if(!dims.length) return; const narrativeId = getNarrativeIdForTitle(dimData.domain || domainName);
      const cards = dims.map((dim, idx)=>{ const c = renderDimensionCard(idx, dim, dimData.domain||domainName, provider, email); c._narrativeId = narrativeId || null; grid.appendChild(c); return c; });
      let i=0, ok=0, fail=0; async function seedWorker(){ while(i<cards.length){ const idx=i++; const card=cards[idx]; try{ await createSeedsForDimension(card._seedPayload, card._seedUI, { email, narrativeId: card._narrativeId, dimensionId: card._dimId }); ok++; status.textContent=`Seeds: ${ok}/${cards.length}${fail?` (${fail} failed)`:''}`; } catch{ fail++; status.textContent=`Seeds: ${ok}/${cards.length} (${fail} failed)`; } } }
      await Promise.all(Array.from({ length: Math.min(MAX_SEED_CONCURRENCY, cards.length) }, ()=> seedWorker())); status.textContent = `Done — dims ${cards.length}, seeds ${ok}/${cards.length}${fail?`, ${fail} failed`:''}`; }

    async function architectDomains(core, provider){ const url = `/api/narrative/domain_architect`; return postJSON(url, { core_story: core, provider }); }

    // --- Orchestrator ---
    form.addEventListener('submit',async e=>{ e.preventDefault(); container.innerHTML=''; globalStatus.textContent=''; const email=currentEmail(); if(email) saveEmailToStorage(email); else globalStatus.textContent='No email entered — results will be generated but NOT saved.'; const cores=(storiesInput.value||'').split('\n').map(s=>s.trim()).filter(Boolean); if(!cores.length){ globalStatus.textContent='Please enter at least one core story.'; return; } try{ await ensureNarrativesCache(email);}catch{} for(let i=0;i<cores.length;i++){ const core=cores[i]; globalStatus.textContent=`Architecting ${i+1} of ${cores.length}: ${core}`; const section=el('section'); section.append(el('h2',{text:core})); container.append(section); let arch; try{ arch=await architectDomains(core);}catch(err){ section.append(el('div',{className:'error',text:`Domain architecture failed: ${err.message||err}`})); continue; } const groups=arch?.domain_map?.groups||[]; if(!groups.length){ section.append(el('div',{className:'muted',text:'No groups returned.'})); continue; } for(const g of groups){ const gtitle=el('h3',{text:g.title||'Domains'}); section.append(gtitle); const cols=el('div',{className:'columns'}); section.append(cols); (Array.isArray(g.domains)?g.domains:[]).forEach(dom=>{ const card=el('div',{className:'domain-card'}); card.append(el('div',{className:'domain-head',text:dom.name||'Unnamed Domain'})); card.append(el('div',{className:'muted',text:dom.description||''})); cols.append(card); runProviderForDomain(dom.name,email,card); }); } } globalStatus.textContent=`Done. Processed ${cores.length} core stor${cores.length>1?'ies':'y'}.`; });

    // Init
    prefillEmailFromStorage();
  </script>
</body>
</html>
