<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Think · Core Thought Pipeline</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <style>
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      margin: 0;
      padding: 0;
      background: #f5f5f5;
      color: #111827;
    }
    .container {
      max-width: 1200px;
      margin: 0 auto;
      padding: 24px 16px 40px;
    }
    h1 {
      margin-bottom: 4px;
    }
    .subtitle {
      font-size: 0.95rem;
      color: #4b5563;
      margin-bottom: 20px;
    }
    textarea {
      width: 100%;
      min-height: 100px;
      padding: 10px;
      border-radius: 8px;
      border: 1px solid #d1d5db;
      font-family: inherit;
      font-size: 0.95rem;
      resize: vertical;
      box-sizing: border-box;
    }
    button {
      border: none;
      padding: 8px 16px;
      border-radius: 999px;
      cursor: pointer;
      font-size: 0.9rem;
      margin: 4px 6px 4px 0;
      background: #111827;
      color: #f9fafb;
    }
    button.secondary {
      background: #e5e7eb;
      color: #111827;
    }
    button:disabled {
      opacity: 0.5;
      cursor: default;
    }
    label {
      font-size: 0.85rem;
      font-weight: 500;
      display: block;
      margin-bottom: 4px;
      color: #374151;
    }
    .status {
      margin-top: 8px;
      font-size: 0.85rem;
      color: #374151;
    }
    .status.error {
      color: #b91c1c;
    }
    .row {
      display: flex;
      flex-wrap: wrap;
      gap: 16px;
      margin-top: 24px;
    }
    .card {
      background: #ffffff;
      border-radius: 12px;
      padding: 12px 14px;
      box-shadow: 0 1px 3px rgba(0,0,0,0.08);
      flex: 1 1 280px;
      min-width: 280px;
      max-height: 360px;
      display: flex;
      flex-direction: column;
    }
    .card h2 {
      font-size: 0.95rem;
      margin: 0 0 6px;
      display: flex;
      align-items: center;
      justify-content: space-between;
    }
    .badge {
      display: inline-block;
      font-size: 0.65rem;
      text-transform: uppercase;
      letter-spacing: 0.06em;
      padding: 1px 7px;
      border-radius: 999px;
      background: #e5e7eb;
      color: #4b5563;
      margin-left: 8px;
    }
    .card pre {
      white-space: pre-wrap;
      word-wrap: break-word;
      font-size: 0.8rem;
      line-height: 1.35;
      margin: 4px 0 0;
      overflow: auto;
      flex: 1;
    }
    .card-controls {
      margin-bottom: 4px;
    }
    .card-controls button {
      margin-right: 4px;
      margin-bottom: 4px;
    }
    .small-input {
      font-size: 0.8rem;
      padding: 4px 6px;
      border-radius: 6px;
      border: 1px solid #d1d5db;
      width: 100%;
      box-sizing: border-box;
      margin-top: 4px;
    }
    .top-controls {
      margin-top: 8px;
      margin-bottom: 12px;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>Core Thought Pipeline</h1>
    <div class="subtitle">
      Start with a seed thought. You can step through each stage (adjacent → core thoughts → expansion → core ideas → world → bridges), or run the full pipeline in one shot.
    </div>

    <label for="thought-input">Seed thought</label>
    <textarea id="thought-input" placeholder="Example: a symphony of a thousand pianos"></textarea>

    <div class="top-controls">
      <button id="adjacent-btn" class="secondary">1 · Adjacent thoughts</button>
      <button id="core-thoughts-btn" class="secondary">2 · Core thoughts</button>
      <button id="expand-btn" class="secondary">3 · Expand core thought</button>
      <button id="core-ideas-btn" class="secondary">4 · Core ideas from expansion</button>
      <button id="world-context-btn" class="secondary">5 · World context</button>
      <button id="bridges-btn" class="secondary">6 · Bridges</button>
      <button id="pipeline-btn">Run full pipeline</button>
    </div>

    <div id="status" class="status"></div>

    <div class="row">
      <div class="card">
        <h2>
          Adjacent thoughts
          <span class="badge">neighborhood</span>
        </h2>
        <div class="card-controls">
          <small>POST /think/adjacent</small>
        </div>
        <pre id="adjacent-output"></pre>
      </div>

      <div class="card">
        <h2>
          Core thoughts architecture
          <span class="badge">structure</span>
        </h2>
        <div class="card-controls">
          <small>POST /think/core_thoughts</small>
        </div>
        <pre id="core-thoughts-output"></pre>
      </div>

      <div class="card">
        <h2>
          Expanded core thought
          <span class="badge">deep dive</span>
        </h2>
        <div class="card-controls">
          <small>POST /think/expand_core_thought</small>
          <div>
            <label for="core-thought-manual" style="margin-top:4px;">
              Core thought to expand (optional)
            </label>
            <input id="core-thought-manual" class="small-input"
                   placeholder="If empty, uses first core thought above">
          </div>
        </div>
        <pre id="expansion-output"></pre>
      </div>
    </div>

    <div class="row">
      <div class="card">
        <h2>
          Core ideas
          <span class="badge">distilled seeds</span>
        </h2>
        <div class="card-controls">
          <small>POST /think/core_ideas</small>
        </div>
        <pre id="core-ideas-output"></pre>
      </div>

      <div class="card">
        <h2>
          World context
          <span class="badge">imagined world</span>
        </h2>
        <div class="card-controls">
          <small>POST /think/world_context</small>
        </div>
        <pre id="world-context-output"></pre>
      </div>

      <div class="card">
        <h2>
          Bridges
          <span class="badge">into your world</span>
        </h2>
        <div class="card-controls">
          <small>POST /think/bridges</small>
        </div>
        <pre id="bridges-output"></pre>
      </div>
    </div>
  </div>

  <script>
    const statusEl = document.getElementById("status");

    const adjacentOutput = document.getElementById("adjacent-output");
    const coreThoughtsOutput = document.getElementById("core-thoughts-output");
    const expansionOutput = document.getElementById("expansion-output");
    const coreIdeasOutput = document.getElementById("core-ideas-output");
    const worldContextOutput = document.getElementById("world-context-output");
    const bridgesOutput = document.getElementById("bridges-output");

    const adjacentBtn = document.getElementById("adjacent-btn");
    const coreThoughtsBtn = document.getElementById("core-thoughts-btn");
    const expandBtn = document.getElementById("expand-btn");
    const coreIdeasBtn = document.getElementById("core-ideas-btn");
    const worldContextBtn = document.getElementById("world-context-btn");
    const bridgesBtn = document.getElementById("bridges-btn");
    const pipelineBtn = document.getElementById("pipeline-btn");

    const coreThoughtManualInput = document.getElementById("core-thought-manual");

    // State for iterative testing
    let lastThought = "";
    let lastAdjacent = null;
    let lastCoreThoughts = null;
    let lastCoreThoughtExpanded = null;
    let lastExpansion = "";
    let lastCoreIdeas = null;
    let lastWorldContext = "";

    function setStatus(msg, isError = false) {
      statusEl.textContent = msg;
      if (isError) {
        statusEl.classList.add("error");
      } else {
        statusEl.classList.remove("error");
      }
    }

    function disableAllButtons(disabled) {
      [
        adjacentBtn,
        coreThoughtsBtn,
        expandBtn,
        coreIdeasBtn,
        worldContextBtn,
        bridgesBtn,
        pipelineBtn
      ].forEach(btn => btn.disabled = disabled);
    }

    async function callEndpoint(path, payload) {
      const res = await fetch(path, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(payload)
      });
      if (!res.ok) {
        let err = {};
        try {
          err = await res.json();
        } catch (_) {}
        throw new Error(err.error || res.statusText);
      }
      return res.json();
    }

    async function runAdjacent() {
      const thought = document.getElementById("thought-input").value.trim();
      if (!thought) {
        setStatus("Enter a seed thought first.", true);
        return;
      }
      lastThought = thought;
      setStatus("Generating adjacent thoughts...");
      disableAllButtons(true);
      try {
        const data = await callEndpoint("/think/adjacent", { thought });
        lastAdjacent = data;
        if (data.adjacent_thoughts) {
          const lines = data.adjacent_thoughts.map(t => `${t.id}. ${t.text}`);
          adjacentOutput.textContent = lines.join("\n");
        } else {
          adjacentOutput.textContent = JSON.stringify(data, null, 2);
        }
        setStatus("Adjacent thoughts generated.");
      } catch (e) {
        setStatus(e.message, true);
      } finally {
        disableAllButtons(false);
      }
    }

    async function runCoreThoughts() {
        const thought = (lastThought || document.getElementById("thought-input").value.trim());
        if (!thought) {
            setStatus("Enter a seed thought first.", true);
            return;
        }
        lastThought = thought;
        setStatus("Generating core thoughts (THINK text block)…");
        disableAllButtons(true);
        try {
            const data = await callEndpoint("/think/core_thoughts", { thought });
            const block = (data.core_thoughts_text || "").trim();
            lastCoreThoughts = { core_thoughts_text: block };

            coreThoughtsOutput.textContent = block || "(empty core thoughts text)";
            setStatus("Core thoughts generated as a single text block.");
        } catch (e) {
            setStatus(e.message, true);
        } finally {
            disableAllButtons(false);
        }
        }


    async function runExpansion() {
      setStatus("Expanding core thought...");
      disableAllButtons(true);
      try {
        let coreThought = coreThoughtManualInput.value.trim();
        if (!coreThought) {
          if (!lastCoreThoughts || !lastCoreThoughts.core_thoughts || lastCoreThoughts.core_thoughts.length === 0) {
            setStatus("No core thoughts available. Generate core thoughts or provide a core thought manually.", true);
            return;
          }
          coreThought = lastCoreThoughts.core_thoughts[0].text;
        }

        const data = await callEndpoint("/think/expand_core_thought", { core_thought: coreThought });
        lastCoreThoughtExpanded = data;
        lastExpansion = data.expansion || "";
        expansionOutput.textContent = "Core thought:\n" + data.core_thought + "\n\nExpansion:\n" + data.expansion;
        setStatus("Core thought expanded.");
      } catch (e) {
        setStatus(e.message, true);
      } finally {
        disableAllButtons(false);
      }
    }

    async function runCoreIdeas() {
        // Use the core thoughts text block as input
        const block =
            (lastCoreThoughts && lastCoreThoughts.core_thoughts_text) ||
            coreThoughtsOutput.textContent.trim();

        if (!block) {
            setStatus("No core thoughts available. Generate core thoughts first.", true);
            return;
        }

        setStatus("Distilling core ideas from core thoughts block…");
        disableAllButtons(true);
        try {
            const data = await callEndpoint("/think/core_ideas", { thought: block });
            const text = (data.core_ideas_text || "").trim();

            lastCoreIdeas = { core_ideas_text: text };
            coreIdeasOutput.textContent = text || "(empty core ideas text)";

            setStatus("Core ideas distilled as a text block.");
        } catch (e) {
            setStatus(e.message, true);
        } finally {
            disableAllButtons(false);
        }
    }


    async function runWorldContext() {
        const block =
            (lastCoreIdeas && lastCoreIdeas.core_ideas_text) ||
            coreIdeasOutput.textContent.trim();

        if (!block) {
            setStatus("No core ideas available. Distill core ideas first.", true);
            return;
        }

        setStatus("Generating world context from core ideas text block…");
        disableAllButtons(true);
        try {
            const data = await callEndpoint("/think/world_context", {
            core_ideas_text: block
            });
            const wc = (data.world_context || "").trim();

            lastWorldContext = wc;
            worldContextOutput.textContent = wc || "(empty world context)";

            setStatus("World context generated from core ideas block.");
        } catch (e) {
            setStatus(e.message, true);
        } finally {
            disableAllButtons(false);
        }
    }


    async function runBridges() {
      const ctx = lastWorldContext || worldContextOutput.textContent;
      if (!ctx) {
        setStatus("No world context available. Generate world context first.", true);
        return;
      }
      setStatus("Generating bridges...");
      disableAllButtons(true);
      try {
        const data = await callEndpoint("/think/bridges", { world_context: ctx });
        bridgesOutput.textContent = data.bridges || JSON.stringify(data, null, 2);
        setStatus("Bridges generated.");
      } catch (e) {
        setStatus(e.message, true);
      } finally {
        disableAllButtons(false);
      }
    }

    async function runPipeline() {
        const thought = document.getElementById("thought-input").value.trim();
        if (!thought) {
            setStatus("Enter a seed thought first.", true);
            return;
        }
        lastThought = thought;
        setStatus("Running full pipeline (no expansion step)…");
        disableAllButtons(true);
        try {
            const data = await callEndpoint("/think/pipeline", { thought });

            // Save state for manual follow-ups
            lastAdjacent = data.adjacent || null;
            lastCoreThoughts = { core_thoughts_text: data.core_thoughts_text || "" };
            lastCoreIdeas = { core_ideas_text: data.core_ideas_text || "" };
            lastWorldContext = data.world_context || "";

            // Adjacent
            if (data.adjacent && data.adjacent.adjacent_thoughts) {
            const lines = data.adjacent.adjacent_thoughts.map(t => `${t.id}. ${t.text}`);
            adjacentOutput.textContent = lines.join("\n");
            } else if (data.adjacent) {
            adjacentOutput.textContent = JSON.stringify(data.adjacent, null, 2);
            } else {
            adjacentOutput.textContent = "(no adjacent thoughts)";
            }

            // Core thoughts
            coreThoughtsOutput.textContent =
            data.core_thoughts_text || "(no core thoughts text)";

            // Expansion section is now explicitly skipped
            expansionOutput.textContent =
            "(expansion step skipped in pipeline; use the Expand control manually if you still want to experiment with expansions.)";

            // Core ideas
            coreIdeasOutput.textContent =
            data.core_ideas_text || "(no core ideas text)";

            // World context
            worldContextOutput.textContent =
            data.world_context || "(no world context)";

            // Bridges
            bridgesOutput.textContent =
            data.bridges || "(no bridges)";

            setStatus("Full pipeline complete (thought → adjacent → core thoughts → core ideas → world context → bridges). Stored with id " + data.id + ".");
        } catch (e) {
            setStatus(e.message, true);
        } finally {
            disableAllButtons(false);
        }
    }


    adjacentBtn.addEventListener("click", runAdjacent);
    coreThoughtsBtn.addEventListener("click", runCoreThoughts);
    expandBtn.addEventListener("click", runExpansion);
    coreIdeasBtn.addEventListener("click", runCoreIdeas);
    worldContextBtn.addEventListener("click", runWorldContext);
    bridgesBtn.addEventListener("click", runBridges);
    pipelineBtn.addEventListener("click", runPipeline);
  </script>
</body>
</html>
