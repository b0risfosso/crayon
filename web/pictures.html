<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Fantasiagenesis · Pictures</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root { color-scheme: light; }
    * { box-sizing: border-box; }
    body { font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial; margin: 20px; }
    header h1 { margin: 0 0 .3rem 0; font-size: clamp(1.2rem, 2.4vw, 1.6rem); }
    .muted { opacity: .85; }
    .row { display:flex; gap:.5rem; align-items:center; flex-wrap:wrap; }
    .panel { border:1px solid #e5e7eb; border-radius:.6rem; padding:.85rem 1rem; background:#fafafb; }
    .panel + .panel { margin-top:.9rem; }
    input[type="email"] { height:2.4rem; padding:.55rem .7rem; border:1px solid #cdd0d5; border-radius:.55rem; width:min(92vw, 440px); }
    button { padding:.6rem .9rem; border:0; border-radius:.55rem; background:#0b5cff; color:#fff; cursor:pointer; }
    button.secondary { background:#4b5563; }
    .status { font-size:.92rem; min-height:1.2em; margin-top:.35rem; }
    .status.error { color:#b00020; white-space:pre-wrap; }
    .status.ok { color:#065f46; }
    .vlist { display:grid; gap:.85rem; }
    .vision { border:1px solid #e5e7eb; border-radius:.6rem; background:#fff; padding:.75rem .85rem; }
    .vision h2 { margin:.1rem 0 .2rem 0; font-size:1.05rem; }
    .meta { font-size:.85rem; opacity:.9; }
    .chips { display:flex; gap:.4rem; flex-wrap:wrap; margin:.45rem 0 .3rem 0; }
    .chip { border:1px solid #d1d5db; border-radius:.45rem; padding:.15rem .45rem; background:#f9fafb; font-size:.85rem; }
    .pics { display:grid; gap:.55rem; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); margin-top:.5rem; }
    .pic { border:1px solid #e5e7eb; border-radius:.6rem; background:#fdfdfd; padding:.6rem .7rem; }
    .pic h3 { margin:.05rem 0 .25rem 0; font-size:1rem; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }
    .sep { height:1px; background:#eee; margin:.6rem 0; }
    .empty { padding:.4rem 0; color:#6b7280; }
    button.view { background: #059669; }       /* green */
    button.create { background: #0b5cff; }     /* blue */
    button.recreate { background: #f59e0b; }   /* amber */
  </style>
</head>
<body>
  <header class="row" style="justify-content: space-between;">
    <div>
      <h1>Pictures</h1>
      <div class="muted">Shows your pictures</div>
    </div>
    <nav class="row">
      <a href="/draw" class="muted">✏️ Draw</a>
    </nav>
  </header>

  <section class="panel">
    <div class="row">
      <input type="email" id="email" placeholder="you@example.com" />
      <button id="loadBtn" type="button">Load</button>
      <button id="saveBtn" class="secondary" type="button">Save email</button>
    </div>
    <div id="status" class="status"></div>
  </section>

  <section id="results" class="panel" style="display:none;">
    <div id="summary" class="muted" style="margin-bottom:.5rem;"></div>
    <div id="visions" class="vlist"></div>
  </section>

  <script>
    // ------------------------------------------
    // Constants / endpoints
    // ------------------------------------------
    const LS_EMAIL = 'fg_user_email';
    const LS_COLLECTION = 'architects_all';

    // Use READ endpoints & the new combined queue endpoint
    const EP = {
      byEmail: '/read/by_email',
      listArchitectures: '/read/architectures',
      initCanvas: '/canvas/initialize_canvas',
      initStatus: '/canvas/initialize_canvas/status',
      initResult: '/canvas/initialize_canvas/result'
    };

    // ------------------------------------------
    // Fetch helpers
    // ------------------------------------------
    async function fetchWithTimeout(url, options={}, timeoutMs=600000){
      const controller = new AbortController();
      const timer = setTimeout(()=> controller.abort(), timeoutMs);
      try {
        return await fetch(url, { ...options, signal: controller.signal });
      } finally {
        clearTimeout(timer);
      }
    }
    async function postJSON(url, body, timeoutMs=600000){
      const resp = await fetchWithTimeout(url, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(body)
      }, timeoutMs);
      let data;
      try { data = await resp.json(); }
      catch { throw new Error(`Non-JSON response from ${url} (status ${resp.status})`); }
      if (!resp.ok || data?.ok === false) {
        const msg = (data && (data.error || data.detail)) ?
          `${data.error || ''} ${data.detail || ''}`.trim() :
          `HTTP ${resp.status}`;
        throw new Error(msg);
      }
      return data;
    }
    async function fetchJSON(url, options={}, timeoutMs=600000){
      const ctrl = new AbortController(); const t = setTimeout(()=>ctrl.abort(), timeoutMs);
      try {
        const r = await fetch(url, { ...options, signal: ctrl.signal });
        const ct = r.headers.get('content-type')||'';
        const data = ct.includes('application/json') ? await r.json() : await r.text();
        if (!r.ok) throw new Error((data && (data.error||data.detail)) || `HTTP ${r.status}`);
        return data;
      } finally { clearTimeout(t); }
    }

    // ------------------------------------------
    // Small utils
    // ------------------------------------------
    const $ = (id) => document.getElementById(id);
    function setStatus(msg, level='') {
      const el = $('status');
      el.className = 'status ' + (level || '');
      el.textContent = msg || '';
    }
    function escapeHtml(s) {
      return String(s ?? '').replaceAll('&','&amp;').replaceAll('<','&lt;')
                            .replaceAll('>','&gt;').replaceAll('"','&quot;')
                            .replaceAll("'",'&#39;');
    }
    function loadEmail(){ const v = (localStorage.getItem(LS_EMAIL)||'').trim().toLowerCase(); if (v) $('email').value = v; }
    function saveEmail(){ const v = ($('email').value||'').trim().toLowerCase(); if (v) localStorage.setItem(LS_EMAIL, v); }

    // ------------------------------------------
    // READ service helpers
    // ------------------------------------------
    async function getArchitecturesForPicture(pictureId, {collection=null, includeBody=false} = {}){
      const params = new URLSearchParams();
      if (pictureId) params.set('picture_id', pictureId);
      if (collection) params.set('collection', collection);
      if (includeBody) params.set('include_body', '1');
      const url = `${EP.listArchitectures}?${params.toString()}`;
      const res = await fetch(url);
      if (!res.ok) return {items:[], count:0};
      return await res.json();
    }

    // New helper: batched counts
    async function getArchitectureCountsForPictures(pictureIds, { collection=null } = {}) {
      if (!pictureIds.length) return {};
      const params = new URLSearchParams();
      params.set('picture_ids', pictureIds.join(','));
      if (collection) params.set('collection', collection);
      const url = `/read/architectures/counts?${params.toString()}`;
      const data = await fetchJSON(url, {}, 120000);
      return data?.counts || {};
    }

    // Open ONE new tab that displays multiple architectures for a single picture
    function openArchitecturesInNewTab({ pictureTitle, items }){
      const viewerUrl = '/architecture_viewer.html'; // adjust path if needed
      const w = window.open(viewerUrl, '_blank');
      if (!w) { alert('Popup blocked: allow popups to view architectures.'); return; }
      const payload = { kind: 'architectures-batch', pictureTitle, items };
      const send = () => { try { w.postMessage(payload, window.location.origin); } catch(_) {} };
      setTimeout(send, 80);
      setTimeout(send, 300);
      setTimeout(send, 800);
    }

    async function viewExistingArchitectures(pic, {collection=null} = {}){
      const {items} = await getArchitecturesForPicture(pic?.id, {collection, includeBody:true});
      if (!items?.length) { alert('No saved architectures for this picture.'); return; }

      const viewerItems = items.map(it => ({
        key: it.prompt_key || 'architecture',
        title: `${(it.collection||'').toUpperCase()} · ${(it.prompt_key||'').toUpperCase()}`,
        subtitle: (pic?.title || `Picture #${pic?.id||''}`),
        body: String(it.output_text||'').trim(),
        meta: {
          collection: it.collection || '',
          created_at: it.created_at || '',
          model: it.model || ''
        }
      }));
      openArchitecturesInNewTab({ pictureTitle: pic?.title || `Picture #${pic?.id||''}`, items: viewerItems });
    }

    // ------------------------------------------
    // Queue polling helpers (initialize_canvas)
    // ------------------------------------------
    async function pollInitializeStatus(taskId, {timeoutMs=900000, intervalMs=1500} = {}){
      const start = Date.now();
      let delay = intervalMs;
      while (true) {
        const url = `${EP.initStatus}?task_id=${encodeURIComponent(taskId)}`;
        const data = await fetchJSON(url, {}, 60000);
        const t = Array.isArray(data?.tasks) ? data.tasks.find(x => x.task_id === taskId) : null;
        const st = t?.status || 'unknown';
        if (st === 'done' || st === 'error' || st === 'unknown') return t || { status: st };
        await new Promise(r => setTimeout(r, delay));
        delay = Math.min(delay * 1.4, 6000);
        if (Date.now() - start > timeoutMs) throw new Error('Timeout waiting for initialize_canvas');
      }
    }

    async function fetchInitializeResult(taskId){
      const url = `${EP.initResult}?task_id=${encodeURIComponent(taskId)}`;
      const resp = await fetch(url);
      const body = await resp.json().catch(()=> ({}));
      return { ok: resp.ok, status: resp.status, body };
    }

    // ------------------------------------------
    // Run architects for a picture via /canvas/initialize_canvas (queued)
    // ------------------------------------------
    function buildInitializePayload(visionText, pic){
      const vision = String(visionText || '').trim();
      if (!vision) throw new Error('This item has no vision text.');

      let picture_title = String(pic?.title || '').trim();
      if (!picture_title) {
        const fromDesc = String(pic?.description || '').trim();
        if (fromDesc) picture_title = (fromDesc.length > 80 ? fromDesc.slice(0, 77) + '…' : fromDesc);
        else if (pic?.id != null) picture_title = `Picture ${pic.id}`;
        else picture_title = 'Untitled picture';
      }
      let picture_description = String(pic?.description || '').trim();
      if (!picture_description) {
        const fromFn = String(pic?.function || '').trim();
        if (fromFn) picture_description = fromFn;
        else picture_description = picture_title;
      }

      return {
        vision,
        picture_title,
        picture_description,
        picture_function: String(pic?.function || '').trim(),
        focus: String(pic?.focus || '').trim()
      };
    }

    async function runArchitectsForPictureCard(cardNode, visionText, pic){
      const email = (document.getElementById('email')?.value || localStorage.getItem(LS_EMAIL) || '').trim().toLowerCase();
      const constraints = '';
      const deployment_context = '';
      const readiness_target = '';
      const collection = (localStorage.getItem(LS_COLLECTION) || '').trim() || 'architects_all';

      // status area on card
      let status = cardNode.querySelector('.status');
      if (!status){
        status = document.createElement('div');
        status.className = 'status';
        cardNode.append(status);
      }
      status.className = 'status';
      status.textContent = `Submitting job…`;

      try {
        // 1) Build payload & submit to queue
        const base = buildInitializePayload(visionText, pic);
        const payload = {
          ...base,
          collection,
          constraints,
          deployment_context,
          readiness_target,
          integrations: '',
          email,
          picture_id: pic?.id || undefined,
          store: true
        };

        const submit = await postJSON(EP.initCanvas, payload, 600000);
        const taskId = Array.isArray(submit?.task_ids) ? submit.task_ids[0] : null;
        if (!taskId) throw new Error('No task_id returned');

        // 2) Poll status
        status.textContent = `Queued…`;
        const st = await pollInitializeStatus(taskId, { timeoutMs: 30 * 60 * 1000 });
        if (st?.status === 'error') {
          const r = await fetchInitializeResult(taskId);
          throw new Error(String(r?.body?.error || 'Worker error'));
        }
        if (st?.status === 'unknown') throw new Error('Unknown task status');

        // Optional: check result body for warnings
        const r = await fetchInitializeResult(taskId);
        if (!r.ok) {
          throw new Error(String(r?.body?.error || `Initialize failed (HTTP ${r.status})`));
        }

        // 3) Success → flip button to "view architectures"
        status.className = 'status ok';
        status.textContent = `Architectures generated.`;

        const primaryBtn = cardNode.querySelector('button.create, button.view, button.recreate') || cardNode.querySelector('button');
        if (primaryBtn){
          const replacement = primaryBtn.cloneNode(true);
          replacement.textContent = 'view architectures';
          replacement.className = 'view';
          replacement.onclick = async () => {
            const preferredCollection = (localStorage.getItem('architects_all') || '').trim() || null;
            await viewExistingArchitectures(pic, { collection: preferredCollection });
          };
          primaryBtn.replaceWith(replacement);
        }

      } catch (e) {
        status.className = 'status error';
        status.textContent = `Failed: ${e.message || e}`;
      }
    }

    // ------------------------------------------
    // Render
    // ------------------------------------------
    async function render(data){
  const visions = Array.isArray(data?.visions) ? data.visions : [];
  $('results').style.display = 'block';
  $('summary').textContent = `${visions.length} vision${visions.length===1?'':'s'} for ${data?.email || ''}`;

  const mount = $('visions');
  mount.innerHTML = '';

  if (!visions.length){
    const empty = document.createElement('div');
    empty.className = 'empty';
    empty.textContent = 'No data for this email yet.';
    mount.append(empty);
    return;
  }

  const preferredCollection = (localStorage.getItem('architects_all') || '').trim() || null;

  for (const v of visions){
    const box = document.createElement('div');
    box.className = 'vision';

    const title = document.createElement('h2');
    title.textContent = v.text || '(Untitled vision)';
    box.append(title);

    const meta = document.createElement('div'); meta.className = 'meta mono';
    meta.textContent = `id:${v.id} · status:${v.status || '—'} · updated:${v.updated_at || v.created_at || '—'}`;
    box.append(meta);

    // focuses chips (if any)
    const f = Array.isArray(v.focuses) ? v.focuses : [];
    if (f.length){
      const chips = document.createElement('div'); chips.className = 'chips';
      for (const it of f){
        const dim = (it && (it.dimension || it.title || it.name)) || 'Focus';
        const chip = document.createElement('div'); chip.className = 'chip';
        chip.innerHTML = `<strong>${escapeHtml(dim)}</strong>`;
        chips.append(chip);
      }
      box.append(chips);
    }

    const sep = document.createElement('div');
    sep.className = 'sep';
    box.append(sep);

    // pictures grid
    const pics = Array.isArray(v.pictures) ? v.pictures : [];
    if (!pics.length){
      const empty = document.createElement('div'); empty.className = 'empty';
      empty.textContent = 'No pictures for this vision yet.';
      box.append(empty);
      mount.append(box);
      continue;
    }

    const grid = document.createElement('div'); grid.className = 'pics';

    // Batch counts ONCE per vision
    const pictureIds = pics.map(p => p?.id).filter(id => id != null);
    const countsMap = pictureIds.length
      ? await getArchitectureCountsForPictures(pictureIds, { collection: preferredCollection })
      : {};

    for (const p of pics){
      const card = document.createElement('div'); card.className = 'pic';

      const h3 = document.createElement('h3'); h3.textContent = p?.title || 'Untitled picture';
      const d  = document.createElement('div'); d.className = 'muted'; d.textContent = p?.description || '';
      const fn = document.createElement('div'); fn.style.marginTop = '.35rem';
      if (p?.function) fn.innerHTML = `<strong>Function:</strong> ${escapeHtml(p.function)}`;
      const pm = document.createElement('div'); pm.className = 'meta mono';
      pm.textContent = `id:${p?.id ?? '—'} · status:${p?.status || '—'} · updated:${p?.updated_at || p?.created_at || '—'}`;

      const btn = document.createElement('button');
      btn.type = 'button';
      btn.style.marginTop = '.5rem';

      // ✅ Now per-picture, using the batched map:
      const existingCount = Number(countsMap?.[String(p?.id)]?.total || 0);

      if (existingCount > 0){
        // GREEN: view existing architectures
        btn.textContent = 'view architectures';
        btn.className = 'view';
        btn.addEventListener('click', async () => {
          await viewExistingArchitectures(p, { collection: preferredCollection || null });
        });

        // Optional: secondary "rerun architects" (re-enqueue)
        const rerun = document.createElement('button');
        rerun.type = 'button';
        rerun.textContent = 'rerun architects';
        rerun.className = 'recreate';
        rerun.style.marginTop = '.5rem';
        rerun.style.marginLeft = '.4rem';
        rerun.addEventListener('click', async () => {
          const visionText = v?.text || '';
          if (!visionText) { alert('This vision has no text.'); return; }
          await runArchitectsForPictureCard(card, visionText, p);
        });

        card.append(h3, d);
        if (p?.function) card.append(fn);
        card.append(pm, btn, rerun);
      } else {
        // BLUE: run architects (enqueue → poll → flip to view)
        btn.textContent = 'run architects';
        btn.className = 'create';
        btn.addEventListener('click', async () => {
          const visionText = v?.text || '';
          if (!visionText) { alert('This vision has no text.'); return; }
          await runArchitectsForPictureCard(card, visionText, p);

          // After run, flip to "view architectures" if stored
          try {
            const { count } = await getArchitecturesForPicture(p.id, { collection: preferredCollection || null });
            if ((Number(count) || 0) > 0){
              const replacement = btn.cloneNode(true);
              replacement.textContent = 'view architectures';
              replacement.className = 'view';
              replacement.onclick = async () => {
                await viewExistingArchitectures(p, { collection: preferredCollection || null });
              };
              btn.replaceWith(replacement);
            }
          } catch {}
        });

        card.append(h3, d);
        if (p?.function) card.append(fn);
        card.append(pm, btn);
      }

      grid.append(card);
    }

    box.append(grid);
    mount.append(box);
  }
}


    // ------------------------------------------
    // Load flow
    // ------------------------------------------
    async function load(){
      const email = ($('email').value || '').trim().toLowerCase();
      if (!email){ setStatus('Enter an email.', 'error'); return; }
      setStatus('Loading…');
      try{
        const data = await fetchJSON(`${EP.byEmail}?email=${encodeURIComponent(email)}`, {}, 120000);
        await render(data);
        setStatus('Done.', 'ok');
      }catch(e){
        setStatus(`Failed: ${e.message || e}`, 'error');
      }
    }

    // ------------------------------------------
    // Init
    // ------------------------------------------
    (function init(){
      loadEmail();
      $('loadBtn').addEventListener('click', load);
      $('saveBtn').addEventListener('click', ()=>{ saveEmail(); setStatus('Email saved.', 'ok'); });
    })();
  </script>
</body>
</html>
