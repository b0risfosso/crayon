<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Music — Imagine</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <style>
    :root { color-scheme: light dark; }
    body { font-family: system-ui, sans-serif; margin: 2rem; max-width: 1000px; }
    h1 { font-size: 1.6rem; margin-bottom: .5rem; }
    form { display: flex; gap: .5rem; flex-wrap: wrap; margin: 1rem 0; align-items: center; }
    select { padding: .55rem .6rem; min-width: 22rem; border: 1px solid #ccc; border-radius: .5rem; }
    button { padding: .6rem .9rem; border: 0; border-radius: .5rem; cursor: pointer; background: #0b5cff; color: #fff; }
    button.secondary { background: #444; }
    .meta { font-size: .9rem; opacity: .85; margin: .25rem 0 1rem; }
    .grid { display: grid; gap: .8rem; }
    details { border: 1px solid #d0d0d0; border-radius: .6rem; padding: .75rem 1rem; background: rgba(0,0,0,.02); }
    summary { cursor: pointer; font-weight: 600; }
    .thesis { margin: .4rem 0 .3rem; font-style: italic; white-space: pre-wrap; }
    .seedbox { border-top: 1px dashed #c8c8c8; margin-top: .5rem; padding-top: .5rem; }
    .seed-title { font-weight: 600; margin-bottom: .25rem; }
    .seed { margin: .35rem 0; padding: .5rem .6rem; border: 1px solid #e0e0e0; border-radius: .5rem; background: #fff; }
    .dim-error, .seed-error, .error { color: #b00020; white-space: pre-wrap; }
    .muted { opacity: .7; font-size: .9rem; }
    pre { background: #f6f6f6; padding: .75rem; border-radius: .5rem; overflow-x: auto; }
    .row { display:flex; align-items:center; gap:.5rem; flex-wrap:wrap; }
    .badge { font-size:.8rem; padding:.15rem .45rem; border:1px solid #ddd; border-radius:.4rem; }
    #statusLog { white-space: pre-wrap; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; }
  </style>
</head>
<body>
  <h1>Imagine — Music</h1>

  <!-- Domain selector -->
  <form id="form" autocomplete="off">
    <label for="narrativeSelect" class="muted">Choose a domain:</label>
    <select id="narrativeSelect">
      <option value="">Loading domains…</option>
    </select>
    <button type="submit">Load</button>
    <button id="runAllBtn" type="button" class="secondary" title="Run Grok + Gemini + DeepSeek sequentially">Run (All Providers)</button>
    <span id="statusLine" class="muted"></span>
  </form>

  <div id="globalStatus" class="meta"></div>
  <div id="container"></div>
  <div id="statusLog" class="meta"></div>

  <script>
    const form = document.getElementById('form');
    const narrativeSelect = document.getElementById('narrativeSelect');
    const runAllBtn = document.getElementById('runAllBtn');
    const globalStatus = document.getElementById('globalStatus');
    const container = document.getElementById('container');
    const statusLine = document.getElementById('statusLine');
    const statusLog = document.getElementById('statusLog');

    // ---------- utilities ----------
    function el(tag, opts = {}) {
      const node = document.createElement(tag);
      if (opts.className) node.className = opts.className;
      if ('text' in opts) node.textContent = opts.text;
      if ('html' in opts) node.innerHTML = opts.html;
      if (opts.attrs) Object.entries(opts.attrs).forEach(([k,v]) => node.setAttribute(k,v));
      return node;
    }
    function escapeHtml(s) {
      return String(s)
        .replaceAll('&', '&amp;').replaceAll('<', '&lt;')
        .replaceAll('>', '&gt;').replaceAll('"', '&quot;')
        .replaceAll("'", '&#39;');
    }
    async function fetchWithTimeout(url, options = {}, timeoutMs = 180000) {
      const controller = new AbortController();
      const id = setTimeout(() => controller.abort(), timeoutMs);
      try {
        return await fetch(url, { ...options, signal: controller.signal });
      } finally { clearTimeout(id); }
    }
    async function getJSON(url, timeoutMs = 180000) {
      const resp = await fetchWithTimeout(url, {}, timeoutMs);
      let data;
      try { data = await resp.json(); } catch {
        throw new Error(`Non-JSON response from ${url} (status ${resp.status})`);
      }
      if (!resp.ok) {
        const msg = (data && (data.error || data.detail)) ? `${data.error || ''} ${data.detail || ''}`.trim() : `HTTP ${resp.status}`;
        throw new Error(msg);
      }
      return data;
    }
    async function postJSON(url, body, timeoutMs = 180000) {
      const resp = await fetchWithTimeout(url, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(body)
      }, timeoutMs);
      let data;
      try { data = await resp.json(); } catch {
        throw new Error(`Non-JSON response from ${url} (status ${resp.status})`);
      }
      if (!resp.ok) {
        const msg = (data && (data.error || data.detail)) ? `${data.error || ''} ${data.detail || ''}`.trim() : `HTTP ${resp.status}`;
        throw new Error(msg);
      }
      return data;
    }
    const sleep = (ms) => new Promise(r => setTimeout(r, ms));
    function log(line) {
      if (!line) return;
      statusLog.textContent += (statusLog.textContent ? "\n" : "") + line;
    }

    // ---------- UI builders ----------
    function makeNarrativeSection(narrative) {
      const section = el('section');
      const h2 = el('h2', { text: narrative.title || `Narrative #${narrative.id}` });
      const meta = el('div', { className: 'meta', html: `ID: <span class="badge">${narrative.id}</span> · Created: ${escapeHtml(narrative.created_at || '—')}` });
      const err = el('div', { className: 'error' });
      const grid = el('div', { className: 'grid' });
      section.append(h2, meta, err, grid);
      container.appendChild(section);
      return { section, meta, err, grid };
    }

    function renderDimensionCard(idx, dim) {
      const card = el('details');
      const sum = el('summary', { text: `${idx + 1}. ${dim.title || dim.name || 'Untitled'}` });
      const desc = dim.description || dim.thesis || '';
      const thesis = el('div', { className: 'thesis', text: desc });

      const seedBox = el('div', { className: 'seedbox' });
      const seedHeader = el('div', { className: 'seed-title', text: 'Seeds' });
      const seedStatus = el('div', { className: 'muted', text: 'Waiting…' });
      const seedWrap = el('div');

      seedBox.append(seedHeader, seedStatus, seedWrap);
      card.append(sum, thesis, seedBox);

      if (dim.id) {
        card._seedFetch = () => fetchSeedsForDimensionGET(dim.id, { seedStatus, seedWrap });
      }
      return card;
    }

    // ---------- Seeds (GET existing) ----------
    async function fetchSeedsForDimensionGET(dimensionId, ui, tries = 2) {
      const { seedStatus, seedWrap } = ui;
      try {
        seedStatus.textContent = 'Loading seeds…';
        const data = await getJSON(`/api/dimensions/${dimensionId}/seeds`);
        seedStatus.textContent = '';

        const seeds = Array.isArray(data?.seeds) ? data.seeds : [];
        if (!seeds.length) { seedStatus.textContent = 'No seeds found.'; return; }
        seeds.forEach(s => {
          const seed = el('div', { className: 'seed' });
          seed.innerHTML =
            `<strong>A (Problem):</strong> ${escapeHtml(s.problem || '')}<br>` +
            `<strong>B (Objective):</strong> ${escapeHtml(s.objective || '')}<br>` +
            `<strong>Solution (Link):</strong> ${escapeHtml(s.solution || '')}` +
            (s.provider ? `<br><small>provider: ${escapeHtml(s.provider)}</small>` : '') +
            (s.created_at ? `<br><small>${escapeHtml(s.created_at)}</small>` : '');
          seedWrap.appendChild(seed);
        });
      } catch (e) {
        if (tries > 0) {
          seedStatus.textContent = 'Retrying…';
          await sleep(1200);
          return fetchSeedsForDimensionGET(dimensionId, ui, tries - 1);
        }
        seedStatus.className = 'seed-error';
        seedStatus.textContent = `Seed fetch failed: ${e.message || e}`;
      }
    }

    // ---------- Dimensions + seeds (GET existing view) ----------
    async function runForNarrative(narrative) {
      const ui = makeNarrativeSection(narrative);
      const { meta, err, grid } = ui;

      err.textContent = '';
      grid.textContent = 'Loading dimensions…';
      globalStatus.textContent = `Loading dimensions for “${narrative.title}”…`;

      try {
        const dims = await getJSON(`/api/narratives/${narrative.id}/dimensions`);
        grid.innerHTML = '';
        meta.innerHTML += ` · Dimensions: <span class="badge">${dims.length}</span>`;

        const cards = dims.map((dim, idx) => {
          const card = renderDimensionCard(idx, dim);
          grid.appendChild(card);
          return card;
        });

        // throttle seed fetches
        const MAX_CONCURRENCY = 2;
        let ptr = 0;
        async function worker() {
          while (ptr < cards.length) {
            const card = cards[ptr++];
            if (card._seedFetch) await card._seedFetch();
          }
        }
        await Promise.all(Array.from({ length: Math.min(MAX_CONCURRENCY, cards.length) }, () => worker()));
        globalStatus.textContent = `Done. Loaded ${dims.length} dimension(s) for “${narrative.title}”.`;
      } catch (e) {
        grid.innerHTML = '';
        err.textContent = e.message || String(e);
        globalStatus.textContent = 'Failed to load dimensions.';
      }
    }

    // ---------- Provider runners ----------
    async function runOneProvider(provider, narrativeTitle) {
      log(`▶ ${provider}: generating dimensions…`);
      statusLine.textContent = `Generating dimensions with ${provider}…`;
      const dimData = await postJSON('/api/narrative-dimensions', {
        domain: narrativeTitle,
        provider
      });
      const dims = Array.isArray(dimData?.dimensions) ? dimData.dimensions : [];
      log(`   ${provider}: ${dims.length} dimension(s) created.`);

      if (!dims.length) return { dims: 0, seedsOk: 0, seedsFail: 0 };

      // generate seeds for each dimension
      const MAX_CONCURRENCY = 2;
      let i = 0, ok = 0, fail = 0;

      async function seedWorker() {
        while (i < dims.length) {
          const idx = i++;
          const d = dims[idx];
          try {
            await postJSON('/api/narrative-seeds', {
              domain: narrativeTitle,
              dimension: d.name,
              description: d.thesis,
              targets: d.targets || [],
              provider
            });
            ok++;
            statusLine.textContent = `Generating ${provider} seeds… ${ok}/${dims.length}`;
          } catch (e) {
            fail++;
            log(`   ${provider}: seed error on "${d.name}": ${e.message || e}`);
          }
        }
      }
      await Promise.all(Array.from({ length: Math.min(MAX_CONCURRENCY, dims.length) }, () => seedWorker()));
      log(`✔ ${provider}: seeds created for ${ok}/${dims.length} dimension(s)${fail ? `, ${fail} failed` : ''}.`);
      return { dims: dims.length, seedsOk: ok, seedsFail: fail };
    }

    async function runAllProvidersSequential(narrative) {
      statusLog.textContent = '';
      const providers = ['xai', 'gemini', 'deepseek'];
      const summary = [];

      for (const p of providers) {
        try {
          const r = await runOneProvider(p, narrative.title);
          summary.push({ provider: p, ...r });
          // brief pause between providers (optional)
          await sleep(400);
        } catch (e) {
          log(`✖ ${p}: failed — ${e.message || e}`);
          summary.push({ provider: p, dims: 0, seedsOk: 0, seedsFail: 0, error: String(e) });
        }
      }

      // Reload canonical view
      statusLine.textContent = 'Reloading view from DB…';
      container.innerHTML = '';
      await runForNarrative(narrative);

      // Print summary
      const s = summary.map(x =>
        `${x.provider}: dims=${x.dims}, seeds_ok=${x.seedsOk}, seeds_fail=${x.seedsFail}${x.error ? `, error=${x.error}` : ''}`
      ).join('\n');
      log(`\n=== Summary ===\n${s}`);
      statusLine.textContent = 'Done.';
    }

    // ---------- populate narratives dropdown ----------
    async function loadNarrativesAndMaybeAutostart() {
      globalStatus.textContent = 'Loading domains…';
      try {
        const rows = await getJSON('/api/narratives');
        narrativeSelect.innerHTML = '';
        if (!rows.length) {
          narrativeSelect.appendChild(el('option', { text: 'No domains available', attrs: { value: '' } }));
          globalStatus.textContent = 'No domains found.';
          return;
        }
        rows.forEach(n => {
          const label = n.title ? `${n.title} — #${n.id}` : `#${n.id}`;
          narrativeSelect.appendChild(el('option', { text: label, attrs: { value: String(n.id) } }));
        });
        globalStatus.textContent = `Loaded ${rows.length} domain(s).`;

        // Deep-link support: ?narrative=ID
        const params = new URLSearchParams(location.search);
        const preId = params.get('narrative');
        if (preId && rows.some(r => String(r.id) === preId)) {
          narrativeSelect.value = preId;
          form.dispatchEvent(new Event('submit'));
        }
      } catch (e) {
        narrativeSelect.innerHTML = '';
        narrativeSelect.appendChild(el('option', { text: `Error: ${e.message || e}`, attrs: { value: '' } }));
        globalStatus.textContent = 'Failed to load domains.';
      }
    }

    // ---------- events ----------
    form.addEventListener('submit', async (e) => {
      e.preventDefault();
      const id = narrativeSelect.value.trim();
      if (!id) { globalStatus.textContent = 'Please choose a domain.'; return; }

      // Keep selection in URL
      const url = new URL(location.href);
      url.searchParams.set('narrative', id);
      history.replaceState(null, '', url.toString());

      const selectedText = narrativeSelect.options[narrativeSelect.selectedIndex]?.text || `#${id}`;
      const titleFromText = selectedText.replace(/\s*—\s*#\d+$/, '');
      const narrative = { id: Number(id), title: titleFromText, created_at: '' };

      container.innerHTML = '';
      statusLine.textContent = '';
      statusLog.textContent = '';
      await runForNarrative(narrative);
    });

    runAllBtn.addEventListener('click', async () => {
      const id = narrativeSelect.value.trim();
      if (!id) { globalStatus.textContent = 'Please choose a domain first.'; return; }
      const selectedText = narrativeSelect.options[narrativeSelect.selectedIndex]?.text || `#${id}`;
      const titleFromText = selectedText.replace(/\s*—\s*#\d+$/, '');
      const narrative = { id: Number(id), title: titleFromText, created_at: '' };

      try {
        runAllBtn.disabled = true;
        statusLine.textContent = 'Starting…';
        statusLog.textContent = '';
        await runAllProvidersSequential(narrative);
      } catch (e) {
        statusLine.textContent = `Run failed: ${e.message || e}`;
        log(`Run failed: ${e.message || e}`);
      } finally {
        runAllBtn.disabled = false;
      }
    });

    // Init
    loadNarrativesAndMaybeAutostart();
  </script>
</body>
</html>
