<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Music – Instrument Pathways</title>
  <style>
    :root {
      --bg: #f6f7fb;
      --card: #ffffff;
      --border: #dfe3eb;
      --muted: #6b7280;
      --accent: #1f7ae0;
    }

    body {
      margin: 0;
      font-family: system-ui, -apple-system, "Segoe UI", sans-serif;
      background: var(--bg);
      color: #111;
    }

    .page {
      max-width: 1100px;
      margin: 0 auto;
      padding: 20px;
    }

    .toolbar {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      align-items: center;
      margin-bottom: 14px;
    }

    button {
      padding: 8px 12px;
      border-radius: 8px;
      border: 1px solid var(--border);
      background: #fff;
      cursor: pointer;
      font-weight: 600;
      font-size: 13px;
    }

    button.primary {
      background: var(--accent);
      border-color: var(--accent);
      color: #fff;
    }

    button:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }

    a.back-link {
      text-decoration: none;
    }

    .muted {
      color: var(--muted);
      font-size: 13px;
    }

    h1, h2 {
      margin: 0;
    }

    .card {
      background: var(--card);
      border-radius: 12px;
      border: 1px solid var(--border);
      padding: 14px;
      box-shadow: 0 12px 40px rgba(0, 0, 0, 0.04);
      margin-bottom: 14px;
    }

    .section-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 10px;
      margin-bottom: 6px;
    }

    .meta {
      font-size: 12px;
      color: var(--muted);
      margin: 4px 0 8px;
    }

    .color-text {
      white-space: pre-wrap;
      background: #f9fafb;
      border-radius: 8px;
      border: 1px solid var(--border);
      padding: 10px;
      font-size: 14px;
    }

    .status {
      font-size: 12px;
      color: #333;
      white-space: pre-wrap;
      margin-top: 6px;
    }

    .instrument-list {
      display: flex;
      flex-direction: column;
      gap: 6px;
      max-height: 260px;
      overflow-y: auto;
      border-radius: 10px;
      border: 1px solid var(--border);
      padding: 8px;
      background: #f9fafb;
    }

    .instrument-item {
      display: flex;
      align-items: center;
      gap: 6px;
      font-size: 13px;
    }

    .instrument-name {
      font-weight: 600;
    }

    .instrument-desc {
      font-size: 12px;
      color: var(--muted);
    }

    .run-controls {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      align-items: center;
      margin-top: 8px;
    }

    .run-controls input[type="number"] {
      width: 80px;
      padding: 6px 8px;
      border-radius: 8px;
      border: 1px solid var(--border);
      font-size: 13px;
    }

    .runs-list {
      display: flex;
      flex-direction: column;
      gap: 8px;
      margin-top: 8px;
      max-height: 360px;
      overflow-y: auto;
    }

    .run-item {
      font-size: 12px;
      color: var(--muted);
    }

    .prev-card {
      border-radius: 10px;
      border: 1px solid var(--border);
      padding: 10px;
      background: #fff;
    }

    .prev-head {
      display: flex;
      justify-content: space-between;
      gap: 8px;
      align-items: baseline;
      margin-bottom: 4px;
    }

    .prev-body {
      white-space: pre-wrap;
      font-size: 13px;
      margin: 0;
    }
  </style>
</head>
<body>
  <div class="page">
    <div class="toolbar">
      <a id="backLink" class="back-link">
        <button>← Back to Painting</button>
      </a>
      <div id="header-label" class="muted"></div>
    </div>

    <!-- Color -->
    <section class="card">
      <div class="section-header">
        <h1 style="font-size:18px;">Color</h1>
        <span class="muted">This color text will be used as the goal / brush stroke.</span>
      </div>
      <div id="color-meta" class="meta"></div>
      <div id="color-text" class="color-text">(loading…)</div>
    </section>

    <!-- Instruments + run controls -->
    <section class="card">
      <div class="section-header">
        <h2 style="font-size:16px;">Instruments</h2>
        <span class="muted">Select one or more instruments, or choose N random.</span>
      </div>

      <div id="instrument-status" class="status"></div>
      <div id="instrument-choices" class="instrument-list">Loading instruments…</div>

      <div class="run-controls">
        <label style="font-size:13px;">
          Random N:
          <input id="randomCount" type="number" min="1" value="1" />
        </label>
        <button type="button" onclick="selectRandomInstruments()">Select random</button>
        <button type="button" class="primary" id="runButton" onclick="runOperationalPathways()">
          Run operational pathways
        </button>
      </div>

      <div id="run-status" class="status"></div>
      <div id="run-results" class="runs-list"></div>
    </section>

    <!-- Previous results -->
    <section class="card">
      <div class="section-header">
        <h2 style="font-size:16px;">Previous results</h2>
        <button type="button" onclick="loadPreviousRuns()">Refresh</button>
      </div>
      <div class="muted" style="margin-bottom:4px;">
        Previously generated brush strokes / instrument runs for this (art, color) pair.
      </div>
      <div id="previous-runs" class="runs-list">Loading…</div>
    </section>
  </div>

  <script>
    const params = new URLSearchParams(window.location.search);
    const artId = parseInt(params.get("art_id") || "", 10);
    const colorId = parseInt(params.get("color_id") || "", 10);

    const API_INSTRUMENTS = "/instruments";
    const API_OPERATIONAL = "/instruments/operational_pathways";
    const API_COLORS_BY_ART = (aid) => `/colors/by_art/${aid}`;
    const API_BRUSH_LIST = "/colors/brush_strokes";

    let instruments = [];
    let selectedInstrumentIds = new Set();
    let colorText = "";

    const backLink = document.getElementById("backLink");
    const headerLabel = document.getElementById("header-label");
    const colorMetaEl = document.getElementById("color-meta");
    const colorTextEl = document.getElementById("color-text");

    // Header + back link wiring
    if (artId) {
      backLink.href = `/painting.html?art_id=${artId}`;
      headerLabel.textContent = `Art #${artId}${colorId ? " · Color #" + colorId : ""}`;
    } else {
      backLink.href = "/art.html";
      headerLabel.textContent = colorId ? `Color #${colorId}` : "Missing art_id";
    }

    // Load color text using colors.py endpoints: GET /colors/by_art/<art_id>
    async function loadColor() {
      if (!artId || !colorId) {
        colorMetaEl.textContent = "Missing art_id or color_id query param.";
        colorTextEl.textContent = "";
        document.getElementById("runButton").disabled = true;
        return;
      }

      colorMetaEl.textContent = "Loading color…";
      colorTextEl.textContent = "Loading…";

      try {
        const res = await fetch(API_COLORS_BY_ART(artId));
        const data = await res.json();
        if (!res.ok) {
          throw new Error(data.message || "Failed to load colors");
        }

        const rows = Array.isArray(data) ? data : [];
        const row = rows.find(r => Number(r.id) === colorId);

        if (!row) {
          colorMetaEl.textContent = `Color #${colorId} not found for art #${artId}.`;
          colorTextEl.textContent = "";
          document.getElementById("runButton").disabled = true;
          return;
        }

        const bits = [];
        if (row.origin) bits.push(row.origin);
        if (row.model) bits.push(row.model);
        if (row.created_at) bits.push(`created: ${row.created_at}`);
        if (row.updated_at) bits.push(`updated: ${row.updated_at}`);

        colorMetaEl.textContent = bits.join(" · ") || `art_id=${row.art_id} · color_id=${row.id}`;
        colorText = row.output_text || "";
        colorTextEl.textContent = colorText || "(no color text)";
      } catch (err) {
        colorMetaEl.textContent = "Error loading color.";
        colorTextEl.textContent = err.message || String(err);
        document.getElementById("runButton").disabled = true;
      }
    }

    // Load instruments from the same API used by instruments.html
    async function loadInstruments() {
      const container = document.getElementById("instrument-choices");
      const statusEl = document.getElementById("instrument-status");
      container.textContent = "Loading instruments…";
      statusEl.textContent = "";

      try {
        const res = await fetch(API_INSTRUMENTS);
        if (!res.ok) throw new Error("Failed to load instruments");
        const data = await res.json();
        instruments = Array.isArray(data) ? data : [];
        renderInstrumentChoices();
        if (!instruments.length) {
          statusEl.textContent = "No instruments yet. Add some on instruments.html.";
        }
      } catch (err) {
        container.textContent = "";
        statusEl.textContent = err.message || "Error loading instruments.";
      }
    }

    function renderInstrumentChoices() {
      const container = document.getElementById("instrument-choices");
      container.innerHTML = "";

      if (!instruments.length) {
        container.innerHTML = '<div class="muted">No instruments available.</div>';
        return;
      }

      instruments.forEach(inst => {
        const row = document.createElement("label");
        row.className = "instrument-item";

        const checkbox = document.createElement("input");
        checkbox.type = "checkbox";
        checkbox.value = inst.id;

        checkbox.addEventListener("change", () => {
          const id = inst.id;
          if (checkbox.checked) {
            selectedInstrumentIds.add(id);
          } else {
            selectedInstrumentIds.delete(id);
          }
        });

        const name = document.createElement("span");
        name.className = "instrument-name";
        name.textContent = inst.name || "(untitled)";

        const desc = document.createElement("span");
        desc.className = "instrument-desc";
        desc.textContent = inst.description || "No description.";

        row.appendChild(checkbox);
        row.appendChild(name);
        row.appendChild(desc);
        container.appendChild(row);
      });
    }

    function selectRandomInstruments() {
      if (!instruments.length) return;

      const nInput = document.getElementById("randomCount");
      let n = parseInt(nInput.value || "1", 10);
      if (Number.isNaN(n) || n <= 0) n = 1;

      const ids = instruments.map(i => i.id);
      const shuffled = ids.slice().sort(() => Math.random() - 0.5);
      const chosen = new Set(shuffled.slice(0, Math.min(n, shuffled.length)));

      selectedInstrumentIds = chosen;

      // sync checkboxes
      const container = document.getElementById("instrument-choices");
      container.querySelectorAll('input[type="checkbox"]').forEach(cb => {
        const id = parseInt(cb.value, 10);
        cb.checked = chosen.has(id);
      });
    }

    async function runOperationalPathways() {
      if (!artId || !colorId) {
        alert("Missing art_id or color_id.");
        return;
      }

      const runBtn = document.getElementById("runButton");
      const statusEl = document.getElementById("run-status");
      const resultsEl = document.getElementById("run-results");

      const instrumentIds = Array.from(selectedInstrumentIds);
      if (!instrumentIds.length) {
        alert("Select at least one instrument.");
        return;
      }

      runBtn.disabled = true;
      statusEl.textContent = "Submitting tasks…";
      resultsEl.innerHTML = "";

      const brush_stroke = colorText || "";

      const payloads = instrumentIds.map(instrument_id => ({
        art_id: artId,
        color_id: colorId,
        instrument_id,
        brush_stroke
      }));

      // Fire all endpoint calls simultaneously – backend handles queueing / concurrency
      const calls = payloads.map(async payload => {
        try {
          const res = await fetch(API_OPERATIONAL, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(payload)
          });
          const data = await res.json();
          if (!res.ok) {
            throw new Error(data.message || data.error || "Request failed");
          }
          const inst = instruments.find(i => i.id === payload.instrument_id);
          return {
            ok: true,
            instrument_id: payload.instrument_id,
            instrument_name: inst ? inst.name : `Instrument #${payload.instrument_id}`,
            task_id: data.task_id,
            status: data.status
          };
        } catch (err) {
          return {
            ok: false,
            instrument_id: payload.instrument_id,
            error: err.message || String(err)
          };
        }
      });

      const results = await Promise.all(calls);

      results.forEach(entry => {
        const div = document.createElement("div");
        div.className = "run-item";
        if (entry.ok) {
          div.textContent =
            `${entry.instrument_name} (#${entry.instrument_id}): ` +
            `queued as task ${entry.task_id} (status: ${entry.status}).`;
        } else {
          div.textContent =
            `Instrument #${entry.instrument_id ?? "?"}: error submitting – ${entry.error}`;
        }
        resultsEl.appendChild(div);
      });

      statusEl.textContent = `Submitted ${instrumentIds.length} task(s). Backend worker will process them via the queue.`;
      runBtn.disabled = false;

      // Refresh previous runs shortly after submitting
      setTimeout(() => {
        loadPreviousRuns();
      }, 1500);
    }

    async function loadPreviousRuns() {
      const container = document.getElementById("previous-runs");
      if (!artId || !colorId) {
        container.textContent = "Missing art_id or color_id.";
        return;
      }

      container.textContent = "Loading…";

      try {
        const url = `${API_BRUSH_LIST}?art_id=${encodeURIComponent(artId)}&color_id=${encodeURIComponent(colorId)}`;
        const res = await fetch(url);
        const data = await res.json();
        if (!res.ok) throw new Error(data.message || "Failed to load brush strokes");

        const rows = Array.isArray(data) ? data : [];
        if (!rows.length) {
          container.innerHTML = '<div class="muted">No previous runs for this color yet.</div>';
          return;
        }

        // Sort newest first by created_at (backend already does, but just in case)
        rows.sort((a, b) =>
          String(b.created_at || "").localeCompare(String(a.created_at || ""))
        );

        container.innerHTML = "";
        rows.forEach(row => {
          const inst = instruments.find(i => i.id === row.instrument_id);
          const instName = inst
            ? inst.name
            : (row.instrument_id != null ? `Instrument #${row.instrument_id}` : "Unknown instrument");

          const card = document.createElement("div");
          card.className = "prev-card";

          const head = document.createElement("div");
          head.className = "prev-head";

          const title = document.createElement("div");
          title.innerHTML = `<strong>${escapeHtml(instName)}</strong>`;

          const meta = document.createElement("div");
          meta.className = "muted";
          meta.textContent = `Brush stroke #${row.id} · ${row.created_at || ""}`;

          head.appendChild(title);
          head.appendChild(meta);

          const body = document.createElement("pre");
          body.className = "prev-body";
          body.textContent = row.output_text || "";

          card.appendChild(head);
          card.appendChild(body);

          container.appendChild(card);
        });
      } catch (err) {
        container.textContent = err.message || "Error loading previous runs.";
      }
    }

    function escapeHtml(str) {
      return String(str)
        .replaceAll("&", "&amp;")
        .replaceAll("<", "&lt;")
        .replaceAll(">", "&gt;")
        .replaceAll('"', "&quot;")
        .replaceAll("'", "&#039;");
    }

    // Init sequence
    (async () => {
      await loadColor();
      await loadInstruments();
      await loadPreviousRuns();
    })();
  </script>
</body>
</html>
