<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Colors Viewer</title>
  <style>
    body { font-family: sans-serif; padding: 20px; }
    .block { border: 1px solid #ccc; padding: 12px; margin-bottom: 16px; border-radius: 8px; }
    pre { white-space: pre-wrap; }

    .controls { margin-top: 8px; display: flex; gap: 6px; flex-wrap: wrap; }
    button { padding: 6px 10px; cursor: pointer; }
    .status { font-size: 12px; color: #333; margin-top: 6px; white-space: pre-wrap; }

    /* Collapsible groups */
    .entity-group { border-top: 1px dashed #ddd; margin-top: 10px; padding-top: 8px; }
    .entity-header {
      display: flex;
      align-items: center;
      gap: 8px;
      cursor: pointer;
      user-select: none;
      font-weight: 700;
      padding: 6px 4px;
      border-radius: 6px;
      background: #f7f7f7;
    }
    .entity-header:hover { background: #efefef; }
    .entity-caret {
      width: 18px;
      text-align: center;
      font-size: 12px;
    }
    .entity-count {
      font-weight: 400;
      font-size: 12px;
      color: #555;
    }
    .entity-body { margin-top: 8px; padding-left: 6px; }
    .entity-item { margin-bottom: 12px; padding-bottom: 8px; border-bottom: 1px solid #eee; }
    .entity-item:last-child { border-bottom: none; }
    .entity-name { font-weight: 600; margin-bottom: 4px; }
    .entity-text { white-space: pre-wrap; margin: 4px 0; }
  </style>
</head>
<body>
  <h1>Colors Expansion</h1>
  <div id="content"></div>

  <script>
    function escapeHtml(s) {
      return String(s)
        .replaceAll('&', '&amp;')
        .replaceAll('<', '&lt;')
        .replaceAll('>', '&gt;')
        .replaceAll('"', '&quot;')
        .replaceAll("'", '&#039;');
    }

    function openEntityInNewTab(entityObj, colorId, groupKey, idx) {
      const w = window.open('', '_blank');
      if (!w) return;

      const name = escapeHtml(entityObj.name || '');
      const desc = escapeHtml(entityObj.description || '');
      const role = escapeHtml(entityObj.role_in_thought || '');

      w.document.write(`
        <!DOCTYPE html>
        <html>
          <head>
            <title>${escapeHtml(groupKey)} #${idx + 1} (Color ${colorId})</title>
          </head>
          <body style="font-family:sans-serif; padding:20px;">
            <h2>${escapeHtml(groupKey)} — Entity ${idx + 1} (Color ${colorId})</h2>
            <h3>${name}</h3>
            <p><strong>Description:</strong> ${desc}</p>
            <p><strong>Role in thought:</strong> ${role}</p>
            <pre style="white-space:pre-wrap;">${escapeHtml(JSON.stringify(entityObj, null, 2))}</pre>
          </body>
        </html>
      `);
      w.document.close();
    }

    async function fetchBridgeForColor(colorId) {
        const res = await fetch(`/colors/bridges/by_color/${colorId}`);
        if (!res.ok) return null;

        const rows = await res.json();
        if (!Array.isArray(rows) || rows.length === 0) return null;

        const latest = rows[0];
        return latest.bridge_text || null;
        }


    async function enqueueBridge(colorId, statusDiv, archDiv) {
        statusDiv.textContent = 'Queued bridge…';

        const res = await fetch('/colors/bridge_simulation', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ color_id: colorId })
        });

        const data = await res.json();
        if (!res.ok) {
            statusDiv.textContent = data.message || 'Error queueing simulation bridge.';
            return;
        }

        const taskId = data.task_id;
        statusDiv.textContent = `Simulation bridge queued (task ${taskId}). Waiting…`;

        try {
            const result = await pollTask(taskId, statusDiv);
            statusDiv.textContent = `Simulation bridge done. Saved #${result.saved_bridge?.id || ''}.`;

            const text = await fetchBridgeForColor(colorId);
            renderBridge(archDiv, text);
        } catch (e) {
            statusDiv.textContent = `Simulation bridge error: ${e.message || e}`;
        }
    }


    async function pollTask(taskId, statusDiv) {
      while (true) {
        const r = await fetch(`/colors/tasks/${taskId}`);
        const t = await r.json();
        if (!r.ok) throw new Error(t.message || 'Polling failed');
        if (t.status === 'done') return t.result;
        if (t.status === 'error') throw new Error(t.error || 'Task error');
        statusDiv.textContent = `Status: ${t.status}…`;
        await new Promise(ok => setTimeout(ok, 1200));
      }
    }

    function renderBridge(archDiv, text) {
        archDiv.innerHTML = '';
        if (!text) {
            archDiv.innerHTML = '<em>No simulation bridge yet.</em>';
            return;
        }

        const pre = document.createElement('pre');
        pre.textContent = text;
        archDiv.appendChild(pre);
    }

    function renderTheoryArchitecture(div, text) {
  div.innerHTML = '';
  if (!text) {
    div.innerHTML = '<em>No theory architecture yet.</em>';
    return;
  }
  const pre = document.createElement('pre');
  pre.textContent = text;
  div.appendChild(pre);
}

async function enqueueTheoryArchitecture(colorId, statusDiv, outDiv) {
  statusDiv.textContent = 'Queued theory architecture…';

  const res = await fetch('/colors/theory_architecture', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ color_id: colorId })
  });

  const data = await res.json();
  if (!res.ok) {
    statusDiv.textContent = data.message || 'Error queueing theory architecture.';
    return;
  }

  const taskId = data.task_id;
  statusDiv.textContent = `Theory architecture queued (task ${taskId}). Waiting…`;

  try {
    const result = await pollTask(taskId, statusDiv);
    statusDiv.textContent = `Theory architecture done. Saved #${result.saved_bridge?.id || ''}.`;

    // Use the task output directly (don’t refetch bridges, since table is shared)
    const text = result.theory_text || result.architecture_text || '';
    renderTheoryArchitecture(outDiv, text);

  } catch (e) {
    statusDiv.textContent = `Theory architecture error: ${e.message || e}`;
  }
}



    async function loadColor() {
      const params = new URLSearchParams(window.location.search);
      const artId = params.get('art_id');
      if (!artId) {
        document.getElementById('content').textContent = 'Missing art_id parameter.';
        return;
      }

      try {
        const res = await fetch(`/colors/by_art/${artId}`);
        const data = await res.json();
        const container = document.getElementById('content');
        container.innerHTML = '';

        if (!Array.isArray(data) || data.length === 0) {
          container.textContent = 'No colors expansions found for this art.';
          return;
        }

        for (const entry of data) {
          const div = document.createElement('div');
          div.className = 'block';

          const entitiesDivId = `entities-${entry.id}`;
          const statusDivId = `status-${entry.id}`;

          div.innerHTML = `
            <strong>Color ID:</strong> ${entry.id}<br>
            <strong>Art ID:</strong> ${entry.art_id}<br>
            <strong>Model:</strong> ${entry.model}<br>
            <strong>Temperature:</strong> ${entry.temperature}<br>
            <strong>Created:</strong> ${entry.created_at}<br>
            <pre>${escapeHtml(entry.output_text)}</pre>

            <div class="controls">
            <button id="gen-arch-btn-${entry.id}">Simulation Architecture</button>
            <button id="gen-theory-btn-${entry.id}">Theory Architecture</button>
            </div>
            <div id="${statusDivId}" class="status"></div>
            <div id="${entitiesDivId}" class="status" style="margin-top:8px;"></div>
            <div id="theory-div-${entry.id}" class="status" style="margin-top:8px;"></div>


          `;

          container.appendChild(div);

          const statusDiv = document.getElementById(statusDivId);
          const entitiesDiv = document.getElementById(entitiesDivId);
          const genBtn = document.getElementById(`gen-arch-btn-${entry.id}`);
          genBtn.onclick = () => enqueueBridge(entry.id, statusDiv, entitiesDiv);
          const theoryDiv = document.getElementById(`theory-div-${entry.id}`);
          const theoryBtn = document.getElementById(`gen-theory-btn-${entry.id}`);
          theoryBtn.onclick = () => enqueueTheoryArchitecture(entry.id, statusDiv, theoryDiv);

          const text = await fetchBridgeForColor(entry.id);
          renderBridge(entitiesDiv, text);

          // no fetch on load (bridges table is shared)
          renderTheoryArchitecture(theoryDiv, null);

        }

      } catch (e) {
        document.getElementById('content').textContent = 'Error: ' + e;
      }
    }

    loadColor();
  </script>
</body>
</html>
