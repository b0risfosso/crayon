<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Colors Viewer</title>
  <style>
    body { font-family: sans-serif; padding: 20px; }
    .block { border: 1px solid #ccc; padding: 12px; margin-bottom: 16px; border-radius: 8px; }
    pre { white-space: pre-wrap; }

    .controls { margin-top: 8px; display: flex; gap: 6px; flex-wrap: wrap; }
    .controls.individual { margin-top: 6px; padding: 6px 0 0 8px; border-left: 2px solid #eee; }
    button { padding: 6px 10px; cursor: pointer; }
    button:disabled { opacity: 0.5; cursor: not-allowed; }
    .status { font-size: 12px; color: #333; margin-top: 6px; white-space: pre-wrap; }
    .muted { font-size: 12px; color: #666; }

    /* Collapsible bridge sections */
    .bridge-group { margin-top: 10px; border: 1px solid #e0e0e0; border-radius: 6px; overflow: hidden; }
    .bridge-header {
      background: #f7f7f7;
      padding: 6px 8px;
      cursor: pointer;
      user-select: none;
      font-weight: 600;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
    }
    .bridge-header .meta { font-weight: 400; font-size: 12px; color: #555; }
    .bridge-content { padding: 8px; border-top: 1px solid #eee; }
    .bridge-content.collapsed { display: none; }
    .caret { font-size: 12px; color: #666; margin-left: 6px; }

    /* New split layout */
    .below-thought {
      display: flex;
      gap: 12px;
      margin-top: 10px;
      align-items: flex-start;
    }
    .left-col {
      width: 70%;
      min-width: 0;
    }
    .right-col {
      width: 30%;
      min-width: 220px;
      border-left: 1px solid #eee;
      padding-left: 10px;
      position: sticky;
      top: 12px; /* mild stickiness when scrolling within big blocks */
    }

    /* Brush strokes panel */
    .brush-panel h3 { margin: 0 0 6px 0; font-size: 16px; }
    .brush-list {
      list-style: none;
      padding: 0;
      margin: 6px 0 10px 0;
      display: flex;
      flex-direction: column;
      gap: 6px;
      max-height: 360px;
      overflow: auto;
      border: 1px solid #f0f0f0;
      border-radius: 6px;
      padding: 6px;
      background: #fafafa;
    }
    .brush-item a {
      text-decoration: none;
      color: #111;
      display: block;
      padding: 6px 8px;
      border-radius: 6px;
      background: white;
      border: 1px solid #eee;
    }
    .brush-item a:hover { background: #f5f5f5; }

    .brush-form {
      display: flex;
      flex-direction: column;
      gap: 6px;
      margin-top: 8px;
    }
    .brush-form input[type="text"] {
      padding: 6px 8px;
      border: 1px solid #ccc;
      border-radius: 6px;
      width: 100%;
      box-sizing: border-box;
    }
    .bridge-select {
      border: 1px solid #eee;
      background: #fff;
      padding: 6px;
      border-radius: 6px;
      display: flex;
      flex-direction: column;
      gap: 4px;
      max-height: 180px;
      overflow: auto;
      font-size: 12px;
    }
    .bridge-select label { display: flex; gap: 6px; align-items: center; }
    .divider { height: 1px; background: #eee; margin: 6px 0; }
  </style>
</head>
<body>
  <h1>Colors Viewer</h1>
  <div id="content">Loading...</div>

  <script>
    const BRUSH_STROKE_ENDPOINT = "/colors/brush_stroke_bridge";

    function escapeHtml(str) {
      if (str == null) return '';
      return String(str)
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#39;');
    }

    function getParam(name) {
      const params = new URLSearchParams(window.location.search);
      return params.get(name);
    }

    async function pollTask(taskId, statusDiv) {
      const softMaxMs = 2 * 60 * 1000;   // 2 minutes
      const hardMaxMs = 30 * 60 * 1000;  // 30 minutes safety cap

      const t0 = Date.now();
      let intervalMs = 1200;

      while (true) {
        const res = await fetch(`/colors/tasks/${taskId}`);
        const data = await res.json();

        if (!res.ok) throw new Error(data.message || 'task poll failed');
        if (data.status === 'done') return data.result;
        if (data.status === 'error') throw new Error(data.error || 'task error');

        const elapsed = Date.now() - t0;
        const elapsedS = Math.floor(elapsed / 1000);

        if (elapsed > softMaxMs) {
          statusDiv.textContent =
            `Task ${taskId}: ${data.status}… still running (${elapsedS}s).`;
          intervalMs = Math.min(intervalMs * 1.25, 8000);
        } else {
          statusDiv.textContent =
            `Task ${taskId}: ${data.status}… (${elapsedS}s)`;
        }

        if (elapsed > hardMaxMs) {
          throw new Error(
            `task exceeded ${Math.floor(hardMaxMs/60000)}min client cap; worker may still be running`
          );
        }

        await new Promise(r => setTimeout(r, intervalMs));
      }
    }

    async function fetchBridgeOfType(colorId, bridgeType) {
      const res = await fetch(`/colors/bridges/by_color/${colorId}/${bridgeType}`);
      if (!res.ok) return null;
      const rows = await res.json();
      if (!Array.isArray(rows) || rows.length === 0) return null;
      return rows[0].bridge_text || null;
    }

    async function fetchAllBridges(colorId) {
      const res = await fetch(`/colors/bridges/by_color/${colorId}`);
      if (!res.ok) return [];
      const rows = await res.json();
      return Array.isArray(rows) ? rows : [];
    }

    function renderBridge(contentDiv, text) {
      contentDiv.innerHTML = '';
      if (!text) {
        contentDiv.innerHTML = '<em>No bridge yet.</em>';
        return;
      }
      const pre = document.createElement('pre');
      pre.textContent = text;
      contentDiv.appendChild(pre);
    }

    function wireCollapse(headerEl, contentEl) {
      headerEl.addEventListener('click', () => {
        const collapsed = contentEl.classList.toggle('collapsed');
        const caret = headerEl.querySelector('.caret');
        if (caret) caret.textContent = collapsed ? '▶' : '▼';
      });
    }

    async function enqueueBridge(colorId, bridgeType, endpoint, statusDiv, contentDiv, headerMetaEl, buttonEl) {
      statusDiv.textContent = `Queued ${bridgeType}…`;
      if (buttonEl) buttonEl.disabled = true;

      const res = await fetch(endpoint, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ color_id: colorId })
      });

      const data = await res.json();
      if (!res.ok) {
        statusDiv.textContent = data.message || `Error queueing ${bridgeType}.`;
        if (buttonEl) buttonEl.disabled = false;
        return;
      }

      const taskId = data.task_id;
      statusDiv.textContent = `${bridgeType} queued (task ${taskId}). Waiting…`;

      try {
        const result = await pollTask(taskId, statusDiv);
        const text = result.bridge_text || result.architecture_text || result.theory_text || '';
        renderBridge(contentDiv, text);
        contentDiv.classList.remove('collapsed');
        const caret = contentDiv.parentElement.querySelector('.caret');
        if (caret) caret.textContent = '▼';
        const savedId = result.saved_bridge?.id;
        headerMetaEl.textContent = savedId ? `latest #${savedId}` : 'latest';
        statusDiv.textContent = `${bridgeType} done.`;
      } catch (e) {
        statusDiv.textContent = `${bridgeType} error: ${e.message || e}`;
        throw e;
      } finally {
        if (buttonEl) buttonEl.disabled = false;
      }
    }

    // ---------- Brush strokes ----------
    async function fetchEntitiesForColor(colorId) {
      const res = await fetch(`/colors/entities/by_color/${colorId}`);
      if (!res.ok) return [];
      const rows = await res.json();
      if (!Array.isArray(rows) || rows.length === 0) return [];
      const latest = rows[0];
      const ej = latest.entities_json;
      if (Array.isArray(ej)) return ej;
      try {
        const parsed = JSON.parse(ej);
        return Array.isArray(parsed) ? parsed : [];
      } catch {
        return [];
      }
    }

    async function loadBrushStrokes(colorId, listEl) {
      listEl.innerHTML = '';
      const entities = await fetchEntitiesForColor(colorId);

      if (!entities.length) {
        const li = document.createElement('li');
        li.innerHTML = '<em>No entities yet. Run entity extraction.</em>';
        listEl.appendChild(li);
        return;
      }

      for (const ent of entities) {
        const name = ent?.name || 'unknown';
        const li = document.createElement('li');
        li.className = 'brush-item';

        const a = document.createElement('a');
        a.href = `brush_stroke.html?color_id=${colorId}&entity=${encodeURIComponent(name)}`;
        a.textContent = name;

        li.appendChild(a);
        listEl.appendChild(li);
      }
    }

    function baseBridgeTypes() {
      // must match your canonical “base” bridge types
      return [
        "simulation_architecture",
        "theory_architecture",
        "physical_world_bridge",
        "math_bridge",
        "language_bridge",
        "data_bridge",
        "computational_bridge",
        "music_bridge",
        "information_bridge",
        "poetry_bridge",
        "metaphysics_bridge",
        "thought"
      ];
    }

    async function getLatestBridgeIdByType(colorId) {
      const rows = await fetchAllBridges(colorId);
      const byType = {};
      for (const r of rows) {
        const t = r.bridge_type;
        if (!t || t.endsWith("_brush_stroke")) continue;
        if (!(t in byType)) byType[t] = r; // rows already newest-first
      }
      return byType; // {type: row}
    }

    async function enqueueBrushStroke(bridgeId, entityText, statusDiv) {
      statusDiv.textContent = `Queued brush stroke for bridge ${bridgeId}…`;

      const res = await fetch(BRUSH_STROKE_ENDPOINT, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ bridge_id: bridgeId, entity_text: entityText })
      });

      const data = await res.json();
      if (!res.ok) {
        statusDiv.textContent = data.message || "Error queueing brush stroke.";
        return { bridgeId, ok: false };
      }

      const taskId = data.task_id;
      statusDiv.textContent = `Brush stroke queued (task ${taskId}). Waiting…`;

      try {
        await pollTask(taskId, statusDiv);
        statusDiv.textContent = `Brush stroke done for bridge ${bridgeId}.`;
        return { bridgeId, ok: true };
      } catch (e) {
        statusDiv.textContent = `Brush stroke error for bridge ${bridgeId}: ${e.message || e}`;
        return { bridgeId, ok: false, error: e };
      }
    }

    async function loadColor() {
      const artId = getParam('art_id');
      if (!artId) {
        document.getElementById('content').textContent = 'Missing art_id parameter.';
        return;
      }

      try {
        const res = await fetch(`/colors/by_art/${artId}`);
        const data = await res.json();
        const container = document.getElementById('content');
        container.innerHTML = '';

        if (!Array.isArray(data) || data.length === 0) {
          container.textContent = 'No colors expansions found for this art.';
          return;
        }

        for (const entry of data) {
          const div = document.createElement('div');
          div.className = 'block';

          const contentIds = {};
          contentIds['simulation_architecture'] = `simulation_architecture-content-${entry.id}`;
          contentIds['theory_architecture'] = `theory_architecture-content-${entry.id}`;
          contentIds['physical_world_bridge'] = `physical_world_bridge-content-${entry.id}`;
          contentIds['math_bridge'] = `math_bridge-content-${entry.id}`;
          contentIds['language_bridge'] = `language_bridge-content-${entry.id}`;
          contentIds['data_bridge'] = `data_bridge-content-${entry.id}`;
          contentIds['computational_bridge'] = `computational_bridge-content-${entry.id}`;
          contentIds['music_bridge'] = `music_bridge-content-${entry.id}`;
          contentIds['information_bridge'] = `information_bridge-content-${entry.id}`;
          contentIds['poetry_bridge'] = `poetry_bridge-content-${entry.id}`;
          contentIds['metaphysics_bridge'] = `metaphysics_bridge-content-${entry.id}`;
          contentIds['thought'] = `thought-content-${entry.id}`;

          // Thought (full width), then split below
          div.innerHTML = `
            <strong>Color ID:</strong> ${entry.id}<br>
            <strong>Art ID:</strong> ${entry.art_id}<br>
            <strong>Model:</strong> ${escapeHtml(entry.model)}<br>
            <strong>Temperature:</strong> ${entry.temperature}<br>
            <strong>Created:</strong> ${entry.created_at}<br>
            <pre>${escapeHtml(entry.output_text)}</pre>

            <div class="below-thought">
              <div class="left-col">
                <!-- RUN ALL + TOGGLE -->
                <div class="controls">
                  <button id="gen-all-btn-${entry.id}">Bridge All</button>
                  <button id="toggle-individual-btns-${entry.id}" class="muted">Show individual bridges ▶</button>
                </div>
                <div id="all-status-${entry.id}" class="status"></div>

                <!-- INDIVIDUAL BUTTONS (collapsed by default) -->
                <div id="individual-btns-${entry.id}" class="controls individual" style="display:none;">
                  <button id="gen-simulation_architecture-btn-${entry.id}">Simulation Architecture</button>
                  <button id="gen-theory_architecture-btn-${entry.id}">Theory Architecture</button>
                  <button id="gen-physical_world_bridge-btn-${entry.id}">Physical World Bridge</button>
                  <button id="gen-math_bridge-btn-${entry.id}">Math Bridge</button>
                  <button id="gen-language_bridge-btn-${entry.id}">Language Bridge</button>
                  <button id="gen-data_bridge-btn-${entry.id}">Data Bridge</button>
                  <button id="gen-computational_bridge-btn-${entry.id}">Computational Bridge</button>
                  <button id="gen-music_bridge-btn-${entry.id}">Music Bridge</button>
                  <button id="gen-information_bridge-btn-${entry.id}">Information Bridge</button>
                  <button id="gen-poetry_bridge-btn-${entry.id}">Poetry Bridge</button>
                  <button id="gen-metaphysics_bridge-btn-${entry.id}">Metaphysics Bridge</button>
                  <button id="gen-thought-btn-${entry.id}">Thought → Thought</button>
                </div>

                <!-- BRIDGES -->
                <div class="bridge-group">
                  <div class="bridge-header" id="simulation_architecture-header-${entry.id}">
                    <div>Simulation Architecture</div>
                    <div class="meta">
                      <span id="simulation_architecture-meta-${entry.id}">latest</span>
                      <span class="caret">▶</span>
                    </div>
                  </div>
                  <div class="bridge-content collapsed" id="${contentIds['simulation_architecture']}"></div>
                </div>
                <div id="simulation_architecture-status-${entry.id}" class="status"></div>

                <div class="bridge-group">
                  <div class="bridge-header" id="theory_architecture-header-${entry.id}">
                    <div>Theory Architecture</div>
                    <div class="meta">
                      <span id="theory_architecture-meta-${entry.id}">latest</span>
                      <span class="caret">▶</span>
                    </div>
                  </div>
                  <div class="bridge-content collapsed" id="${contentIds['theory_architecture']}"></div>
                </div>
                <div id="theory_architecture-status-${entry.id}" class="status"></div>

                <div class="bridge-group">
                  <div class="bridge-header" id="physical_world_bridge-header-${entry.id}">
                    <div>Physical World Bridge</div>
                    <div class="meta">
                      <span id="physical_world_bridge-meta-${entry.id}">latest</span>
                      <span class="caret">▶</span>
                    </div>
                  </div>
                  <div class="bridge-content collapsed" id="${contentIds['physical_world_bridge']}"></div>
                </div>
                <div id="physical_world_bridge-status-${entry.id}" class="status"></div>

                <div class="bridge-group">
                  <div class="bridge-header" id="math_bridge-header-${entry.id}">
                    <div>Math Bridge</div>
                    <div class="meta">
                      <span id="math_bridge-meta-${entry.id}">latest</span>
                      <span class="caret">▶</span>
                    </div>
                  </div>
                  <div class="bridge-content collapsed" id="${contentIds['math_bridge']}"></div>
                </div>
                <div id="math_bridge-status-${entry.id}" class="status"></div>

                <div class="bridge-group">
                  <div class="bridge-header" id="language_bridge-header-${entry.id}">
                    <div>Language Bridge</div>
                    <div class="meta">
                      <span id="language_bridge-meta-${entry.id}">latest</span>
                      <span class="caret">▶</span>
                    </div>
                  </div>
                  <div class="bridge-content collapsed" id="${contentIds['language_bridge']}"></div>
                </div>
                <div id="language_bridge-status-${entry.id}" class="status"></div>

                <div class="bridge-group">
                  <div class="bridge-header" id="data_bridge-header-${entry.id}">
                    <div>Data Bridge</div>
                    <div class="meta">
                      <span id="data_bridge-meta-${entry.id}">latest</span>
                      <span class="caret">▶</span>
                    </div>
                  </div>
                  <div class="bridge-content collapsed" id="${contentIds['data_bridge']}"></div>
                </div>
                <div id="data_bridge-status-${entry.id}" class="status"></div>

                <div class="bridge-group">
                  <div class="bridge-header" id="computational_bridge-header-${entry.id}">
                    <div>Computational Bridge</div>
                    <div class="meta">
                      <span id="computational_bridge-meta-${entry.id}">latest</span>
                      <span class="caret">▶</span>
                    </div>
                  </div>
                  <div class="bridge-content collapsed" id="${contentIds['computational_bridge']}"></div>
                </div>
                <div id="computational_bridge-status-${entry.id}" class="status"></div>

                <div class="bridge-group">
                  <div class="bridge-header" id="music_bridge-header-${entry.id}">
                    <div>Music Bridge</div>
                    <div class="meta">
                      <span id="music_bridge-meta-${entry.id}">latest</span>
                      <span class="caret">▶</span>
                    </div>
                  </div>
                  <div class="bridge-content collapsed" id="${contentIds['music_bridge']}"></div>
                </div>
                <div id="music_bridge-status-${entry.id}" class="status"></div>

                <div class="bridge-group">
                  <div class="bridge-header" id="information_bridge-header-${entry.id}">
                    <div>Information Bridge</div>
                    <div class="meta">
                      <span id="information_bridge-meta-${entry.id}">latest</span>
                      <span class="caret">▶</span>
                    </div>
                  </div>
                  <div class="bridge-content collapsed" id="${contentIds['information_bridge']}"></div>
                </div>
                <div id="information_bridge-status-${entry.id}" class="status"></div>

                <div class="bridge-group">
                  <div class="bridge-header" id="poetry_bridge-header-${entry.id}">
                    <div>Poetry Bridge</div>
                    <div class="meta">
                      <span id="poetry_bridge-meta-${entry.id}">latest</span>
                      <span class="caret">▶</span>
                    </div>
                  </div>
                  <div class="bridge-content collapsed" id="${contentIds['poetry_bridge']}"></div>
                </div>
                <div id="poetry_bridge-status-${entry.id}" class="status"></div>

                <div class="bridge-group">
                  <div class="bridge-header" id="metaphysics_bridge-header-${entry.id}">
                    <div>Metaphysics Bridge</div>
                    <div class="meta">
                      <span id="metaphysics_bridge-meta-${entry.id}">latest</span>
                      <span class="caret">▶</span>
                    </div>
                  </div>
                  <div class="bridge-content collapsed" id="${contentIds['metaphysics_bridge']}"></div>
                </div>
                <div id="metaphysics_bridge-status-${entry.id}" class="status"></div>

                <div class="bridge-group">
                  <div class="bridge-header" id="thought-header-${entry.id}">
                    <div>Thought → Thought</div>
                    <div class="meta">
                      <span id="thought-meta-${entry.id}">latest</span>
                      <span class="caret">▶</span>
                    </div>
                  </div>
                  <div class="bridge-content collapsed" id="${contentIds['thought']}"></div>
                </div>
                <div id="thought-status-${entry.id}" class="status"></div>
              </div>

              <div class="right-col">
                <div class="brush-panel">
                  <h3>Brush Strokes</h3>
                  <div class="muted">Entities for this color</div>
                  <ul id="brush-list-${entry.id}" class="brush-list"></ul>

                  <div class="divider"></div>

                  <div class="muted">Add brush stroke</div>
                  <div class="brush-form">
                    <input id="brush-input-${entry.id}" type="text" placeholder="entity / brush stroke text" />

                    <label class="muted">
                      <input id="brush-all-${entry.id}" type="checkbox" checked />
                      All bridges
                    </label>

                    <div id="brush-bridge-select-${entry.id}" class="bridge-select"></div>

                    <button id="brush-add-btn-${entry.id}">Add brush stroke → selected bridges</button>
                    <div id="brush-status-${entry.id}" class="status"></div>
                  </div>
                </div>
              </div>
            </div>
          `;

          container.appendChild(div);

          // Toggle individual buttons visibility
          const individualBtnsDiv = document.getElementById(`individual-btns-${entry.id}`);
          const toggleBtnsBtn = document.getElementById(`toggle-individual-btns-${entry.id}`);
          toggleBtnsBtn.onclick = () => {
            const isHidden = individualBtnsDiv.style.display === 'none';
            individualBtnsDiv.style.display = isHidden ? 'flex' : 'none';
            toggleBtnsBtn.textContent = isHidden ? 'Hide individual bridges ▼' : 'Show individual bridges ▶';
          };

          // Content + meta + collapse wiring
          const simulation_architectureContentDiv = document.getElementById(contentIds['simulation_architecture']);
          const simulation_architectureMeta = document.getElementById(`simulation_architecture-meta-${entry.id}`);
          wireCollapse(document.getElementById(`simulation_architecture-header-${entry.id}`), simulation_architectureContentDiv);

          const theory_architectureContentDiv = document.getElementById(contentIds['theory_architecture']);
          const theory_architectureMeta = document.getElementById(`theory_architecture-meta-${entry.id}`);
          wireCollapse(document.getElementById(`theory_architecture-header-${entry.id}`), theory_architectureContentDiv);

          const physical_world_bridgeContentDiv = document.getElementById(contentIds['physical_world_bridge']);
          const physical_world_bridgeMeta = document.getElementById(`physical_world_bridge-meta-${entry.id}`);
          wireCollapse(document.getElementById(`physical_world_bridge-header-${entry.id}`), physical_world_bridgeContentDiv);

          const math_bridgeContentDiv = document.getElementById(contentIds['math_bridge']);
          const math_bridgeMeta = document.getElementById(`math_bridge-meta-${entry.id}`);
          wireCollapse(document.getElementById(`math_bridge-header-${entry.id}`), math_bridgeContentDiv);

          const language_bridgeContentDiv = document.getElementById(contentIds['language_bridge']);
          const language_bridgeMeta = document.getElementById(`language_bridge-meta-${entry.id}`);
          wireCollapse(document.getElementById(`language_bridge-header-${entry.id}`), language_bridgeContentDiv);

          const data_bridgeContentDiv = document.getElementById(contentIds['data_bridge']);
          const data_bridgeMeta = document.getElementById(`data_bridge-meta-${entry.id}`);
          wireCollapse(document.getElementById(`data_bridge-header-${entry.id}`), data_bridgeContentDiv);

          const computational_bridgeContentDiv = document.getElementById(contentIds['computational_bridge']);
          const computational_bridgeMeta = document.getElementById(`computational_bridge-meta-${entry.id}`);
          wireCollapse(document.getElementById(`computational_bridge-header-${entry.id}`), computational_bridgeContentDiv);

          const music_bridgeContentDiv = document.getElementById(contentIds['music_bridge']);
          const music_bridgeMeta = document.getElementById(`music_bridge-meta-${entry.id}`);
          wireCollapse(document.getElementById(`music_bridge-header-${entry.id}`), music_bridgeContentDiv);

          const information_bridgeContentDiv = document.getElementById(contentIds['information_bridge']);
          const information_bridgeMeta = document.getElementById(`information_bridge-meta-${entry.id}`);
          wireCollapse(document.getElementById(`information_bridge-header-${entry.id}`), information_bridgeContentDiv);

          const poetry_bridgeContentDiv = document.getElementById(contentIds['poetry_bridge']);
          const poetry_bridgeMeta = document.getElementById(`poetry_bridge-meta-${entry.id}`);
          wireCollapse(document.getElementById(`poetry_bridge-header-${entry.id}`), poetry_bridgeContentDiv);

          const metaphysics_bridgeContentDiv = document.getElementById(contentIds['metaphysics_bridge']);
          const metaphysics_bridgeMeta = document.getElementById(`metaphysics_bridge-meta-${entry.id}`);
          wireCollapse(document.getElementById(`metaphysics_bridge-header-${entry.id}`), metaphysics_bridgeContentDiv);

          const thoughtContentDiv = document.getElementById(contentIds['thought']);
          const thoughtMeta = document.getElementById(`thought-meta-${entry.id}`);
          wireCollapse(document.getElementById(`thought-header-${entry.id}`), thoughtContentDiv);

          const simulation_architectureStatusDiv = document.getElementById(`simulation_architecture-status-${entry.id}`);
          const theory_architectureStatusDiv = document.getElementById(`theory_architecture-status-${entry.id}`);
          const physical_world_bridgeStatusDiv = document.getElementById(`physical_world_bridge-status-${entry.id}`);
          const math_bridgeStatusDiv = document.getElementById(`math_bridge-status-${entry.id}`);
          const language_bridgeStatusDiv = document.getElementById(`language_bridge-status-${entry.id}`);
          const data_bridgeStatusDiv = document.getElementById(`data_bridge-status-${entry.id}`);
          const computational_bridgeStatusDiv = document.getElementById(`computational_bridge-status-${entry.id}`);
          const music_bridgeStatusDiv = document.getElementById(`music_bridge-status-${entry.id}`);
          const information_bridgeStatusDiv = document.getElementById(`information_bridge-status-${entry.id}`);
          const poetry_bridgeStatusDiv = document.getElementById(`poetry_bridge-status-${entry.id}`);
          const metaphysics_bridgeStatusDiv = document.getElementById(`metaphysics_bridge-status-${entry.id}`);
          const thoughtStatusDiv = document.getElementById(`thought-status-${entry.id}`);
          const allStatusDiv = document.getElementById(`all-status-${entry.id}`);

          // Load existing bridges by type
          renderBridge(simulation_architectureContentDiv, await fetchBridgeOfType(entry.id, "simulation_architecture"));
          renderBridge(theory_architectureContentDiv, await fetchBridgeOfType(entry.id, "theory_architecture"));
          renderBridge(physical_world_bridgeContentDiv, await fetchBridgeOfType(entry.id, "physical_world_bridge"));
          renderBridge(math_bridgeContentDiv, await fetchBridgeOfType(entry.id, "math_bridge"));
          renderBridge(language_bridgeContentDiv, await fetchBridgeOfType(entry.id, "language_bridge"));
          renderBridge(data_bridgeContentDiv, await fetchBridgeOfType(entry.id, "data_bridge"));
          renderBridge(computational_bridgeContentDiv, await fetchBridgeOfType(entry.id, "computational_bridge"));
          renderBridge(music_bridgeContentDiv, await fetchBridgeOfType(entry.id, "music_bridge"));
          renderBridge(information_bridgeContentDiv, await fetchBridgeOfType(entry.id, "information_bridge"));
          renderBridge(poetry_bridgeContentDiv, await fetchBridgeOfType(entry.id, "poetry_bridge"));
          renderBridge(metaphysics_bridgeContentDiv, await fetchBridgeOfType(entry.id, "metaphysics_bridge"));
          renderBridge(thoughtContentDiv, await fetchBridgeOfType(entry.id, "thought"));

          // Individual buttons wiring
          const simulation_architectureBtn = document.getElementById(`gen-simulation_architecture-btn-${entry.id}`);
          simulation_architectureBtn.onclick = () =>
            enqueueBridge(entry.id, "simulation_architecture", "/colors/simulation_architecture",
              simulation_architectureStatusDiv, simulation_architectureContentDiv, simulation_architectureMeta, simulation_architectureBtn);

          const theory_architectureBtn = document.getElementById(`gen-theory_architecture-btn-${entry.id}`);
          theory_architectureBtn.onclick = () =>
            enqueueBridge(entry.id, "theory_architecture", "/colors/theory_architecture",
              theory_architectureStatusDiv, theory_architectureContentDiv, theory_architectureMeta, theory_architectureBtn);

          const physical_world_bridgeBtn = document.getElementById(`gen-physical_world_bridge-btn-${entry.id}`);
          physical_world_bridgeBtn.onclick = () =>
            enqueueBridge(entry.id, "physical_world_bridge", "/colors/physical_world_bridge",
              physical_world_bridgeStatusDiv, physical_world_bridgeContentDiv, physical_world_bridgeMeta, physical_world_bridgeBtn);

          const math_bridgeBtn = document.getElementById(`gen-math_bridge-btn-${entry.id}`);
          math_bridgeBtn.onclick = () =>
            enqueueBridge(entry.id, "math_bridge", "/colors/math_bridge",
              math_bridgeStatusDiv, math_bridgeContentDiv, math_bridgeMeta, math_bridgeBtn);

          const language_bridgeBtn = document.getElementById(`gen-language_bridge-btn-${entry.id}`);
          language_bridgeBtn.onclick = () =>
            enqueueBridge(entry.id, "language_bridge", "/colors/language_bridge",
              language_bridgeStatusDiv, language_bridgeContentDiv, language_bridgeMeta, language_bridgeBtn);

          const data_bridgeBtn = document.getElementById(`gen-data_bridge-btn-${entry.id}`);
          data_bridgeBtn.onclick = () =>
            enqueueBridge(entry.id, "data_bridge", "/colors/data_bridge",
              data_bridgeStatusDiv, data_bridgeContentDiv, data_bridgeMeta, data_bridgeBtn);

          const computational_bridgeBtn = document.getElementById(`gen-computational_bridge-btn-${entry.id}`);
          computational_bridgeBtn.onclick = () =>
            enqueueBridge(entry.id, "computational_bridge", "/colors/computational_bridge",
              computational_bridgeStatusDiv, computational_bridgeContentDiv, computational_bridgeMeta, computational_bridgeBtn);

          const music_bridgeBtn = document.getElementById(`gen-music_bridge-btn-${entry.id}`);
          music_bridgeBtn.onclick = () =>
            enqueueBridge(entry.id, "music_bridge", "/colors/music_bridge",
              music_bridgeStatusDiv, music_bridgeContentDiv, music_bridgeMeta, music_bridgeBtn);

          const information_bridgeBtn = document.getElementById(`gen-information_bridge-btn-${entry.id}`);
          information_bridgeBtn.onclick = () =>
            enqueueBridge(entry.id, "information_bridge", "/colors/information_bridge",
              information_bridgeStatusDiv, information_bridgeContentDiv, information_bridgeMeta, information_bridgeBtn);

          const poetry_bridgeBtn = document.getElementById(`gen-poetry_bridge-btn-${entry.id}`);
          poetry_bridgeBtn.onclick = () =>
            enqueueBridge(entry.id, "poetry_bridge", "/colors/poetry_bridge",
              poetry_bridgeStatusDiv, poetry_bridgeContentDiv, poetry_bridgeMeta, poetry_bridgeBtn);

          const metaphysics_bridgeBtn = document.getElementById(`gen-metaphysics_bridge-btn-${entry.id}`);
          metaphysics_bridgeBtn.onclick = () =>
            enqueueBridge(entry.id, "metaphysics_bridge", "/colors/metaphysics_bridge",
              metaphysics_bridgeStatusDiv, metaphysics_bridgeContentDiv, metaphysics_bridgeMeta, metaphysics_bridgeBtn);

          const thoughtBtn = document.getElementById(`gen-thought-btn-${entry.id}`);
          thoughtBtn.onclick = () =>
            enqueueBridge(entry.id, "thought", "/colors/thought_bridge",
              thoughtStatusDiv, thoughtContentDiv, thoughtMeta, thoughtBtn);

          // RUN ALL wiring (unchanged)
          const allBtn = document.getElementById(`gen-all-btn-${entry.id}`);
          allBtn.onclick = async () => {
            allBtn.disabled = true;
            allStatusDiv.textContent = "Bridge all started… queueing everything.";

            const specs = [
              { type: "simulation_architecture", endpoint: "/colors/simulation_architecture",
                status: simulation_architectureStatusDiv, content: simulation_architectureContentDiv,
                meta: simulation_architectureMeta, btn: simulation_architectureBtn },
              { type: "theory_architecture", endpoint: "/colors/theory_architecture",
                status: theory_architectureStatusDiv, content: theory_architectureContentDiv,
                meta: theory_architectureMeta, btn: theory_architectureBtn },
              { type: "physical_world_bridge", endpoint: "/colors/physical_world_bridge",
                status: physical_world_bridgeStatusDiv, content: physical_world_bridgeContentDiv,
                meta: physical_world_bridgeMeta, btn: physical_world_bridgeBtn },
              { type: "math_bridge", endpoint: "/colors/math_bridge",
                status: math_bridgeStatusDiv, content: math_bridgeContentDiv,
                meta: math_bridgeMeta, btn: math_bridgeBtn },
              { type: "language_bridge", endpoint: "/colors/language_bridge",
                status: language_bridgeStatusDiv, content: language_bridgeContentDiv,
                meta: language_bridgeMeta, btn: language_bridgeBtn },
              { type: "data_bridge", endpoint: "/colors/data_bridge",
                status: data_bridgeStatusDiv, content: data_bridgeContentDiv,
                meta: data_bridgeMeta, btn: data_bridgeBtn },
              { type: "computational_bridge", endpoint: "/colors/computational_bridge",
                status: computational_bridgeStatusDiv, content: computational_bridgeContentDiv,
                meta: computational_bridgeMeta, btn: computational_bridgeBtn },
              { type: "music_bridge", endpoint: "/colors/music_bridge",
                status: music_bridgeStatusDiv, content: music_bridgeContentDiv,
                meta: music_bridgeMeta, btn: music_bridgeBtn },
              { type: "information_bridge", endpoint: "/colors/information_bridge",
                status: information_bridgeStatusDiv, content: information_bridgeContentDiv,
                meta: information_bridgeMeta, btn: information_bridgeBtn },
              { type: "poetry_bridge", endpoint: "/colors/poetry_bridge",
                status: poetry_bridgeStatusDiv, content: poetry_bridgeContentDiv,
                meta: poetry_bridgeMeta, btn: poetry_bridgeBtn },
              { type: "metaphysics_bridge", endpoint: "/colors/metaphysics_bridge",
                status: metaphysics_bridgeStatusDiv, content: metaphysics_bridgeContentDiv,
                meta: metaphysics_bridgeMeta, btn: metaphysics_bridgeBtn },
              { type: "thought", endpoint: "/colors/thought_bridge",
                status: thoughtStatusDiv, content: thoughtContentDiv,
                meta: thoughtMeta, btn: thoughtBtn },
            ];

            const jobs = specs.map(async (s) => {
              try {
                const existing = await fetchBridgeOfType(entry.id, s.type);
                if (existing) {
                  renderBridge(s.content, existing);
                  s.status.textContent = `${s.type} already exists, skipped.`;
                  return { type: s.type, skipped: true };
                }

                s.status.textContent = `${s.type} queued…`;
                await enqueueBridge(entry.id, s.type, s.endpoint, s.status, s.content, s.meta, s.btn);
                return { type: s.type, ok: true };
              } catch (e) {
                return { type: s.type, error: e };
              }
            });

            allStatusDiv.textContent = "All bridges queued. Waiting for completion…";
            const results = await Promise.allSettled(jobs);

            let failures = 0;
            let skipped = 0;
            let succeeded = 0;

            for (const r of results) {
              if (r.status === "fulfilled") {
                if (r.value?.error) failures += 1;
                else if (r.value?.skipped) skipped += 1;
                else succeeded += 1;
              } else failures += 1;
            }

            allStatusDiv.textContent =
              failures === 0
                ? `Bridge all complete. (${succeeded} ran, ${skipped} skipped)`
                : `Bridge all complete with ${failures} error(s). (${succeeded} ran, ${skipped} skipped)`;

            allBtn.disabled = false;
          };

          // ---- Brush strokes panel wiring ----
          const brushListEl = document.getElementById(`brush-list-${entry.id}`);
          await loadBrushStrokes(entry.id, brushListEl);

          const bsAllCb = document.getElementById(`brush-all-${entry.id}`);
          const bsSelectDiv = document.getElementById(`brush-bridge-select-${entry.id}`);
          const bsInput = document.getElementById(`brush-input-${entry.id}`);
          const bsBtn = document.getElementById(`brush-add-btn-${entry.id}`);
          const bsStatus = document.getElementById(`brush-status-${entry.id}`);

          // render bridge checkboxes
          const types = baseBridgeTypes();
          bsSelectDiv.innerHTML = types.map(t => `
            <label>
              <input type="checkbox" data-bridge-type="${t}" />
              ${t}
            </label>
          `).join("");

          function setCheckboxesEnabled(enabled) {
            bsSelectDiv.querySelectorAll('input[type="checkbox"]').forEach(cb => {
              cb.disabled = !enabled;
              if (!enabled) cb.checked = false;
            });
          }
          setCheckboxesEnabled(false);

          bsAllCb.addEventListener("change", () => {
            setCheckboxesEnabled(!bsAllCb.checked);
          });

          bsBtn.onclick = async () => {
            const entityText = (bsInput.value || "").trim();
            if (!entityText) {
              bsStatus.textContent = "Enter an entity / brush stroke text first.";
              return;
            }

            bsBtn.disabled = true;
            bsStatus.textContent = "Preparing brush strokes…";

            // get latest bridge ids
            const latestByType = await getLatestBridgeIdByType(entry.id);

            let selectedTypes;
            if (bsAllCb.checked) {
              selectedTypes = types;
            } else {
              selectedTypes = Array.from(bsSelectDiv.querySelectorAll('input[type="checkbox"]'))
                .filter(cb => cb.checked)
                .map(cb => cb.dataset.bridgeType);
            }

            const bridgeRows = selectedTypes
              .map(t => latestByType[t])
              .filter(Boolean);

            if (!bridgeRows.length) {
              bsStatus.textContent = "No selected bridges exist yet for this color.";
              bsBtn.disabled = false;
              return;
            }

            bsStatus.textContent =
              `Queueing brush strokes for ${bridgeRows.length} bridge(s)…`;

            // Fire everything at once; backend handles concurrency
            const jobs = bridgeRows.map(r => enqueueBrushStroke(r.id, entityText, bsStatus));
            const results = await Promise.all(jobs);

            const ok = results.filter(r => r.ok).length;
            const fail = results.length - ok;

            bsStatus.textContent =
              fail === 0
                ? `Brush strokes complete for ${ok} bridge(s).`
                : `Brush strokes complete: ${ok} ok, ${fail} failed.`;

            bsBtn.disabled = false;
          };
        }
      } catch (e) {
        document.getElementById('content').textContent = 'Error: ' + e;
      }
    }

    loadColor();
  </script>
</body>
</html>
