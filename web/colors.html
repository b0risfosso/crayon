<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Colors Viewer</title>
  <style>
    body { font-family: sans-serif; padding: 20px; }
    .block { border: 1px solid #ccc; padding: 12px; margin-bottom: 16px; border-radius: 8px; }
    pre { white-space: pre-wrap; }

    .controls { margin-top: 8px; display: flex; gap: 6px; flex-wrap: wrap; }
    button { padding: 6px 10px; cursor: pointer; }
    button:disabled { opacity: 0.5; cursor: not-allowed; }
    .status { font-size: 12px; color: #333; margin-top: 6px; white-space: pre-wrap; }

    /* Collapsible bridge sections */
    .bridge-group { margin-top: 10px; border: 1px solid #e0e0e0; border-radius: 6px; overflow: hidden; }
    .bridge-header {
      background: #f7f7f7;
      padding: 6px 8px;
      cursor: pointer;
      user-select: none;
      font-weight: 600;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
    }
    .bridge-header .meta { font-weight: 400; font-size: 12px; color: #555; }
    .bridge-content { padding: 8px; border-top: 1px solid #eee; }
    .bridge-content.collapsed { display: none; }
    .caret { font-size: 12px; color: #666; margin-left: 6px; }
  </style>
</head>
<body>
  <h1>Colors Viewer</h1>
  <div id="content">Loading...</div>

  <script>
    function escapeHtml(str) {
      if (str == null) return '';
      return String(str)
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#39;');
    }

    function getParam(name) {
      const params = new URLSearchParams(window.location.search);
      return params.get(name);
    }

    async function pollTask(taskId, statusDiv) {
      const maxMs = 120000;
      const intervalMs = 1200;
      const t0 = Date.now();

      while (true) {
        const res = await fetch(`/colors/tasks/${taskId}`);
        const data = await res.json();

        if (!res.ok) throw new Error(data.message || 'task poll failed');
        if (data.status === 'done') return data.result;
        if (data.status === 'error') throw new Error(data.error || 'task error');

        const elapsed = Date.now() - t0;
        statusDiv.textContent = `Task ${taskId}: ${data.status}… (${Math.floor(elapsed/1000)}s)`;
        if (elapsed > maxMs) throw new Error('task timed out');
        await new Promise(r => setTimeout(r, intervalMs));
      }
    }

    async function fetchBridgeOfType(colorId, bridgeType) {
      const res = await fetch(`/colors/bridges/by_color/${colorId}/${bridgeType}`);
      if (!res.ok) return null;
      const rows = await res.json();
      if (!Array.isArray(rows) || rows.length === 0) return null;
      return rows[0].bridge_text || null;
    }

    function renderBridge(contentDiv, text) {
      contentDiv.innerHTML = '';
      if (!text) {
        contentDiv.innerHTML = '<em>No bridge yet.</em>';
        return;
      }
      const pre = document.createElement('pre');
      pre.textContent = text;
      contentDiv.appendChild(pre);
    }

    function wireCollapse(headerEl, contentEl) {
      headerEl.addEventListener('click', () => {
        const collapsed = contentEl.classList.toggle('collapsed');
        const caret = headerEl.querySelector('.caret');
        if (caret) caret.textContent = collapsed ? '▶' : '▼';
      });
    }

    async function enqueueBridge(colorId, bridgeType, endpoint, statusDiv, contentDiv, headerMetaEl, buttonEl) {
      statusDiv.textContent = `Queued ${bridgeType}…`;
      buttonEl.disabled = true;

      const res = await fetch(endpoint, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ color_id: colorId })
      });

      const data = await res.json();
      if (!res.ok) {
        statusDiv.textContent = data.message || `Error queueing ${bridgeType}.`;
        buttonEl.disabled = false;
        return;
      }

      const taskId = data.task_id;
      statusDiv.textContent = `${bridgeType} queued (task ${taskId}). Waiting…`;

      try {
        const result = await pollTask(taskId, statusDiv);
        const text = result.bridge_text || result.architecture_text || result.theory_text || '';
        renderBridge(contentDiv, text);
        contentDiv.classList.remove('collapsed');
        const caret = contentDiv.parentElement.querySelector('.caret');
        if (caret) caret.textContent = '▼';
        const savedId = result.saved_bridge?.id;
        headerMetaEl.textContent = savedId ? `latest #${savedId}` : 'latest';
        statusDiv.textContent = `${bridgeType} done.`;
      } catch (e) {
        statusDiv.textContent = `${bridgeType} error: ${e.message || e}`;
      } finally {
        buttonEl.disabled = false;
      }
    }

    async function loadColor() {
      const artId = getParam('art_id');
      if (!artId) {
        document.getElementById('content').textContent = 'Missing art_id parameter.';
        return;
      }

      try {
        const res = await fetch(`/colors/by_art/${artId}`);
        const data = await res.json();
        const container = document.getElementById('content');
        container.innerHTML = '';

        if (!Array.isArray(data) || data.length === 0) {
          container.textContent = 'No colors expansions found for this art.';
          return;
        }

        for (const entry of data) {
          const div = document.createElement('div');
          div.className = 'block';

          const statusDivId = `status-${entry.id}`;
          const simContentId = `sim-content-${entry.id}`;
          const theoryContentId = `theory-content-${entry.id}`;
          const physContentId = `phys-content-${entry.id}`;

          div.innerHTML = `
            <strong>Color ID:</strong> ${entry.id}<br>
            <strong>Art ID:</strong> ${entry.art_id}<br>
            <strong>Model:</strong> ${escapeHtml(entry.model)}<br>
            <strong>Temperature:</strong> ${entry.temperature}<br>
            <strong>Created:</strong> ${entry.created_at}<br>
            <pre>${escapeHtml(entry.output_text)}</pre>

            <div class="controls">
              <button id="gen-sim-btn-${entry.id}">Simulation Architecture</button>
              <button id="gen-theory-btn-${entry.id}">Theory Architecture</button>
              <button id="gen-phys-btn-${entry.id}">Physical World Bridge</button>
            </div>
            <div id="${statusDivId}" class="status"></div>

            <div class="bridge-group">
              <div class="bridge-header" id="sim-header-${entry.id}">
                <div>Simulation Architecture</div>
                <div class="meta">
                  <span id="sim-meta-${entry.id}">latest</span>
                  <span class="caret">▶</span>
                </div>
              </div>
              <div class="bridge-content collapsed" id="${simContentId}"></div>
            </div>

            <div class="bridge-group">
              <div class="bridge-header" id="theory-header-${entry.id}">
                <div>Theory Architecture</div>
                <div class="meta">
                  <span id="theory-meta-${entry.id}">latest</span>
                  <span class="caret">▶</span>
                </div>
              </div>
              <div class="bridge-content collapsed" id="${theoryContentId}"></div>
            </div>

            <div class="bridge-group">
              <div class="bridge-header" id="phys-header-${entry.id}">
                <div>Physical World Bridge</div>
                <div class="meta">
                  <span id="phys-meta-${entry.id}">latest</span>
                  <span class="caret">▶</span>
                </div>
              </div>
              <div class="bridge-content collapsed" id="${physContentId}"></div>
            </div>
          `;

          container.appendChild(div);

          const statusDiv = document.getElementById(statusDivId);

          const simContentDiv = document.getElementById(simContentId);
          const theoryContentDiv = document.getElementById(theoryContentId);
          const physContentDiv = document.getElementById(physContentId);

          const simMeta = document.getElementById(`sim-meta-${entry.id}`);
          const theoryMeta = document.getElementById(`theory-meta-${entry.id}`);
          const physMeta = document.getElementById(`phys-meta-${entry.id}`);

          wireCollapse(document.getElementById(`sim-header-${entry.id}`), simContentDiv);
          wireCollapse(document.getElementById(`theory-header-${entry.id}`), theoryContentDiv);
          wireCollapse(document.getElementById(`phys-header-${entry.id}`), physContentDiv);

          // Load existing bridges by type
          const simText = await fetchBridgeOfType(entry.id, "simulation_architecture");
          renderBridge(simContentDiv, simText);

          const theoryText = await fetchBridgeOfType(entry.id, "theory_architecture");
          renderBridge(theoryContentDiv, theoryText);

          const physText = await fetchBridgeOfType(entry.id, "physical_world_bridge");
          renderBridge(physContentDiv, physText);

          // Wire buttons
          const simBtn = document.getElementById(`gen-sim-btn-${entry.id}`);
          simBtn.onclick = () =>
            enqueueBridge(entry.id, "simulation_architecture", "/colors/simulation_architecture",
              statusDiv, simContentDiv, simMeta, simBtn);

          const theoryBtn = document.getElementById(`gen-theory-btn-${entry.id}`);
          theoryBtn.onclick = () =>
            enqueueBridge(entry.id, "theory_architecture", "/colors/theory_architecture",
              statusDiv, theoryContentDiv, theoryMeta, theoryBtn);

          const physBtn = document.getElementById(`gen-phys-btn-${entry.id}`);
          physBtn.onclick = () =>
            enqueueBridge(entry.id, "physical_world_bridge", "/colors/physical_world_bridge",
              statusDiv, physContentDiv, physMeta, physBtn);
        }

      } catch (e) {
        document.getElementById('content').textContent = 'Error: ' + e;
      }
    }

    loadColor();
  </script>
</body>
</html>
