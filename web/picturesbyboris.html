<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Fantasiagenesis ¬∑ Pictures (Boris)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root { color-scheme: light; }
    * { box-sizing: border-box; }
    body { font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial; margin: 20px; }
    header h1 { margin: 0 0 .3rem 0; font-size: clamp(1.2rem, 2.4vw, 1.6rem); }
    .muted { opacity: .85; }
    .row { display:flex; gap:.5rem; align-items:center; flex-wrap:wrap; }
    .panel { border:1px solid #e5e7eb; border-radius:.6rem; padding:.85rem 1rem; background:#fafafb; }
    .panel + .panel { margin-top:.9rem; }
    input[type="email"], input[type="text"] { height:2.4rem; padding:.55rem .7rem; border:1px solid #cdd0d5; border-radius:.55rem; }
    button { padding:.6rem .9rem; border:0; border-radius:.55rem; background:#0b5cff; color:#fff; cursor:pointer; }
    button.secondary { background:#4b5563; }
    .status { font-size:.92rem; min-height:1.2em; margin-top:.35rem; }
    .status.error { color:#b00020; white-space:pre-wrap; }
    .status.ok { color:#065f46; }
    .vlist { display:grid; gap:.85rem; }
    .vision { border:1px solid #e5e7eb; border-radius:.6rem; background:#fff; padding:.75rem .85rem; }
    .vision h2 { margin:.1rem 0 .2rem 0; font-size:1.05rem; }
    .meta { font-size:.85rem; opacity:.9; }
    .chips { display:flex; gap:.4rem; flex-wrap:wrap; margin:.45rem 0 .3rem 0; }
    .chip { border:1px solid #d1d5db; border-radius:.45rem; padding:.15rem .45rem; background:#f9fafb; font-size:.85rem; }
    .pics { display:grid; gap:.55rem; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); margin-top:.5rem; }
    .pic { border:1px solid #e5e7eb; border-radius:.6rem; background:#fdfdfd; padding:.6rem .7rem; }
    .pic h3 { margin:.05rem 0 .25rem 0; font-size:1rem; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }
    .sep { height:1px; background:#eee; margin:.6rem 0; }
    .empty { padding:.4rem 0; color:#6b7280; }
    .hidden { display:none !important; }
    button.view { background: #059669; }       /* green */
    .note { font-size:.9rem; color:#6b7280; margin-top:.6rem; }
  </style>
</head>
<body>
  <header class="row" style="justify-content: space-between;">
    <div>
      <h1>Pictures (Boris)</h1>
      <div class="muted">Auto-loaded for <code class="mono">boris@fantasiagenesis.com</code></div>
    </div>
    <nav class="row">
      <a href="/draw" class="muted">‚úèÔ∏è Draw</a>
      <a href="/jid" class="muted">üß© JID</a>
    </nav>
  </header>

  <!-- Hidden email row (prefilled & disabled) -->
  <section class="panel hidden" id="emailPanel">
    <div class="row">
      <input type="email" id="email" placeholder="you@example.com" />
      <button id="loadBtn" type="button">Load</button>
      <button id="saveBtn" class="secondary" type="button">Save email</button>
    </div>
    <div id="status" class="status"></div>
  </section>

  <section id="results" class="panel" style="display:none;">
    <div id="summary" class="muted" style="margin-bottom:.5rem;"></div>
    <div id="visions" class="vlist"></div>
  </section>

  <script>
    // Hard-coded Boris email
    const BORIS_EMAIL = 'boris@fantasiagenesis.com';

    // Endpoints
    const EP = { byEmail: '/jid/by_email' };
    const EP_CRAYON = { listArchitectures: '/crayon/architectures' };

    // ---------- Shared JSON helpers ----------
    async function fetchWithTimeout(url, options={}, timeoutMs=300000){
      const controller = new AbortController();
      const timer = setTimeout(()=> controller.abort(), timeoutMs);
      try {
        return await fetch(url, { ...options, signal: controller.signal });
      } finally {
        clearTimeout(timer);
      }
    }
    async function fetchJSON(url, options={}, timeoutMs=600000){
      const ctrl = new AbortController(); const t = setTimeout(()=>ctrl.abort(), timeoutMs);
      try {
        const r = await fetch(url, { ...options, signal: ctrl.signal });
        const ct = r.headers.get('content-type')||'';
        const data = ct.includes('application/json') ? await r.json() : await r.text();
        if (!r.ok) throw new Error((data && (data.error||data.detail)) || `HTTP ${r.status}`);
        return data;
      } finally { clearTimeout(t); }
    }

    // ----- Minimal utilities for the page -----
    const $ = (id) => document.getElementById(id);
    function setStatus(msg, level='') {
      const el = document.querySelector('#emailPanel #status') || $('status');
      if (!el) return;
      el.className = 'status ' + (level || '');
      el.textContent = msg || '';
    }
    function escapeHtml(s) {
      return String(s ?? '').replaceAll('&','&amp;').replaceAll('<','&lt;')
                            .replaceAll('>','&gt;').replaceAll('"','&quot;')
                            .replaceAll("'",'&#39;');
    }

    // ------------------------------------------
    // Architecture endpoints helpers (READ ONLY)
    // ------------------------------------------
    async function getArchitecturesForPicture(pictureId, {collection=null, includeBody=false} = {}){
      const params = new URLSearchParams();
      if (pictureId) params.set('picture_id', pictureId);
      if (collection) params.set('collection', collection);
      if (includeBody) params.set('include_body', '1');
      const url = `${EP_CRAYON.listArchitectures}?${params.toString()}`;
      const res = await fetch(url);
      if (!res.ok) return {items:[], count:0};
      return await res.json();
    }

    // Open ONE new tab that displays multiple architectures for a single picture
    function openArchitecturesInNewTab({ pictureTitle, items }){
      const viewerUrl = '/architecture_viewer.html'; // adjust path if needed
      const w = window.open(viewerUrl, '_blank');
      if (!w) { alert('Popup blocked: allow popups to view architectures.'); return; }
      const payload = { kind: 'architectures-batch', pictureTitle, items };
      const send = () => { try { w.postMessage(payload, window.location.origin); } catch(_) {} };
      setTimeout(send, 80);
      setTimeout(send, 300);
      setTimeout(send, 800);
    }

    async function viewExistingArchitectures(pic, {collection=null} = {}){
      const {items} = await getArchitecturesForPicture(pic?.id, {collection, includeBody:true});
      if (!items?.length) { alert('No saved architectures for this picture.'); return; }

      // Normalize viewer items for the batch page
      const viewerItems = items.map(it => ({
        key: it.prompt_key || 'architecture',
        title: `${(it.collection||'').toUpperCase()} ¬∑ ${(it.prompt_key||'').toUpperCase()}`,
        subtitle: (pic?.title || `Picture #${pic?.id||''}`),
        body: String(it.output_text||'').trim(),
        meta: {
          collection: it.collection || '',
          created_at: it.created_at || '',
          model: it.model || ''
        }
      }));

      openArchitecturesInNewTab({ pictureTitle: pic?.title || `Picture #${pic?.id||''}`, items: viewerItems });
    }

    // ------------------------------------------
    // Render (READ ONLY UI)
    // ------------------------------------------
    async function render(data){
      const visions = Array.isArray(data?.visions) ? data.visions : [];
      $('results').style.display = 'block';
      $('summary').textContent = `${visions.length} vision${visions.length===1?'':'s'} for ${data?.email || ''}`;

      const mount = $('visions');
      mount.innerHTML = '';

      if (!visions.length){
        const empty = document.createElement('div');
        empty.className = 'empty';
        empty.textContent = 'No data for this email yet.';
        mount.append(empty);
        return;
      }

      for (const v of visions){
        const box = document.createElement('div'); box.className = 'vision';

        const title = document.createElement('h2');
        title.textContent = v.text || '(Untitled vision)';
        box.append(title);

        const meta = document.createElement('div'); meta.className = 'meta mono';
        meta.textContent = `id:${v.id} ¬∑ status:${v.status || '‚Äî'} ¬∑ updated:${v.updated_at || v.created_at || '‚Äî'}`;
        box.append(meta);

        // focuses chips (if any)
        const f = Array.isArray(v.focuses) ? v.focuses : [];
        if (f.length){
          const chips = document.createElement('div'); chips.className = 'chips';
          for (const it of f){
            const dim = (it && (it.dimension || it.title || it.name)) || 'Focus';
            const chip = document.createElement('div'); chip.className = 'chip';
            chip.innerHTML = `<strong>${escapeHtml(dim)}</strong>`;
            chips.append(chip);
          }
          box.append(chips);
        }

        const sep = document.createElement('div');
        sep.className = 'sep';
        box.append(sep);

        // pictures grid
        const pics = Array.isArray(v.pictures) ? v.pictures : [];
        if (!pics.length){
          const empty = document.createElement('div'); empty.className = 'empty';
          empty.textContent = 'No pictures for this vision yet.';
          box.append(empty);
          mount.append(box);
          continue;
        }

        const grid = document.createElement('div'); grid.className = 'pics';

        // Check for architectures per picture (READ ONLY)
        const existenceChecks = await Promise.all(pics.map(async (p) => {
          const pid = p?.id;
          if (pid == null) return { id: null, count: 0 };
          try {
            const { count } = await getArchitecturesForPicture(pid, { collection: null, includeBody: false });
            return { id: pid, count: Number(count) || 0 };
          } catch {
            return { id: pid, count: 0 };
          }
        }));
        const archCountByPic = Object.fromEntries(existenceChecks.map(x => [String(x.id), x.count]));

        for (const p of pics){
          const card = document.createElement('div'); card.className = 'pic';

          const h3 = document.createElement('h3'); h3.textContent = p?.title || 'Untitled picture';
          const d  = document.createElement('div'); d.className = 'muted'; d.textContent = p?.description || '';
          const fn = document.createElement('div'); fn.style.marginTop = '.35rem';
          if (p?.function) fn.innerHTML = `<strong>Function:</strong> ${escapeHtml(p.function)}`;
          const pm = document.createElement('div'); pm.className = 'meta mono';
          pm.textContent = `id:${p?.id ?? '‚Äî'} ¬∑ status:${p?.status || '‚Äî'} ¬∑ updated:${p?.updated_at || p?.created_at || '‚Äî'}`;

          const existingCount = p?.id != null ? (archCountByPic[String(p.id)] || 0) : 0;

          if (existingCount > 0){
            // GREEN: view existing architectures (one tab with all)
            const viewBtn = document.createElement('button');
            viewBtn.type = 'button';
            viewBtn.style.marginTop = '.5rem';
            viewBtn.textContent = 'view architectures';
            viewBtn.className = 'view';
            viewBtn.addEventListener('click', async () => {
              await viewExistingArchitectures(p, { collection: null });
            });

            card.append(h3, d);
            if (p?.function) card.append(fn);
            card.append(pm, viewBtn);
          } else {
            // read-only: show a muted note (no run/create actions here)
            const note = document.createElement('div');
            note.className = 'note';
            note.textContent = 'no architectures yet';
            card.append(h3, d);
            if (p?.function) card.append(fn);
            card.append(pm, note);
          }

          grid.append(card);
        }

        box.append(grid);
        mount.append(box);
      }
    }

    async function loadForBoris(){
      setStatus('Loading‚Ä¶');
      try{
        const data = await fetchJSON(`${EP.byEmail}?email=${encodeURIComponent(BORIS_EMAIL)}`, {}, 120000);
        await render(data);
        setStatus('Done.', 'ok');
      }catch(e){
        setStatus(`Failed: ${e.message || e}`, 'error');
      }
    }

    (function init(){
      // Prefill (and keep hidden) input with Boris' email, then autoload.
      const emailInput = document.getElementById('email');
      if (emailInput) {
        emailInput.value = BORIS_EMAIL;
        emailInput.setAttribute('disabled', 'disabled');
      }
      document.getElementById('emailPanel')?.classList.add('hidden');

      // Autoload immediately
      loadForBoris();
    })();
  </script>
</body>
</html>
