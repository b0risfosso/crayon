<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Fantasiagenesis ¬∑ Pictures (Boris)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root { color-scheme: light; }
    * { box-sizing: border-box; }
    body { font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial; margin: 20px; }
    header h1 { margin: 0 0 .3rem 0; font-size: clamp(1.2rem, 2.4vw, 1.6rem); }
    .muted { opacity: .85; }
    .row { display:flex; gap:.5rem; align-items:center; flex-wrap:wrap; }
    .panel { border:1px solid #e5e7eb; border-radius:.6rem; padding:.85rem 1rem; background:#fafafb; }
    .panel + .panel { margin-top:.9rem; }
    input[type="email"], input[type="text"] { height:2.4rem; padding:.55rem .7rem; border:1px solid #cdd0d5; border-radius:.55rem; }
    button { padding:.6rem .9rem; border:0; border-radius:.55rem; background:#0b5cff; color:#fff; cursor:pointer; }
    button.secondary { background:#4b5563; }
    .status { font-size:.92rem; min-height:1.2em; margin-top:.35rem; }
    .status.error { color:#b00020; white-space:pre-wrap; }
    .status.ok { color:#065f46; }
    .vlist { display:grid; gap:.85rem; }
    .vision { border:1px solid #e5e7eb; border-radius:.6rem; background:#fff; padding:.75rem .85rem; }
    .vision h2 { margin:.1rem 0 .2rem 0; font-size:1.05rem; }
    .meta { font-size:.85rem; opacity:.9; }
    .chips { display:flex; gap:.4rem; flex-wrap:wrap; margin:.45rem 0 .3rem 0; }
    .chip { border:1px solid #d1d5db; border-radius:.45rem; padding:.15rem .45rem; background:#f9fafb; font-size:.85rem; }
    .pics { display:grid; gap:.55rem; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); margin-top:.5rem; }
    .pic { border:1px solid #e5e7eb; border-radius:.6rem; background:#fdfdfd; padding:.6rem .7rem; }
    .pic h3 { margin:.05rem 0 .25rem 0; font-size:1rem; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }
    .sep { height:1px; background:#eee; margin:.6rem 0; }
    .empty { padding:.4rem 0; color:#6b7280; }
    .hidden { display:none !important; }
    button.view { background: #059669; }       /* green */
    button.create { background: #0b5cff; }     /* blue */

  </style>
</head>
<body>
  <header class="row" style="justify-content: space-between;">
    <div>
      <h1>Pictures (Boris)</h1>
      <div class="muted">Auto-loaded for <code class="mono">boris@fantasiagenesis.com</code></div>
    </div>
    <nav class="row">
      <a href="/draw" class="muted">‚úèÔ∏è Draw</a>
      <a href="/jid" class="muted">üß© JID</a>
    </nav>
  </header>

  <!-- Hidden email row (prefilled & disabled) -->
  <section class="panel hidden" id="emailPanel">
    <div class="row">
      <input type="email" id="email" placeholder="you@example.com" />
      <button id="loadBtn" type="button">Load</button>
      <button id="saveBtn" class="secondary" type="button">Save email</button>
    </div>
    <div id="status" class="status"></div>
  </section>

  <!-- Optional build context (constraints/deploy/readiness); keep visible in case you want to set them -->
  <section class="panel" id="ctxPanel">
    <div class="row" style="gap:.6rem; flex-wrap:wrap;">
      <input id="ctxConstraints" type="text" placeholder="Constraints (optional)" style="width:min(92vw,460px)">
      <input id="ctxDeploy" type="text" placeholder="Deployment context (optional)" style="width:min(92vw,360px)">
      <input id="ctxReadiness" type="text" placeholder="Readiness target (optional)" style="width:min(92vw,280px)">
    </div>
    <div id="status" class="status"></div>
  </section>

  <section id="results" class="panel" style="display:none;">
    <div id="summary" class="muted" style="margin-bottom:.5rem;"></div>
    <div id="visions" class="vlist"></div>
  </section>

  <script>
    // Hard-coded Boris email
    const BORIS_EMAIL = 'boris@fantasiagenesis.com';

    const EP = { byEmail: '/jid/by_email' }; // alias exists at /by_email too

    // ---- Crayon endpoints
    const EP_CRAYON = {
      waxStack: '/crayon/wax_stack',
      world: '/crayon/wax_worldwright'
    };

    // ---------- Shared JSON helpers ----------
    async function fetchWithTimeout(url, options={}, timeoutMs=300000){
      const controller = new AbortController();
      const timer = setTimeout(()=> controller.abort(), timeoutMs);
      try {
        return await fetch(url, { ...options, signal: controller.signal });
      } finally {
        clearTimeout(timer);
      }
    }

    async function postJSON(url, body, timeoutMs=600000){
      const resp = await fetchWithTimeout(url, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(body)
      }, timeoutMs);
      let data;
      try {
        data = await resp.json();
      } catch {
        throw new Error(`Non-JSON response from ${url} (status ${resp.status})`);
      }
      if (!resp.ok || data?.ok === false) {
        const msg = (data && (data.error || data.detail)) ?
          `${data.error || ''} ${data.detail || ''}`.trim() :
          `HTTP ${resp.status}`;
        throw new Error(msg);
      }
      return data;
    }

    // Batch check which pictures already have worlds
    async function lookupExistingWorldsByPictureIds(ids){
      if (!Array.isArray(ids) || !ids.length) return {};
      const res = await postJSON('/crayon/worlds/lookup', { picture_ids: ids }, 60000);
      // returns { worlds: { "<picId>": { id, picture_id, updated_at }, ... } }
      return res?.worlds || {};
    }

    async function fetchWorldHtml(worldId){
      const r = await fetch(`/crayon/world/html?id=${encodeURIComponent(worldId)}`);
      if (!r.ok) throw new Error(`HTTP ${r.status}`);
      const j = await r.json();
      return j?.html || '';
    }

    // Normalize various possible response shapes
    function pickWaxStack(res){
      if (!res) return '';
      if (typeof res.wax_stack === 'string') return res.wax_stack;
      if (res.data && typeof res.data.wax_stack === 'string') return res.data.wax_stack;
      if (res.result && typeof res.result.wax_stack === 'string') return res.result.wax_stack;
      if (typeof res.wax === 'string') return res.wax;
      return '';
    }

    function openHtmlInNewTab(html){
      const w = window.open('', '_blank');
      if (!w) { alert('Popup blocked: allow popups to see the world.'); return; }
      w.document.open();
      w.document.write(html || '<!doctype html><title>World</title><pre>No HTML</pre>');
      w.document.close();
    }

    async function createWorldForPictureCard(cardNode, visionText, pic){
      // Always use Boris' email for this page
      const email = BORIS_EMAIL;
      const constraints = (document.getElementById('ctxConstraints')?.value || '').trim();
      const deployment_context = (document.getElementById('ctxDeploy')?.value || '').trim();
      const readiness_target = (document.getElementById('ctxReadiness')?.value || '').trim();

      const status = document.createElement('div');
      status.className = 'status';
      status.textContent = 'Building wax‚Ä¶';
      cardNode.append(status);

      try {
        // 1) Wax stack
        const wsPayload = {
          vision: visionText,
          picture_short: pic.title || '',
          picture_description: pic.description || '',
          constraints, deployment_context, readiness_target
        };
        const wsRes = await postJSON(EP_CRAYON.waxStack, wsPayload, 600000);
        const wax_stack = pickWaxStack(wsRes);
        if (!wax_stack) throw new Error('No wax_stack returned.');

        status.textContent = 'Wax ready. Building world‚Ä¶';

        // 2) Worldwright
        const wwPayload = {
          vision: visionText,
          picture_short: pic.title || '',
          picture_description: pic.description || '',
          wax_stack,
          email, // hard-coded
          constraints, deployment_context, readiness_target
        };
        const worldRes = await postJSON(EP_CRAYON.world, wwPayload, 600000);
        const html = worldRes?.html || worldRes?.data?.html || worldRes?.result?.html;
        if (!html) throw new Error('No world HTML returned.');

        status.className = 'status ok';
        status.textContent = 'World built. Opening‚Ä¶';
        openHtmlInNewTab(html);
      } catch (e) {
        status.className = 'status error';
        status.textContent = `Failed: ${e.message || e}`;
      }
    }

    // ----- Minimal utilities for the page -----
    const $ = (id) => document.getElementById(id);
    function setStatus(msg, level='') {
      const el = document.querySelector('#ctxPanel #status') || $('status');
      if (!el) return;
      el.className = 'status ' + (level || '');
      el.textContent = msg || '';
    }
    function escapeHtml(s) {
      return String(s ?? '').replaceAll('&','&amp;').replaceAll('<','&lt;')
                            .replaceAll('>','&gt;').replaceAll('"','&quot;')
                            .replaceAll("'",'&#39;');
    }
    async function fetchJSON(url, options={}, timeoutMs=60000){
      const ctrl = new AbortController(); const t = setTimeout(()=>ctrl.abort(), timeoutMs);
      try {
        const r = await fetch(url, { ...options, signal: ctrl.signal });
        const ct = r.headers.get('content-type')||'';
        const data = ct.includes('application/json') ? await r.json() : await r.text();
        if (!r.ok) throw new Error((data && (data.error||data.detail)) || `HTTP ${r.status}`);
        return data;
      } finally { clearTimeout(t); }
    }

    function render(data){
      const visions = Array.isArray(data?.visions) ? data.visions : [];
      $('results').style.display = 'block';
      $('summary').textContent = `${visions.length} vision${visions.length===1?'':'s'} for ${data?.email || ''}`;

      const mount = $('visions');
      mount.innerHTML = '';

      if (!visions.length){
        const empty = document.createElement('div');
        empty.className = 'empty';
        empty.textContent = 'No data for this email yet.';
        mount.append(empty);
        return;
      }

      for (const v of visions){
        const box = document.createElement('div'); box.className = 'vision';

        const title = document.createElement('h2');
        title.textContent = v.text || '(Untitled vision)';
        box.append(title);

        const meta = document.createElement('div'); meta.className = 'meta mono';
        meta.textContent = `id:${v.id} ¬∑ status:${v.status || '‚Äî'} ¬∑ updated:${v.updated_at || v.created_at || '‚Äî'}`;
        box.append(meta);

        // focuses chips (if any)
        const f = Array.isArray(v.focuses) ? v.focuses : [];
        if (f.length){
          const chips = document.createElement('div'); chips.className = 'chips';
          for (const it of f){
            const dim = (it && (it.dimension || it.title || it.name)) || 'Focus';
            const chip = document.createElement('div'); chip.className = 'chip';
            chip.innerHTML = `<strong>${escapeHtml(dim)}</strong>`;
            chips.append(chip);
          }
          box.append(chips);
        }

        const sep = document.createElement('div');
        sep.className = 'sep';
        box.append(sep);

        // pictures grid
        // pictures grid
const pics = Array.isArray(v.pictures) ? v.pictures : [];
if (!pics.length){
  const empty = document.createElement('div'); empty.className = 'empty';
  empty.textContent = 'No pictures for this vision yet.';
  box.append(empty);
} else {
  const grid = document.createElement('div'); grid.className = 'pics';

  // --- NEW: batch-lookup worlds for these pic ids
  const picIds = pics.map(p => p?.id).filter(x => x != null);
  let worldMap = {};
  try {
    worldMap = await lookupExistingWorldsByPictureIds(picIds);
  } catch(e) {
    // non-fatal; just leave as empty map
    console.warn('world lookup failed', e);
  }

  for (const p of pics){
    const card = document.createElement('div'); card.className = 'pic';
    const h3 = document.createElement('h3'); h3.textContent = p?.title || 'Untitled picture';
    const d  = document.createElement('div'); d.className = 'muted'; d.textContent = p?.description || '';
    const fn = document.createElement('div'); fn.style.marginTop = '.35rem';
    if (p?.function) fn.innerHTML = `<strong>Function:</strong> ${escapeHtml(p.function)}`;
    const pm = document.createElement('div'); pm.className = 'meta mono';
    pm.textContent = `id:${p?.id ?? '‚Äî'} ¬∑ status:${p?.status || '‚Äî'} ¬∑ updated:${p?.updated_at || p?.created_at || '‚Äî'}`;

    const btn = document.createElement('button');
    btn.type = 'button';
    btn.style.marginTop = '.5rem';

    const existing = p?.id != null ? worldMap[String(p.id)] : null;
    if (existing?.id) {
      // ---- VIEW MODE (green)
      btn.textContent = 'view picture';
      btn.className = 'view';
      btn.addEventListener('click', async () => {
        try {
          const html = await fetchWorldHtml(existing.id);
          openHtmlInNewTab(html);
        } catch(e) {
          alert(`Failed to load world: ${e.message || e}`);
        }
      });
    } else {
      // ---- CREATE MODE (blue)
      btn.textContent = 'create picture';
      btn.className = 'create';
      btn.addEventListener('click', async () => {
        const visionText = v?.text || '';
        if (!visionText) { alert('This vision has no text.'); return; }
        await createWorldForPictureCard(card, visionText, p);
        // Optional: after creating, try upgrading the button to "view"
        try {
          const m = await lookupExistingWorldsByPictureIds([p.id]);
          const w = m && m[String(p.id)];
          if (w?.id) {
            btn.textContent = 'view picture';
            btn.className = 'view';
            btn.replaceWith(btn.cloneNode(true)); // remove old handler
            const newBtn = card.querySelector('button.view');
            newBtn?.addEventListener('click', async () => {
              try {
                const html = await fetchWorldHtml(w.id);
                openHtmlInNewTab(html);
              } catch(e) { alert(`Failed to load world: ${e.message || e}`); }
            });
          }
        } catch(_) {}
      });
    }

    card.append(h3, d);
    if (p?.function) card.append(fn);
    card.append(pm, btn);
    grid.append(card);
  }
  box.append(grid);
}


        mount.append(box);
      }
    }

    async function loadForBoris(){
      setStatus('Loading‚Ä¶');
      try{
        const data = await fetchJSON(`${EP.byEmail}?email=${encodeURIComponent(BORIS_EMAIL)}`, {}, 120000);
        render(data);
        setStatus('Done.', 'ok');
      }catch(e){
        setStatus(`Failed: ${e.message || e}`, 'error');
      }
    }

    (function init(){
      // Prefill (and keep hidden) input with Boris' email, then autoload.
      const emailInput = document.getElementById('email');
      if (emailInput) {
        emailInput.value = BORIS_EMAIL;
        emailInput.setAttribute('disabled', 'disabled');
      }
      document.getElementById('emailPanel')?.classList.add('hidden');

      // Autoload immediately
      loadForBoris();
    })();
  </script>
</body>
</html>
