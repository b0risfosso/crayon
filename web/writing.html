<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Writing</title>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; margin: 2rem; line-height: 1.5; }
    main { max-width: 60rem; margin: 0 auto; }
    nav a { margin-right: 1rem; text-decoration: none; }
    h1 { font-size: 1.5rem; margin: 1rem 0 0.5rem; }
    .desc { white-space: pre-wrap; margin-bottom: 1rem; }
    textarea { width: 100%; box-sizing: border-box; padding: 0.5rem; font: inherit; min-height: 4rem; }
    input[type="text"], select { width: 100%; box-sizing: border-box; padding: 0.5rem; font: inherit; }
    button { margin-top: 0.5rem; padding: 0.45rem 0.8rem; font: inherit; }
    .note { border-top: 1px solid #ccc; padding: 0.75rem 0; }
    .muted { color: #555; font-size: 0.9rem; }
    .row { display: flex; gap: 0.5rem; align-items: center; }
    .list { border: 1px solid #ccc; padding: 0.5rem; max-height: 12rem; overflow: auto; }
    .list label { display: flex; gap: 0.5rem; align-items: flex-start; font-weight: 400; margin: 0.35rem 0; }
    .list label span { flex: 1; white-space: pre-wrap; overflow-wrap: anywhere; }
    .result { margin-top: 0.75rem; white-space: pre-wrap; }
    details { border-top: 1px solid #ccc; padding: 0.5rem 0; }
    summary { cursor: pointer; font-weight: 600; }
    .meta { font-size: 0.9rem; color: #555; margin-left: 1rem; }
    .ideas { margin-left: 1rem; }
    .idea { margin: 0.5rem 0; }
  </style>
</head>
<body>
  <main>
    <nav>
      <a href="/index.html">Home</a>
      <a href="/lang.html">Runs</a>
      <a href="/writings.html">Writings</a>
    </nav>

    <h1 id="idea-name">(untitled)</h1>
    <div id="idea-desc" class="desc"></div>
    <div id="meta" class="muted"></div>

    <section>
      <h2>Generate ideas</h2>
      <form id="write-form">
        <label for="text-a">Text A</label>
        <textarea id="text-a" name="text_a" readonly></textarea>

        <label>Text B (select one or more)</label>
        <div id="creations-list" class="list"></div>
        <div class="row">
          <input id="random-count" type="number" min="1" placeholder="N" />
          <button type="button" id="random-select">Select N random</button>
        </div>
        <button type="button" id="delete-creation">Remove Selected</button>

        <label for="new-creation">Add to creations</label>
        <div class="row">
          <input id="new-creation" type="text" placeholder="New text B" />
          <button type="button" id="add-creation">Add</button>
        </div>

        <button type="submit">write</button>
      </form>
      <div id="write-status" class="muted"></div>
      <div id="write-result" class="result"></div>
    </section>

    <section>
      <h2>Runs for this writing</h2>
      <div id="writing-runs"></div>
    </section>

    <section>
      <h2>Child writing</h2>
      <label for="new-note-name">Add Child Writing Name</label>
      <input id="new-note-name" type="text" />
      <label for="new-note-desc">Add Child Writing Description</label>
      <textarea id="new-note-desc"></textarea>
      <label for="note-type-select">Child Writing Type</label>
      <div class="row">
        <select id="note-type-select"></select>
        <input id="note-type-custom" type="text" placeholder="Or enter custom type" />
      </div>
      <button type="button" id="add-note">Add Child Writing</button>
      <div id="status" class="muted"></div>
      <div id="notes"></div>
    </section>
  </main>

  <script>
    const params = new URLSearchParams(window.location.search);
    const ideaNameParam = params.get('name') || '(untitled)';
    const ideaDescParam = params.get('description') || '';
    const runId = params.get('run_id') || '';
    const textA = params.get('text_a') || '';
    const textB = params.get('text_b') || '';
    const writingIdParam = params.get('writing_id');

    const statusEl = document.getElementById('status');
    const notesEl = document.getElementById('notes');
    const newNoteNameEl = document.getElementById('new-note-name');
    const newNoteDescEl = document.getElementById('new-note-desc');
    const addNoteBtn = document.getElementById('add-note');
    const noteTypeSelect = document.getElementById('note-type-select');
    const noteTypeCustomEl = document.getElementById('note-type-custom');
    const textAEl = document.getElementById('text-a');
    const form = document.getElementById('write-form');
    const writeStatusEl = document.getElementById('write-status');
    const writeResultEl = document.getElementById('write-result');
    const runsEl = document.getElementById('writing-runs');
    const creationsList = document.getElementById('creations-list');
    const newCreationEl = document.getElementById('new-creation');
    const addCreationBtn = document.getElementById('add-creation');
    const deleteCreationBtn = document.getElementById('delete-creation');
    const randomCountEl = document.getElementById('random-count');
    const randomSelectBtn = document.getElementById('random-select');

    let writingId = null;
    let currentName = ideaNameParam;
    let currentDesc = ideaDescParam;

    function composeTextA(name, description) {
      if (name && description) return `${name}\n\n${description}`;
      return name || description || '';
    }

    function splitNoteContent(content) {
      const text = (content || '').trim();
      if (!text) return { name: '', description: '' };
      const lines = text.split(/\r?\n/);
      const name = (lines.shift() || '').trim();
      const description = lines.join('\n').trim();
      return { name, description };
    }

    function updateHeading() {
      document.getElementById('idea-name').textContent = currentName || '(untitled)';
      document.getElementById('idea-desc').textContent = currentDesc || '';
      textAEl.value = composeTextA(currentName, currentDesc);
    }

    async function ensureWriting() {
      try {
        const lookup = await fetch(`/api/writings/lookup?run_id=${encodeURIComponent(runId)}&name=${encodeURIComponent(currentName)}&text_a=${encodeURIComponent(textA)}&text_b=${encodeURIComponent(textB)}`);
        if (lookup.ok) {
          const data = await lookup.json();
          writingId = data.id;
          currentName = data.name || currentName;
          currentDesc = data.description || currentDesc;
          updateHeading();
          return;
        }
      } catch (err) {
        statusEl.textContent = `Error: ${err.message}`;
        return;
      }

      try {
        const res = await fetch('/api/writings', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            name: currentName,
            description: currentDesc,
            parent_run_id: runId || null,
            parent_text_a: textA,
            parent_text_b: textB,
          }),
        });
        if (!res.ok) {
          const err = await res.json().catch(() => ({}));
          throw new Error(err.error || 'Failed to create writing');
        }
        const data = await res.json();
        writingId = data.id;
      } catch (err) {
        statusEl.textContent = `Error: ${err.message}`;
      }
    }

    function renderNotes(notes) {
      notesEl.textContent = '';
      if (!notes.length) {
        notesEl.textContent = 'No notes yet.';
        return;
      }
      notes.forEach((note) => {
        const container = document.createElement('div');
        container.className = 'note';

        const { name, description } = splitNoteContent(note.content);
        const nameInput = document.createElement('input');
        nameInput.type = 'text';
        nameInput.value = name;
        container.appendChild(nameInput);

        const textarea = document.createElement('textarea');
        textarea.value = description;
        container.appendChild(textarea);

        const buttonsRow = document.createElement('div');
        buttonsRow.className = 'row';

        const saveBtn = document.createElement('button');
        saveBtn.type = 'button';
        saveBtn.textContent = 'Save';
        saveBtn.addEventListener('click', async () => {
          try {
            const res = await fetch(`/api/notes/${note.id}`, {
              method: 'PATCH',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                name: nameInput.value.trim(),
                description: textarea.value.trim(),
              }),
            });
            if (!res.ok) {
              const err = await res.json().catch(() => ({}));
              throw new Error(err.error || 'Failed to update note');
            }
            statusEl.textContent = 'Note saved.';
          } catch (err) {
            statusEl.textContent = `Error: ${err.message}`;
          }
        });
        buttonsRow.appendChild(saveBtn);

        const deleteBtn = document.createElement('button');
        deleteBtn.type = 'button';
        deleteBtn.textContent = 'Delete';
        deleteBtn.addEventListener('click', async () => {
          try {
            const res = await fetch(`/api/notes/${note.id}`, { method: 'DELETE' });
            if (!res.ok) {
              const err = await res.json().catch(() => ({}));
              throw new Error(err.error || 'Failed to delete note');
            }
            await loadNotes();
          } catch (err) {
            statusEl.textContent = `Error: ${err.message}`;
          }
        });
        buttonsRow.appendChild(deleteBtn);

        // Open this note as its own writing
        if (note.child_writing_id) {
          const openBtn = document.createElement('button');
          openBtn.type = 'button';
          openBtn.textContent = 'Open writing';
          openBtn.addEventListener('click', () => {
            const url = `/writing.html?writing_id=${encodeURIComponent(note.child_writing_id)}`;
            window.open(url, '_blank');
          });
          buttonsRow.appendChild(openBtn);
        }

        container.appendChild(buttonsRow);
        notesEl.appendChild(container);
      });
    }

    async function loadNotes() {
      if (!writingId) return;
      try {
        const res = await fetch(`/api/writings/${writingId}/notes`);
        if (!res.ok) throw new Error('Failed to load notes');
        const data = await res.json();
        renderNotes(data);
      } catch (err) {
        statusEl.textContent = `Error: ${err.message}`;
      }
    }

    async function loadTypes() {
      try {
        const res = await fetch('/api/writing-types');
        if (!res.ok) throw new Error('Failed to load types');
        const data = await res.json();
        if (!Array.isArray(data)) return;

        // Clear and add placeholder
        noteTypeSelect.textContent = '';
        const placeholder = document.createElement('option');
        placeholder.value = '';
        placeholder.textContent = '(no type)';
        noteTypeSelect.appendChild(placeholder);

        data.forEach((type) => {
          if (!type) return;
          const option = document.createElement('option');
          option.value = type;
          option.textContent = type;
          noteTypeSelect.appendChild(option);
        });
      } catch (err) {
        // Fail softly; just log so the rest of the page still works
        console.error('Failed to load writing types', err);
      }
    }

    function renderIdeaSet(response, run) {
      const container = document.createElement('div');
      container.className = 'ideas';

      if (response && typeof response === 'object' && Array.isArray(response.ideas)) {
        response.ideas.forEach((idea) => {
          const ideaEl = document.createElement('div');
          ideaEl.className = 'idea';
          const link = document.createElement('a');
          const name = idea.name || '(untitled)';
          const descText = idea.desciription || '';
          link.textContent = name;

          if (idea.writing_id) {
            // New path: writing created at LLM time
            const params = new URLSearchParams({ writing_id: String(idea.writing_id) });
            link.href = `/writing.html?${params.toString()}`;
          } else {
            // Fallback for older runs that don't have writing_id
            const params = new URLSearchParams({
              run_id: String(run.id || ''),
              text_a: run.text_a || '',
              text_b: run.text_b || '',
              name,
              description: descText,
            });
            link.href = `/writing.html?${params.toString()}`;
          }

          const desc = document.createElement('div');
          desc.textContent = descText;
          ideaEl.appendChild(link);
          ideaEl.appendChild(desc);
          container.appendChild(ideaEl);
        });
      } else {
        const pre = document.createElement('pre');
        pre.textContent = typeof response === 'string' ? response : JSON.stringify(response, null, 2);
        container.appendChild(pre);
      }

      return container;
    }

    function renderRuns(runs) {
      runsEl.textContent = '';
      if (!runs.length) {
        runsEl.textContent = 'No runs yet.';
        return;
      }
      runs.forEach((run) => {
        const runDetails = document.createElement('details');
        const summary = document.createElement('summary');
        summary.textContent = run.text_b || '(no text B)';
        runDetails.appendChild(summary);

        const meta = document.createElement('div');
        meta.className = 'meta';
        meta.textContent = run.created_at ? `Created ${run.created_at}` : '';
        runDetails.appendChild(meta);

        runDetails.appendChild(renderIdeaSet(run.response, run));
        runsEl.appendChild(runDetails);
      });
    }

    async function loadRuns() {
      if (!writingId) return;
      runsEl.textContent = 'Loading...';
      try {
        const res = await fetch(`/api/lang?parent_writing_id=${encodeURIComponent(writingId)}`);
        if (!res.ok) throw new Error('Failed to load runs');
        const data = await res.json();
        runsEl.textContent = '';
        if (!data.length) {
          runsEl.textContent = 'No runs yet.';
          return;
        }
        renderRuns(data);
      } catch (err) {
        runsEl.textContent = `Error: ${err.message}`;
      }
    }

    async function loadCreations() {
      if (!writingId) return;
      try {
        const res = await fetch(`/api/creations?writing_id=${encodeURIComponent(writingId)}`);
        if (!res.ok) throw new Error('Failed to load creations');
        const data = await res.json();
        creationsList.textContent = '';
        if (!data.length) {
          creationsList.textContent = 'No creations yet.';
          return;
        }
        data.forEach((item) => {
          const label = document.createElement('label');
          const checkbox = document.createElement('input');
          checkbox.type = 'checkbox';
          checkbox.value = String(item.id);
          checkbox.dataset.textB = item.text_b;
          const span = document.createElement('span');
          span.textContent = item.text_b || '(empty)';
          label.appendChild(checkbox);
          label.appendChild(span);
          creationsList.appendChild(label);
        });
      } catch (err) {
        writeStatusEl.textContent = `Error: ${err.message}`;
      }
    }

    addNoteBtn.addEventListener('click', async () => {
      if (!writingId) return;
      const nameValue = newNoteNameEl.value.trim();
      const descValue = newNoteDescEl.value.trim();
      const selectedType = (noteTypeSelect.value || '').trim();
      const customType = (noteTypeCustomEl.value || '').trim();
      const typeValue = customType || selectedType;
      if (!nameValue && !descValue) return;
      try {
        const payload = { name: nameValue, description: descValue };
        if (typeValue) {
          payload.type = typeValue;
        }
        const res = await fetch(`/api/writings/${writingId}/notes`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload),
        });
        if (!res.ok) {
          const err = await res.json().catch(() => ({}));
          throw new Error(err.error || 'Failed to create note');
        }
        newNoteNameEl.value = '';
        newNoteDescEl.value = '';
        noteTypeSelect.value = '';
        noteTypeCustomEl.value = '';
        await loadNotes();
      } catch (err) {
        statusEl.textContent = `Error: ${err.message}`;
      }
    });

    form.addEventListener('submit', async (event) => {
      event.preventDefault();
      writeStatusEl.textContent = 'writing...';
      writeResultEl.textContent = '';

      if (!writingId) {
        writeStatusEl.textContent = 'Writing is not ready yet.';
        return;
      }

      const selected = Array.from(
        creationsList.querySelectorAll('input[type="checkbox"]:checked')
      );
      if (!selected.length) {
        writeStatusEl.textContent = 'Select at least one creation.';
        return;
      }

      const textAValue = textAEl.value.trim();
      if (!textAValue) {
        writeStatusEl.textContent = 'Text A is empty.';
        return;
      }

      try {
        const results = await Promise.all(
          selected.map(async (checkbox) => {
            const payload = {
              text_a: textAValue,
              text_b: checkbox.dataset.textB || '',
              parent_writing_id: writingId,
            };
            const res = await fetch('/api/lang', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify(payload),
            });
            if (!res.ok) {
              const err = await res.json().catch(() => ({}));
              throw new Error(err.error || 'Request failed');
            }
            return res.json();
          })
        );

        writeStatusEl.textContent = '';
        const queued = results
          .filter((item) => item && item.task_id)
          .map((item) => item.task_id);
        if (queued.length) {
          writeResultEl.textContent =
            `Queued tasks: ${queued.join(', ')}. Check /queue.html for status.`;
        } else {
          writeResultEl.textContent = '';
        }
      } catch (err) {
        writeStatusEl.textContent = `Error: ${err.message}`;
      }
    });

    addCreationBtn.addEventListener('click', async () => {
      if (!writingId) return;
      const value = newCreationEl.value.trim();
      if (!value) return;
      try {
        const res = await fetch('/api/creations', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ text_b: value, writing_id: writingId }),
        });
        if (!res.ok) {
          const err = await res.json().catch(() => ({}));
          throw new Error(err.error || 'Failed to add creation');
        }
        newCreationEl.value = '';
        await loadCreations();
      } catch (err) {
        writeStatusEl.textContent = `Error: ${err.message}`;
      }
    });

    deleteCreationBtn.addEventListener('click', async () => {
      const selected = Array.from(
        creationsList.querySelectorAll('input[type="checkbox"]:checked')
      );
      if (!selected.length) return;
      try {
        await Promise.all(
          selected.map(async (checkbox) => {
            const res = await fetch(`/api/creations/${checkbox.value}`, {
              method: 'DELETE',
            });
            if (!res.ok) {
              const err = await res.json().catch(() => ({}));
              throw new Error(err.error || 'Failed to delete creation');
            }
          })
        );
        await loadCreations();
      } catch (err) {
        writeStatusEl.textContent = `Error: ${err.message}`;
      }
    });

    randomSelectBtn.addEventListener('click', () => {
      const checkboxes = Array.from(
        creationsList.querySelectorAll('input[type="checkbox"]')
      );
      const count = Number.parseInt(randomCountEl.value, 10);
      if (!checkboxes.length || !Number.isFinite(count) || count <= 0) {
        return;
      }

      checkboxes.forEach((checkbox) => {
        checkbox.checked = false;
      });

      const picks = Math.min(count, checkboxes.length);
      const pool = [...checkboxes];
      for (let i = pool.length - 1; i > 0; i -= 1) {
        const j = Math.floor(Math.random() * (i + 1));
        [pool[i], pool[j]] = [pool[j], pool[i]];
      }

      pool.slice(0, picks).forEach((checkbox) => {
        checkbox.checked = true;
      });
    });

    async function loadWritingById(id) {
      try {
        const res = await fetch(`/api/writings/${encodeURIComponent(id)}`);
        if (!res.ok) throw new Error('Failed to load writing');
        const data = await res.json();
        writingId = data.id;
        currentName = data.name || currentName;
        currentDesc = data.description || currentDesc;
        updateHeading();
        document.getElementById('meta').textContent = data.created_at
          ? `Created ${data.created_at}`
          : '';
      } catch (err) {
        statusEl.textContent = `Error: ${err.message}`;
      }
    }

    async function init() {
      if (writingIdParam) {
        // New path: direct writing_id
        await loadWritingById(writingIdParam);
      } else {
        // Old path: use run_id + name + text_a + text_b to find or create
        currentName = ideaNameParam;
        currentDesc = ideaDescParam;
        updateHeading();
        document.getElementById('meta').textContent = runId ? `Run ${runId}` : '';
        await ensureWriting();
      }
      await loadTypes();
      await loadCreations();
      await loadNotes();
      await loadRuns();
    }

    init();
  </script>
</body>
</html>
