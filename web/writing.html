<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Writing</title>
<style>
  :root {
    --border-color: #000;
    --bg-main: #fff;
    --text-muted: #444;
  }

  * {
    box-sizing: border-box;
  }

  body {
    font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
    margin: 0;
    padding: 2rem 1.5rem;
    background: #fff;
    color: #000;
    line-height: 1.5;
  }

  main {
    max-width: 64rem;
    margin: 0 auto;
    background: #fff;
    border: 1px solid #000;
    padding: 1.75rem 1.5rem 2.5rem;
    box-shadow: none;
  }

  nav {
    margin-bottom: 1.5rem;
    display: flex;
    gap: 0.75rem;
    align-items: center;
    font-size: 0.9rem;
  }

  nav a {
    text-decoration: none;
    color: #000;
    padding: 0.25rem 0.6rem;
    border: 1px solid #000;
  }

  nav a:hover {
    background: #000;
    color: #fff;
  }

  h1 {
    font-size: 1.6rem;
    margin: 0 0 0.4rem;
  }

  h2 {
    font-size: 1.1rem;
    margin: 1.5rem 0 0.75rem;
  }

  label {
    display: block;
    font-weight: 600;
    margin-bottom: 0.35rem;
    font-size: 0.95rem;
  }

  textarea,
  input,
  select {
    width: 100%;
    padding: 0.55rem 0.7rem;
    font: inherit;
    border: 1px solid #000;
    background: #fff;
    color: #000;
    border-radius: 0;
  }

  textarea {
    resize: vertical;
  }

  input[type="checkbox"] {
    width: auto;
  }

  input[type="number"] {
    width: 6rem;
  }

  button {
    padding: 0.5rem 0.9rem;
    font: inherit;
    border: 1px solid #000;
    background: #000;
    color: #fff;
    cursor: pointer;
    border-radius: 0;
  }

  button.secondary {
    background: #fff;
    color: #000;
  }

  button:hover:not(:disabled) {
    background: #fff;
    color: #000;
  }

  button.secondary:hover {
    background: #000;
    color: #fff;
  }

  button:disabled {
    opacity: 0.6;
    cursor: default;
  }

  .row {
    display: flex;
    gap: 0.5rem;
    align-items: center;
    flex-wrap: wrap;
  }

  .result {
    margin-top: 0.75rem;
    white-space: pre-wrap;
  }

  .muted {
    color: #444;
    font-size: 0.9rem;
  }

  /* Section cards (now simple boxes, sharp edge) */
  .section-card {
    border: 1px solid #000;
    padding: 1rem 1.1rem;
    background: #fff;
    margin-bottom: 0.75rem;
    border-radius: 0;
  }

  .section-title {
    font-size: 0.95rem;
    font-weight: 700;
    margin-bottom: 0.6rem;
  }

  /* Lists */
  .list {
    border: 1px solid #000;
    padding: 0.5rem;
    max-height: 14rem;
    overflow: auto;
    background: #fff;
    font-size: 0.9rem;
    border-radius: 0;
  }

  .list label {
    display: flex;
    gap: 0.5rem;
    align-items: flex-start;
    font-weight: 400;
    margin: 0.25rem 0;
  }

  .list label span {
    flex: 1;
    white-space: pre-wrap;
    overflow-wrap: anywhere;
  }

  /* Text B layout */
  .textb-layout {
    display: flex;
    gap: 1rem;
    align-items: flex-start;
  }

  .textb-column {
    flex: 1;
    min-width: 0;
  }

  .textb-column-title {
    font-size: 0.9rem;
    font-weight: 700;
    margin-bottom: 0.35rem;
  }

  details {
    border: 1px solid #000;
    padding: 0.45rem 0.7rem 0.6rem;
    background: #fff;
    margin-bottom: 0.5rem;
    border-radius: 0;
  }

  summary {
    cursor: pointer;
    font-weight: 600;
  }

  #erase-writing {
    background: #000;
    border-color: #000;
    color: #fff;
  }

  #erase-writing:hover {
    background: #fff;
    color: #000;
  }

  @media (max-width: 900px) {
    main {
      padding: 1.25rem 1rem 1.75rem;
    }

    .textb-layout {
      flex-direction: column;
    }
  }

  #erase-container {
  display: flex;
  justify-content: flex-end;
  gap: 0.5rem;
  margin-top: 0.5rem;
}

#erase-container button {
  background: #b00000;
  color: white;
  border: none;
  padding: 0.4rem 0.8rem;
  border-radius: 6px;
  cursor: pointer;
}

#erase-container button:hover {
  background: #c00000;
}

  .type-list-block {
    margin-bottom: 0.4rem;
    font-size: 0.85rem;
  }

  .type-summary {
    padding: 0.25rem 0;
  }

  .type-summary strong {
    font-weight: 600;
  }

  /* Hide per-writing rows for other types */
  .type-list-hidden {
    display: none;
  }

  .test {
    border: 1px solid red;
  }


</style>


</head>
<body>
  <main>
    <nav>
      <a href="/index.html">home</a>
      <a href="/write.html">write</a>
      <a href="/lang.html">lang</a>
    </nav>

    <h1 id="idea-name">(untitled)</h1>
    <div id="idea-desc" class="desc"></div>
    <div id="meta" class="muted"></div>

    <div id="type-line" class="muted" style="margin-top: 0.25rem;"></div>

    <div id="parent-text" class="muted" style="margin-top: 0.25rem; display: none;"></div>



        <section>
      <h2>Write</h2>
      <form id="write-form">
        <!-- Text A card -->
        <div class="section-card">
          <div class="section-title">Text A</div>
          <label for="text-a">Text A</label>
          <textarea id="text-a" name="text_a" readonly></textarea>
          <div class="muted" style="margin-top: 0.25rem;">
            This is the base text for this writing.
          </div>
        </div>

        <!-- Text B sources card -->
        <div class="section-card">
          <div class="section-title">Text B sources</div>

          <div class="textb-layout">
            <!-- Column 1: Creations -->
            <div class="textb-column">
              <div class="textb-column-title">From creations</div>
              <small>Select one or more saved creations.</small>

              <div id="creations-list" class="list"></div>

              <div class="row" style="margin-top: 0.5rem;">
                <input id="random-count" type="number" min="1" placeholder="N" />
                <button type="button" id="random-select" class="secondary">
                  Select N random
                </button>
              </div>

              <button
                type="button"
                id="delete-creation"
                class="secondary"
                style="margin-top: 0.4rem;"
              >
                Remove selected
              </button>
            </div>

            <!-- Column 2: Language writings -->
            <div class="textb-column">
              <div class="textb-column-title">From language writings</div>
              <small>Use previous language writings as Text B.</small>

              <div id="lang-writings-list" class="list"></div>
            </div>

            <!-- Column 3: Other writing types -->
            <div class="textb-column">
              <div class="textb-column-title">From other types</div>
              <small>Use writings across types as Text B.</small>
              <select id="textb-type-select" style="display:none"></select>

              <div id="type-lists-container" class="list"></div>
            </div>
          </div>

          <div class="muted" style="margin-top: 0.75rem;">
            Select at least one Text B source to run this writing.
          </div>
        </div>

        <!-- Submit row -->
        <div class="row" style="margin-top: 0.75rem; justify-content: flex-end;">
          <button type="submit">Write</button>
        </div>
      </form>

      <div id="write-status" class="muted"></div>
      <div id="write-result" class="result"></div>
    </section>


    <section>
      <h2>Runs for this writing</h2>
      <div id="writing-runs"></div>
    </section>

    <section id="llm-child-section">
      <h2>Generate child writing (gargantua)</h2>

      <div class="section-card">
        <div class="section-title">gargantua entry</div>
        <select id="gargantua-select" multiple size="5"></select>
        <div id="gargantua-meta" class="muted" style="margin-top: 0.25rem;"></div>
      </div>

      <button type="button" id="run-gargantua-task">Generate child writing</button>
      <div id="gargantua-status" class="muted"></div>
    </section>



    <section>
      <h2>Child writings</h2>
      <label for="new-note-name">Add Child Writing Name</label>
      <input id="new-note-name" type="text" />
      <label for="new-note-desc">Add Child Writing Description</label>
      <textarea id="new-note-desc"></textarea>
      <label for="note-type-select">Child Writing Type</label>
      <div class="row">
        <select id="note-type-select"></select>
        <input id="note-type-custom" type="text" placeholder="Or enter custom type" />
      </div>
      <button type="button" id="add-note">Add Child Writing</button>
      <div id="status" class="muted"></div>
      <div id="notes"></div>
    </section>

    <!-- NEW: erase button -->
    <div id="erase-container">
      <button id="erase-writing" type="button" style="margin: 0.5rem 0; background: #c00; color: #fff;">
        Erase writing (and children)
      </button>
    </div>
  </main>

  <script>
    const params = new URLSearchParams(window.location.search);
    const ideaNameParam = params.get('name') || '(untitled)';
    const ideaDescParam = params.get('description') || '';
    const runId = params.get('run_id') || '';
    const textA = params.get('text_a') || '';
    const textB = params.get('text_b') || '';
    const writingIdParam = params.get('writing_id');

    const statusEl = document.getElementById('status');
    const notesEl = document.getElementById('notes');
    const newNoteNameEl = document.getElementById('new-note-name');
    const newNoteDescEl = document.getElementById('new-note-desc');
    const addNoteBtn = document.getElementById('add-note');
    const noteTypeSelect = document.getElementById('note-type-select');
    const noteTypeCustomEl = document.getElementById('note-type-custom');
    const textAEl = document.getElementById('text-a');
    const form = document.getElementById('write-form');
    const writeStatusEl = document.getElementById('write-status');
    const writeResultEl = document.getElementById('write-result');
    const runsEl = document.getElementById('writing-runs');
    const creationsList = document.getElementById('creations-list');
    const deleteCreationBtn = document.getElementById('delete-creation');
    const randomCountEl = document.getElementById('random-count');
    const randomSelectBtn = document.getElementById('random-select');

    const parentTextEl = document.getElementById('parent-text');
    const typeLineEl = document.getElementById('type-line');


    let writingId = null;
    let currentName = ideaNameParam;
    let currentDesc = ideaDescParam;

    let currentType = '';


    const eraseBtn = document.getElementById('erase-writing');

    const langWritingsList = document.getElementById('lang-writings-list');

    const textBTypeSelect = document.getElementById('textb-type-select');
    const typeListsContainer = document.getElementById('type-lists-container');

    const gargantuaSelect = document.getElementById('gargantua-select');
    const gargantuaMetaEl = document.getElementById('gargantua-meta');
    const gargantuaStatusEl = document.getElementById('gargantua-status');
    const runGargantuaBtn = document.getElementById('run-gargantua-task');





    function composeTextA(name, description) {
      if (name && description) return `${name}\n\n${description}`;
      return name || description || '';
    }

    function splitNoteContent(content) {
      const text = (content || '').trim();
      if (!text) return { name: '', description: '' };
      const lines = text.split(/\r?\n/);
      const name = (lines.shift() || '').trim();
      const description = lines.join('\n').trim();
      return { name, description };
    }
    
    function firstLine(text) {
      const t = (text || '').trim();
      if (!t) return '';
      return t.split(/\r?\n/)[0];
    }

    function renderParentTexts(parentTextA, parentTextB) {
      if (!parentTextEl) return;

      const lineA = firstLine(parentTextA);
      const lineB = firstLine(parentTextB);

      if (!lineA && !lineB) {
        parentTextEl.textContent = '';
        parentTextEl.style.display = 'none';
        return;
      }

      const parts = [];
      if (lineA) parts.push(`A: ${lineA}`);
      if (lineB) parts.push(`B: ${lineB}`);

      parentTextEl.textContent = `Parent text — ${parts.join(' | ')}`;
      parentTextEl.style.display = '';
    }


    function updateHeading() {
      document.getElementById('idea-name').textContent = currentName || '(untitled)';
      document.getElementById('idea-desc').textContent = currentDesc || '';
      textAEl.value = composeTextA(currentName, currentDesc);
    }

    async function ensureWriting() {
      try {
        const lookup = await fetch(`/api/writings/lookup?run_id=${encodeURIComponent(runId)}&name=${encodeURIComponent(currentName)}&text_a=${encodeURIComponent(textA)}&text_b=${encodeURIComponent(textB)}`);
        if (lookup.ok) {
          const data = await lookup.json();
          writingId = data.id;
          currentName = data.name || currentName;
          currentDesc = data.description || currentDesc;
          if (data.type) {
          currentType = data.type;
        }
          updateHeading();
          return;
        }
      } catch (err) {
        statusEl.textContent = `Error: ${err.message}`;
        return;
      }

      try {
        const res = await fetch('/api/writings', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            name: currentName,
            description: currentDesc,
            parent_run_id: runId || null,
            parent_text_a: textA,
            parent_text_b: textB,
          }),
        });
        if (!res.ok) {
          const err = await res.json().catch(() => ({}));
          throw new Error(err.error || 'Failed to create writing');
        }
        const data = await res.json();
        writingId = data.id;
      } catch (err) {
        statusEl.textContent = `Error: ${err.message}`;
      }
    }

    async function loadGargantuaEntries() {
      if (!gargantuaSelect) return;

      gargantuaSelect.innerHTML = '';
      gargantuaMetaEl.textContent = 'Loading…';

      try {
        const res = await fetch('/api/gargantua');
        if (!res.ok) throw new Error('Failed to load gargantua entries');
        const data = await res.json();

        gargantuaSelect.innerHTML = '';
        if (!data.length) {
          gargantuaMetaEl.textContent = 'No gargantua entries yet.';
          return;
        }

        data.forEach((g) => {
          const opt = document.createElement('option');
          opt.value = String(g.id);
          opt.textContent = g.name || `(id ${g.id})`;
          opt.dataset.type = g.type || '';
          gargantuaSelect.appendChild(opt);
        });

        gargantuaMetaEl.textContent = 'Pick one or more entries; each selection will create a child writing.';
      } catch (err) {
        gargantuaMetaEl.textContent = `Error: ${err.message}`;
      }
    }


    async function loadLangWritings() {
      try {
        const res = await fetch('/api/writings?type=lang');
        if (!res.ok) throw new Error('Failed to load language writings');
        const data = await res.json();

        langWritingsList.textContent = '';
        if (!data.length) {
          langWritingsList.textContent = 'No language writings yet.';
          return;
        }

        data.forEach((item) => {
          const label = document.createElement('label');
          const checkbox = document.createElement('input');
          checkbox.type = 'checkbox';
          checkbox.value = String(item.id);
          checkbox.dataset.name = item.name || '';
          checkbox.dataset.description = item.description || '';
          const span = document.createElement('span');
          span.textContent = item.name || '(untitled)'; // name only
          label.appendChild(checkbox);
          label.appendChild(span);
          langWritingsList.appendChild(label);
        });
      } catch (err) {
        writeStatusEl.textContent = `Error: ${err.message}`;
      }
    }


    function renderNotes(notes) {
      notesEl.textContent = '';
      if (!notes.length) {
        notesEl.textContent = 'No notes yet.';
        return;
      }
      notes.forEach((note) => {
        const container = document.createElement('div');
        container.className = 'note';

        const typeText = note.child_type ? `Type: ${note.child_type}` : 'Type: (none)';
        const typeEl = document.createElement('div');
        typeEl.className = 'muted';
        typeEl.textContent = typeText;
        container.appendChild(typeEl);


        const { name, description } = splitNoteContent(note.content);
        const nameInput = document.createElement('input');
        nameInput.type = 'text';
        nameInput.value = name;
        container.appendChild(nameInput);

        const textarea = document.createElement('textarea');
        textarea.value = description;
        container.appendChild(textarea);

        const buttonsRow = document.createElement('div');
        buttonsRow.className = 'row';

        const saveBtn = document.createElement('button');
        saveBtn.type = 'button';
        saveBtn.textContent = 'Save';
        saveBtn.addEventListener('click', async () => {
          try {
            const res = await fetch(`/api/notes/${note.id}`, {
              method: 'PATCH',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                name: nameInput.value.trim(),
                description: textarea.value.trim(),
              }),
            });
            if (!res.ok) {
              const err = await res.json().catch(() => ({}));
              throw new Error(err.error || 'Failed to update note');
            }
            statusEl.textContent = 'Note saved.';
          } catch (err) {
            statusEl.textContent = `Error: ${err.message}`;
          }
        });
        buttonsRow.appendChild(saveBtn);


        const deleteBtn = document.createElement('button');
        deleteBtn.type = 'button';
        deleteBtn.textContent = 'Delete';
        deleteBtn.addEventListener('click', async () => {
          try {
            const res = await fetch(`/api/notes/${note.id}`, { method: 'DELETE' });
            if (!res.ok) {
              const err = await res.json().catch(() => ({}));
              throw new Error(err.error || 'Failed to delete note');
            }
            await loadNotes();
          } catch (err) {
            statusEl.textContent = `Error: ${err.message}`;
          }
        });
        buttonsRow.appendChild(deleteBtn);

        // Open this note as its own writing
        if (note.child_writing_id) {
          const openBtn = document.createElement('button');
          openBtn.type = 'button';
          openBtn.textContent = 'Open writing';
          openBtn.addEventListener('click', () => {
            const url = `/writing.html?writing_id=${encodeURIComponent(note.child_writing_id)}`;
            window.open(url, '_blank');
          });
          buttonsRow.appendChild(openBtn);
        }

        container.appendChild(buttonsRow);
        notesEl.appendChild(container);
      });
    }

    async function loadNotes() {
      if (!writingId) return;
      try {
        const res = await fetch(`/api/writings/${writingId}/notes`);
        if (!res.ok) throw new Error('Failed to load notes');
        const data = await res.json();
        renderNotes(data);
      } catch (err) {
        statusEl.textContent = `Error: ${err.message}`;
      }
    }

    async function loadTypes() {
      try {
        // Use the stats endpoint so we get counts per type
        const res = await fetch('/api/writing-types/stats');
        if (!res.ok) throw new Error('Failed to load types');
        const data = await res.json();
        if (!Array.isArray(data)) return;

        // Fill noteTypeSelect as before
        noteTypeSelect.textContent = '';
        const placeholder = document.createElement('option');
        placeholder.value = '';
        placeholder.textContent = '(no type)';
        noteTypeSelect.appendChild(placeholder);

        data.forEach((item) => {
          const type = item && item.type;
          if (!type) return;
          const opt = document.createElement('option');
          opt.value = type;
          opt.textContent = type;
          noteTypeSelect.appendChild(opt);
        });

        // We keep the hidden textBTypeSelect for compatibility, but it isn't used.
        textBTypeSelect.textContent = '';
        const tbPlaceholder = document.createElement('option');
        tbPlaceholder.value = '';
        tbPlaceholder.textContent = 'Select type…';
        textBTypeSelect.appendChild(tbPlaceholder);

        // Build "other types" summaries (non-creations, non-lang)
        typeListsContainer.textContent = '';

        const otherTypes = data.filter(
          (item) =>
            item &&
            item.type &&
            item.type !== 'creations' &&
            item.type !== 'lang'
        );

        otherTypes.forEach((item) => {
          const type = item.type;
          const count = item.count || 0;

          const wrapper = document.createElement('div');
          wrapper.dataset.typeList = type;
          wrapper.dataset.total = String(count);
          wrapper.className = 'type-list-block';

          const summary = document.createElement('div');
          summary.className = 'type-summary';
          summary.innerHTML = `
            <strong>${type}</strong>:
            <span class="type-total">${count}</span> writings,
            <span class="type-selected">0</span> selected
          `;
          wrapper.appendChild(summary);

          // Hidden container that will hold ONLY the randomly selected writings
          const selectedContainer = document.createElement('div');
          selectedContainer.className =
            'type-selected-container type-list-hidden';
          wrapper.appendChild(selectedContainer);

          typeListsContainer.appendChild(wrapper);
        });
      } catch (err) {
        console.error('Failed to load writing types', err);
      }
    }



    async function addTypeList(type) {
      if (!type) return;

      const existing = typeListsContainer.querySelector(
        `[data-type-list="${type}"]`
      );
      if (existing) return existing;

      const wrapper = document.createElement('div');
      wrapper.dataset.typeList = type;
      wrapper.className = 'type-list-block';

      // Summary row (visible)
      const summary = document.createElement('div');
      summary.className = 'type-summary';
      summary.innerHTML = `
        <strong>${type}</strong>:
        <span class="type-total">0</span> writings,
        <span class="type-selected">0</span> selected
      `;
      wrapper.appendChild(summary);

      // Hidden list of actual writings
      const list = document.createElement('div');
      list.className = 'list type-list-hidden';
      wrapper.appendChild(list);

      typeListsContainer.appendChild(wrapper);

      try {
        const res = await fetch(`/api/writings?type=${encodeURIComponent(type)}`);
        if (!res.ok) throw new Error(`Failed to load writings for type ${type}`);
        const data = await res.json();

        list.textContent = '';
        const totalSpan = summary.querySelector('.type-total');
        const selectedSpan = summary.querySelector('.type-selected');

        if (!data.length) {
          totalSpan.textContent = '0';
          selectedSpan.textContent = '0';
          return wrapper;
        }

        data.forEach((item) => {
          const row = document.createElement('label');
          const checkbox = document.createElement('input');
          checkbox.type = 'checkbox';
          checkbox.value = String(item.id);
          checkbox.dataset.name = item.name || '';
          checkbox.dataset.description = item.description || '';

          const span = document.createElement('span');
          span.textContent = item.name || '(untitled)';
          row.appendChild(checkbox);
          row.appendChild(span);
          list.appendChild(row);
        });

        totalSpan.textContent = String(data.length);
        selectedSpan.textContent = '0';
      } catch (err) {
        list.textContent = `Error: ${err.message}`;
      }

      return wrapper;
    }


    function updateAllTypeSummaries() {
      const blocks = typeListsContainer.querySelectorAll('.type-list-block');
      blocks.forEach((block) => {
        const selectedContainer =
          block.querySelector('.type-selected-container') ||
          block.querySelector('.list'); // fallback

        const totalSpan = block.querySelector('.type-total');
        const selectedSpan = block.querySelector('.type-selected');
        if (!selectedSpan) return;

        // total comes from the data attribute, not from checkbox count
        if (totalSpan && block.dataset.total != null) {
          totalSpan.textContent = block.dataset.total;
        }

        if (!selectedContainer) {
          selectedSpan.textContent = '0';
          return;
        }

        const checkboxes = Array.from(
          selectedContainer.querySelectorAll('input[type="checkbox"]')
        );

        selectedSpan.textContent = String(
          checkboxes.filter((cb) => cb.checked).length
        );
      });
    }

    // Keep summaries in sync if any of the hidden checkboxes are toggled
    typeListsContainer.addEventListener('change', (event) => {
      if (event.target && event.target.matches('input[type="checkbox"]')) {
        updateAllTypeSummaries();
      }
    });




    function renderIdeaSet(response, run) {
      const container = document.createElement('div');
      container.className = 'ideas';

      if (response && typeof response === 'object' && Array.isArray(response.ideas)) {
        response.ideas.forEach((idea) => {
          const ideaEl = document.createElement('div');
          ideaEl.className = 'idea';
          const link = document.createElement('a');
          const name = idea.name || '(untitled)';
          const descText = idea.desciription || '';
          link.textContent = name;

          if (idea.writing_id) {
            // New path: writing created at LLM time
            const params = new URLSearchParams({ writing_id: String(idea.writing_id) });
            link.href = `/writing.html?${params.toString()}`;
          } else {
            // Fallback for older runs that don't have writing_id
            const params = new URLSearchParams({
              run_id: String(run.id || ''),
              text_a: run.text_a || '',
              text_b: run.text_b || '',
              name,
              description: descText,
            });
            link.href = `/writing.html?${params.toString()}`;
          }

          const desc = document.createElement('div');
          desc.textContent = descText;
          ideaEl.appendChild(link);
          ideaEl.appendChild(desc);
          container.appendChild(ideaEl);
        });
      } else {
        const pre = document.createElement('pre');
        pre.textContent = typeof response === 'string' ? response : JSON.stringify(response, null, 2);
        container.appendChild(pre);
      }

      return container;
    }

    function renderRuns(runs) {
      runsEl.textContent = '';

      const filtered = runs.filter(run => {
        // Either we rely on prompt_id or instruction value
        if (run.prompt_id) return false;
        if (run.instruction === 'prompt_child') return false;
        return true;
      });

      if (!filtered.length) {
        runsEl.textContent = 'No runs yet.';
        return;
      }

      filtered.forEach((run) => {
        const runDetails = document.createElement('details');
        const summary = document.createElement('summary');
        const summaryText = firstLine(run.text_b);
        summary.textContent = summaryText || '(no text B)';
        runDetails.appendChild(summary);

        const meta = document.createElement('div');
        meta.className = 'meta';
        meta.textContent = run.created_at ? `Created ${run.created_at}` : '';
        runDetails.appendChild(meta);

        runDetails.appendChild(renderIdeaSet(run.response, run));
        runsEl.appendChild(runDetails);
      });
    }

    async function loadRuns() {
      if (!writingId) return;
      runsEl.textContent = 'Loading...';
      try {
        const res = await fetch(`/api/lang?parent_writing_id=${encodeURIComponent(writingId)}`);
        if (!res.ok) throw new Error('Failed to load runs');
        const data = await res.json();
        runsEl.textContent = '';
        if (!data.length) {
          runsEl.textContent = 'No runs yet.';
          return;
        }
        renderRuns(data);
      } catch (err) {
        runsEl.textContent = `Error: ${err.message}`;
      }
    }

    async function loadCreations() {
      // no need to wait for writingId
      try {
        const res = await fetch('/api/creations');   // ← changed
        if (!res.ok) throw new Error('Failed to load creations');
        const data = await res.json();
        creationsList.textContent = '';
        if (!data.length) {
          creationsList.textContent = 'No creations yet.';
          return;
        }
        data.forEach((item) => {
          const label = document.createElement('label');
          const checkbox = document.createElement('input');
          checkbox.type = 'checkbox';
          checkbox.value = String(item.id);
          checkbox.dataset.name = item.name || '';
          checkbox.dataset.description = item.description || '';
          const span = document.createElement('span');
          const name = item.name || '(untitled)';
          const type = item.type ? ` — ${item.type}` : '';
          span.textContent = name + type;

          label.appendChild(checkbox);
          label.appendChild(span);

          creationsList.appendChild(label);
        });
      } catch (err) {
        writeStatusEl.textContent = `Error: ${err.message}`;
      }
    }

    if (gargantuaSelect) {
      gargantuaSelect.addEventListener('change', () => {
        const selected = Array.from(gargantuaSelect.selectedOptions);
        if (!selected.length) {
          gargantuaMetaEl.textContent = '';
          return;
        }
        const types = Array.from(
          new Set(
            selected
              .map((option) => (option.dataset.type || '').trim())
              .filter(Boolean)
          )
        );
        gargantuaMetaEl.textContent = types.length
          ? `Child writing types: ${types.join(', ')}`
          : 'Child writing types: (none)';
      });
    }

    if (runGargantuaBtn) {
      runGargantuaBtn.addEventListener('click', async () => {
        if (!writingId) {
          gargantuaStatusEl.textContent = 'Writing is not ready yet.';
          return;
        }

        const selectedOptions = gargantuaSelect
          ? Array.from(gargantuaSelect.selectedOptions)
          : [];
        const gargantuaIds = selectedOptions
          .map((option) => Number.parseInt(option.value, 10))
          .filter((value) => Number.isFinite(value));

        if (!gargantuaIds.length) {
          gargantuaStatusEl.textContent = 'Select at least one gargantua entry.';
          return;
        }

        try {
          gargantuaStatusEl.textContent = 'Queuing LLM tasks…';

          const results = await Promise.all(
            gargantuaIds.map(async (gargantuaId) => {
              const res = await fetch(`/api/writings/${encodeURIComponent(writingId)}/gargantua-run`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ gargantua_id: gargantuaId }),
              });

              if (!res.ok) {
                const err = await res.json().catch(() => ({}));
                throw new Error(err.error || `Failed to queue gargantua task ${gargantuaId}`);
              }

              return res.json();
            })
          );

          const queued = results
            .filter((item) => item && item.task_id)
            .map((item) => item.task_id);

          gargantuaStatusEl.textContent = queued.length
            ? `Queued tasks ${queued.join(', ')}. Check /queue.html for status.`
            : 'Tasks queued. Check /queue.html for status.';
        } catch (err) {
          gargantuaStatusEl.textContent = `Error: ${err.message}`;
        }
      });
    }



    eraseBtn.addEventListener('click', async () => {
          if (!writingId) {
            alert('Writing is not loaded yet.');
            return;
          }

          const confirmed = window.confirm(
            'Erase this writing and ALL of its child writings, notes, and runs? This cannot be undone.'
          );
          if (!confirmed) return;

          try {
            const res = await fetch(`/api/writings/${encodeURIComponent(writingId)}/erase`, {
              method: 'DELETE',
            });
            if (!res.ok) {
              const err = await res.json().catch(() => ({}));
              throw new Error(err.error || 'Failed to erase writing');
            }

            // Optionally, you can inspect the deleted IDs:
            // const data = await res.json();

            // After successful erase, send user somewhere safe
            window.location.href = '/writings.html'; // or '/lang.html' or '/index.html'
          } catch (err) {
            statusEl.textContent = `Error: ${err.message}`;
          }
        });

    addNoteBtn.addEventListener('click', async () => {
      if (!writingId) return;
      const nameValue = newNoteNameEl.value.trim();
      const descValue = newNoteDescEl.value.trim();
      const selectedType = (noteTypeSelect.value || '').trim();
      const customType = (noteTypeCustomEl.value || '').trim();
      const typeValue = customType || selectedType;
      if (!nameValue && !descValue) return;
      try {
        const payload = { name: nameValue, description: descValue };
        if (typeValue) {
          payload.type = typeValue;
        }
        const res = await fetch(`/api/writings/${writingId}/notes`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload),
        });
        if (!res.ok) {
          const err = await res.json().catch(() => ({}));
          throw new Error(err.error || 'Failed to create note');
        }
        newNoteNameEl.value = '';
        newNoteDescEl.value = '';
        noteTypeSelect.value = '';
        noteTypeCustomEl.value = '';
        await loadNotes();
      } catch (err) {
        statusEl.textContent = `Error: ${err.message}`;
      }
    });

    form.addEventListener('submit', async (event) => {
      event.preventDefault();
      writeStatusEl.textContent = 'writing...';
      writeResultEl.textContent = '';

      if (!writingId) {
        writeStatusEl.textContent = 'Writing is not ready yet.';
        return;
      }

      const selectedCreations = Array.from(
        creationsList.querySelectorAll('input[type="checkbox"]:checked')
      );
      const selectedLang = Array.from(
        langWritingsList.querySelectorAll('input[type="checkbox"]:checked')
      );

      const selectedTyped = Array.from(
        typeListsContainer.querySelectorAll('input[type="checkbox"]:checked')
      );

      if (!selectedCreations.length && !selectedLang.length && !selectedTyped.length) {
        writeStatusEl.textContent = 'Select at least one Text B.';
        return;
      }

      const textAValue = textAEl.value.trim();
      if (!textAValue) {
        writeStatusEl.textContent = 'Text A is empty.';
        return;
      }

      try {
        const jobs = [];

        // 1) creations: raw text_b
        selectedCreations.forEach((checkbox) => {
          const name = checkbox.dataset.name || '';
          const description = checkbox.dataset.description || '';
          const textBValue = composeTextA(name, description);
          jobs.push({
            text_a: textAValue,
            text_b: textBValue,
            parent_writing_id: writingId,
          });
        });


        // 2) lang writings: name + description as text_b
        selectedLang.forEach((checkbox) => {
          const name = checkbox.dataset.name || '';
          const description = checkbox.dataset.description || '';
          const textBValue = composeTextA(name, description);
          jobs.push({
            text_a: textAValue,
            text_b: textBValue,
            parent_writing_id: writingId,
          });
        });

         // 3) type-based lists: name + description
        selectedTyped.forEach((checkbox) => {
          const name = checkbox.dataset.name || '';
          const description = checkbox.dataset.description || '';
          const textBValue = composeTextA(name, description);
          jobs.push({
            text_a: textAValue,
            text_b: textBValue,
            parent_writing_id: writingId,
          });
        });



        const results = await Promise.all(
          jobs.map(async (payload) => {
            const res = await fetch('/api/lang', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify(payload),
            });
            if (!res.ok) {
              const err = await res.json().catch(() => ({}));
              throw new Error(err.error || 'Request failed');
            }
            return res.json();
          })
        );



        writeStatusEl.textContent = '';
        const queued = results
          .filter((item) => item && item.task_id)
          .map((item) => item.task_id);
        if (queued.length) {
          writeResultEl.textContent =
            `Queued tasks: ${queued.join(', ')}. Check /queue.html for status.`;
        } else {
          writeResultEl.textContent = '';
        }
      } catch (err) {
        writeStatusEl.textContent = `Error: ${err.message}`;
      }
    });


    deleteCreationBtn.addEventListener('click', async () => {
      const selected = Array.from(
        creationsList.querySelectorAll('input[type="checkbox"]:checked')
      );
      if (!selected.length) return;
      try {
        await Promise.all(
          selected.map(async (checkbox) => {
            const res = await fetch(`/api/creations/${checkbox.value}`, {
              method: 'DELETE',
            });
            if (!res.ok) {
              const err = await res.json().catch(() => ({}));
              throw new Error(err.error || 'Failed to delete creation');
            }
          })
        );
        await loadCreations();
      } catch (err) {
        writeStatusEl.textContent = `Error: ${err.message}`;
      }
    });

    randomSelectBtn.addEventListener('click', async () => {
      const count = Number.parseInt(randomCountEl.value, 10);
      if (!Number.isFinite(count) || count <= 0) {
        return;
      }

      writeStatusEl.textContent = 'Selecting random writings...';

      // 1) Clear all existing selections
      //    a) Creations + lang: just uncheck
      [
        ...creationsList.querySelectorAll('input[type="checkbox"]'),
        ...langWritingsList.querySelectorAll('input[type="checkbox"]'),
      ].forEach((cb) => {
        cb.checked = false;
      });

      //    b) Other types: remove any previously created selected checkboxes
      typeListsContainer
        .querySelectorAll('.type-selected-container')
        .forEach((container) => {
          container.textContent = '';
        });

      try {
        // 2) Ask the backend for a balanced selection
        const res = await fetch(
          `/api/writings/random-balanced?total=${encodeURIComponent(count)}`
        );
        if (!res.ok) {
          const err = await res.json().catch(() => ({}));
          throw new Error(err.error || 'Random selection failed');
        }
        const data = await res.json();
        if (!Array.isArray(data)) {
          throw new Error('Unexpected response from random-balanced');
        }

        // 3) Mark the returned writings as selected in the UI
        data.forEach((item) => {
          const id = String(item.id);
          const type = item.type || '';
          const name = item.name || '';
          const description = item.description || '';

          if (type === 'creations') {
            // Existing creations checkbox
            const cb = creationsList.querySelector(
              `input[type="checkbox"][value="${id}"]`
            );
            if (cb) {
              cb.checked = true;
              cb.dataset.name = name;
              cb.dataset.description = description;
            }
            return;
          }

          if (type === 'lang') {
            // Existing lang checkbox
            const cb = langWritingsList.querySelector(
              `input[type="checkbox"][value="${id}"]`
            );
            if (cb) {
              cb.checked = true;
              cb.dataset.name = name;
              cb.dataset.description = description;
            }
            return;
          }

          // Other types: add a hidden checkbox to that type's container
          let block = typeListsContainer.querySelector(
            `[data-type-list="${type}"]`
          );

          // If this type wasn't present in stats, create a block on the fly
          if (!block) {
            block = document.createElement('div');
            block.dataset.typeList = type;
            block.dataset.total = '0';
            block.className = 'type-list-block';

            const summary = document.createElement('div');
            summary.className = 'type-summary';
            summary.innerHTML = `
              <strong>${type}</strong>:
              <span class="type-total">0</span> writings,
              <span class="type-selected">0</span> selected
            `;
            block.appendChild(summary);

            const selectedContainer = document.createElement('div');
            selectedContainer.className =
              'type-selected-container type-list-hidden';
            block.appendChild(selectedContainer);

            typeListsContainer.appendChild(block);
          }

          const selectedContainer =
            block.querySelector('.type-selected-container');
          if (!selectedContainer) return;

          const label = document.createElement('label');
          const cb = document.createElement('input');
          cb.type = 'checkbox';
          cb.value = id;
          cb.checked = true; // pre-selected
          cb.dataset.name = name;
          cb.dataset.description = description;

          const span = document.createElement('span');
          span.textContent = name || '(untitled)';

          label.appendChild(cb);
          label.appendChild(span);
          selectedContainer.appendChild(label);
        });

        updateAllTypeSummaries();
        writeStatusEl.textContent = '';
      } catch (err) {
        writeStatusEl.textContent = `Error selecting random writings: ${err.message}`;
      }
    });




    async function loadWritingById(id) {
      try {
        const res = await fetch(`/api/writings/${encodeURIComponent(id)}`);
        if (!res.ok) throw new Error('Failed to load writing');
        const data = await res.json();
        writingId = data.id;
        currentName = data.name || currentName;
        currentDesc = data.description || currentDesc;
        currentType = data.type || '';  
        updateHeading();
        document.getElementById('meta').textContent = data.created_at
          ? `Created ${data.created_at}`
          : '';

        typeLineEl.textContent = data.type ? `Type: ${data.type}` : 'Type: (none)';
        renderParentTexts(data.parent_text_a, data.parent_text_b);

      } catch (err) {
        statusEl.textContent = `Error: ${err.message}`;
      }
    }



    async function init() {
      if (writingIdParam) {
        // New path: direct writing_id
        await loadWritingById(writingIdParam);
      } else {
        // Old path...
        currentName = ideaNameParam;
        currentDesc = ideaDescParam;
        updateHeading();
        document.getElementById('meta').textContent = runId ? `Run ${runId}` : '';
        await ensureWriting();
        renderParentTexts(textA, textB);
      }
      await loadTypes();
      await loadCreations();
      await loadLangWritings();
      await loadNotes();
      await loadRuns();
      await loadGargantuaEntries(); 
    }



    init();
  </script>
</body>
</html>
