<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Imagine...</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <style>
    :root { color-scheme: light dark; }
    body { font-family: system-ui, sans-serif; margin: 2rem; max-width: 1100px; }
    h1 { font-size: 1.6rem; margin-bottom: .5rem; }
    form { display: grid; gap: .6rem; margin: 1rem 0; align-items: start; }
    textarea { padding: .6rem .7rem; min-width: 28rem; width: min(90vw, 48rem); border: 1px solid #ccc; border-radius: .5rem; }
    .row { display:flex; align-items:center; gap:.6rem; flex-wrap:wrap; }
    .providers { display:flex; gap:.8rem; flex-wrap:wrap; }
    .chip { display:inline-flex; align-items:center; gap:.35rem; padding:.35rem .55rem; border:1px solid #ccc; border-radius:.6rem; background: rgba(0,0,0,.02); }
    .muted { opacity:.8; font-size:.9rem; }
    button { padding: .6rem .9rem; border: 0; border-radius: .5rem; cursor: pointer; background: #0b5cff; color: #fff; }
    button.secondary { background:#444; }
    .meta { font-size: .9rem; opacity: .85; margin: .25rem 0 1rem; }
    .grid { display: grid; gap: .8rem; }
    details { border: 1px solid #d0d0d0; border-radius: .6rem; padding: .75rem 1rem; background: rgba(0,0,0,.02); }
    summary { cursor: pointer; font-weight: 600; }
    .thesis { margin: .4rem 0 .3rem; font-style: italic; white-space: pre-wrap; }
    .targets { margin: .25rem 0 .5rem 1.25rem; }
    .seedbox { border-top: 1px dashed #c8c8c8; margin-top: .5rem; padding-top: .5rem; }
    .seed-title { font-weight: 600; margin-bottom: .25rem; }
    .seed { margin: .35rem 0; padding: .5rem .6rem; border: 1px solid #e0e0e0; border-radius: .5rem; background: #fff; }
    .seed small { display: block; opacity: .8; margin-top: .2rem; }
    .dim-error, .seed-error, .error { color: #b00020; white-space: pre-wrap; }
    pre { background: #f6f6f6; padding: .75rem; border-radius: .5rem; overflow-x: auto; }
    .badge { font-size:.8rem; padding:.15rem .45rem; border:1px solid #ddd; border-radius:.4rem; }
    .provider-block { border:1px solid #e2e2e2; border-radius:.6rem; padding: .6rem .8rem; background: rgba(0,0,0,.02); }
    .provider-head { display:flex; align-items:center; gap:.5rem; margin-bottom:.4rem; }
    .provider-name { font-weight:600; }
    .provider-status { font-size:.9rem; opacity:.8; }
    .provider-grid { display:grid; gap:.7rem; }
    .pro-sep { height:.5rem; }
    .domain-head { display:flex; align-items:center; gap:.6rem; }
    a.seedlink { text-decoration: none; color: inherit; display:block; }
    a.seedlink:hover .seed { outline: 2px solid #9bbcff; outline-offset: 2px; }
  </style>
</head>
<body>
  <h1>Imagine</h1>

  <section class="panel" id="panel-instructions" aria-labelledby="h-instructions" 
          style="border-color: color-mix(in oklab, dodgerblue 40%, CanvasText 20%);
                  background: color-mix(in oklab, Canvas 88%, dodgerblue 12%);
                  box-shadow: 0 1px 0 rgba(30,144,255,.12) inset;">
    <header><h2 id="h-instructions">Instructions</h2></header>
    <div class="content" style="font-size:.9rem; line-height:1.45;">
      <ul style="margin:0; padding-left:1.1rem; display:grid; gap:.4rem;">
        <li>Enter your <strong>email</strong> to load or save private narratives.</li>
        <li>Type one or more things you want to create/understand/imagine (one per line).</li>
        <li>Select which <strong>providers</strong> you want to use for generation.</li>
        <li>Click <strong>Generate</strong> to create narrative dimensions and seeds.</li>
        <li>Click a seed to construct its prototype/box of dirt.</li>
      </ul>
      <p class="muted" style="margin-top:.6rem;">Email is required to save work to your private garden.</p>
    </div>
  </section>


  <form id="form" autocomplete="off">
    <textarea id="domains" rows="4" placeholder="Enter one or more domains — one per line"></textarea>

    <!-- Provider selection -->
    <div class="row">
      <span class="muted">Providers:</span>
      <label class="chip"><input id="allProviders" type="checkbox" checked> Select all</label>
      <div id="providerChips" class="providers">
        <label class="chip"><input type="checkbox" value="openai" checked> openai</label>
        <label class="chip"><input type="checkbox" value="openai_web" checked> openai_web</label>
        <label class="chip"><input type="checkbox" value="xai" checked> xai</label>
        <label class="chip"><input type="checkbox" value="gemini" checked> gemini</label>
        <label class="chip"><input type="checkbox" value="deepseek" checked> deepseek</label>
      </div>
      <button id="noneBtn" type="button" class="secondary" title="Deselect all providers">None</button>
      <button id="invertBtn" type="button" class="secondary" title="Invert selection">Invert</button>
    </div>

    <div class="row">
      <input type="email" id="emailInput" placeholder="Enter email to save results to your personal garden (optional)" />
      <button type="button" id="saveEmailBtn" class="secondary" title="Save email locally">Save email</button>
    </div>
    

    <div class="row">
      <button type="submit">Generate</button>
      <span id="hint" class="muted">Runs selected providers per domain with live updates.</span>
    </div>
  </form>

  <div id="globalStatus" class="meta"></div>
  <div id="container"></div>

  <script>
    const PROVIDERS = ['openai', 'openai_web', 'xai', 'gemini', 'deepseek'];
    const MAX_SEED_CONCURRENCY = 2;
    const EMAIL_KEY = 'fg_user_email';

    const form = document.getElementById('form');
    const multiDomainsInput = document.getElementById('domains');
    const globalStatus = document.getElementById('globalStatus');
    const container = document.getElementById('container');

    const allProvidersCb = document.getElementById('allProviders');
    const providerChips = document.getElementById('providerChips');
    const noneBtn = document.getElementById('noneBtn');
    const invertBtn = document.getElementById('invertBtn');
    const saveEmailBtn = document.getElementById('saveEmailBtn');


    function saveEmailToStorage(email) {
      const v = String(email || '').trim().toLowerCase();
      if (v) localStorage.setItem(EMAIL_KEY, v);
      else localStorage.removeItem(EMAIL_KEY);
    }

    function readEmailFromStorage() {
      return (localStorage.getItem(EMAIL_KEY) || '').trim().toLowerCase();
    }

    function prefillEmailFromStorage() {
      const input = document.getElementById('emailInput');
      const v = readEmailFromStorage();
      if (input && v && !input.value) input.value = v;  // don't clobber user-typed text
    }

    function currentEmail() {
      const typed = (document.getElementById('emailInput')?.value || '').trim().toLowerCase();
      return typed || readEmailFromStorage();
    }




    // ---------- provider selection logic ----------
    function getProviderCheckboxes() {
      return Array.from(providerChips.querySelectorAll('input[type="checkbox"]'));
    }
    function syncAllCheckboxFromChildren() {
      const boxes = getProviderCheckboxes();
      const checkedCount = boxes.filter(b => b.checked).length;
      allProvidersCb.indeterminate = checkedCount > 0 && checkedCount < boxes.length;
      allProvidersCb.checked = checkedCount === boxes.length;
    }
    function setAllProviders(val) {
      getProviderCheckboxes().forEach(b => b.checked = val);
      allProvidersCb.indeterminate = false;
      allProvidersCb.checked = val;
    }
    function invertProviders() {
      getProviderCheckboxes().forEach(b => b.checked = !b.checked);
      syncAllCheckboxFromChildren();
    }
    function getSelectedProviders() {
      const selected = getProviderCheckboxes().filter(b => b.checked).map(b => b.value);
      return selected.length ? selected : []; // caller will validate
    }

    allProvidersCb.addEventListener('change', () => setAllProviders(allProvidersCb.checked));
    providerChips.addEventListener('change', syncAllCheckboxFromChildren);
    noneBtn.addEventListener('click', () => setAllProviders(false));
    invertBtn.addEventListener('click', invertProviders);

    // ---------- utilities ----------
    function el(tag, opts = {}) {
      const node = document.createElement(tag);
      if (opts.className) node.className = opts.className;
      if ('text' in opts) node.textContent = opts.text;
      if ('html' in opts) node.innerHTML = opts.html;
      if (opts.attrs) Object.entries(opts.attrs).forEach(([k,v]) => node.setAttribute(k,v));
      return node;
    }
    function escapeHtml(s) {
      return String(s)
        .replaceAll('&', '&amp;').replaceAll('<', '&lt;')
        .replaceAll('>', '&gt;').replaceAll('"', '&quot;')
        .replaceAll("'", '&#39;');
    }
    async function fetchWithTimeout(url, options = {}, timeoutMs = 180000) {
      const controller = new AbortController();
      const id = setTimeout(() => controller.abort(), timeoutMs);
      try { return await fetch(url, { ...options, signal: controller.signal }); }
      finally { clearTimeout(id); }
    }
    async function postJSON(url, body, timeoutMs = 180000) {
      const resp = await fetchWithTimeout(url, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(body)
      }, timeoutMs);
      let data;
      try { data = await resp.json(); } catch {
        throw new Error(`Non-JSON response from ${url} (status ${resp.status})`);
      }
      if (!resp.ok) {
        const msg = (data && (data.error || data.detail)) ? `${data.error || ''} ${data.detail || ''}`.trim() : `HTTP ${resp.status}`;
        throw new Error(msg);
      }
      return data;
    }
    const sleep = (ms) => new Promise(r => setTimeout(r, ms));
    // ADD next to fetchWithTimeout/postJSON
    async function getJSON(url, timeoutMs = 180000) {
      const resp = await fetchWithTimeout(url, {}, timeoutMs);
      let data;
      try { data = await resp.json(); } catch {
        throw new Error(`Non-JSON response from ${url} (status ${resp.status})`);
      }
      if (!resp.ok) {
        const msg = (data && (data.error || data.detail)) ? `${data.error || ''} ${data.detail || ''}`.trim() : `HTTP ${resp.status}`;
        throw new Error(msg);
      }
      return data;
    }

    // Narrative title → id cache so we can deep link dirt.html with IDs
    const narrativeIdByTitle = new Map();
    async function ensureNarrativesCache() {
      if (narrativeIdByTitle.size) return;
      const rows = await getJSON('/api/narratives?email=' + encodeURIComponent(em));
      rows.forEach(r => {
        if (r && r.title) narrativeIdByTitle.set(r.title, r.id);
      });
    }
    function getNarrativeIdForTitle(title) {
      return narrativeIdByTitle.get(title) || null;
    }


    // ---------- per-domain UI ----------
    function makeDomainSection(domain) {
      const section = el('section');
      const h2 = el('h2');
      const head = el('div', { className:'domain-head' });
      head.append(el('span', { text: domain }));
      h2.append(head);

      const meta = el('div', { className: 'meta' });
      const err = el('div', { className: 'error' });
      const providersWrap = el('div', { className: 'grid' });

      section.append(h2, meta, err, providersWrap);
      container.appendChild(section);
      return { section, meta, err, providersWrap };
    }

    function makeProviderBlock(provider) {
      const block = el('div', { className: 'provider-block' });
      const head = el('div', { className: 'provider-head' });
      const badge = el('span', { className: 'badge', text: provider });
      const name = el('span', { className: 'provider-name', text: 'Dimensions' });
      const status = el('span', { className: 'provider-status', text: 'Waiting…' });
      const grid = el('div', { className: 'provider-grid' });

      head.append(badge, name, el('span', { className: 'muted', text: '·' }), status);
      block.append(head, grid);
      return { block, status, grid };
    }

    function renderDimensionCard(idx, dim, domain, provider) {
      const card = el('details');
      const title = dim.title || dim.name || 'Untitled';
      const sum = el('summary', { text: `${idx + 1}. ${title}` });

      const thesisText = dim.description || dim.thesis || '';
      const thesis = el('div', { className: 'thesis', text: thesisText });

      const targetsList = el('ul', { className: 'targets' });
      (Array.isArray(dim.targets) ? dim.targets : []).forEach(t => {
        targetsList.appendChild(el('li', { text: t }));
      });

      const seedBox = el('div', { className: 'seedbox' });
      const seedHeader = el('div', { className: 'seed-title', html: `Seeds <span class="badge">${provider}</span>` });
      const seedStatus = el('div', { className: 'muted', text: 'Waiting…' });
      const seedWrap = el('div');

      seedBox.append(seedHeader, seedStatus, seedWrap);
      card.append(sum, thesis, targetsList, seedBox);

      card._seedPayload = {
        domain,
        dimension: dim.name || dim.title || '',
        description: thesisText,
        targets: Array.isArray(dim.targets) ? dim.targets : [],
        provider,
        email: currentEmail()
      };

      card._seedUI = { seedStatus, seedWrap };

      card._dimId = dim.id || null;          // <-- dimension id from backend
      card._narrativeId = null;              // <-- filled later in runProviderForDomain
      return card;
    }

    // ---------- seeds (create via provider) ----------
    async function createSeedsForDimension(payload, ui, extras, tries = 2) {
      const { seedStatus, seedWrap } = ui;
      const { narrativeId, dimensionId } = extras || {};
      const seedsRendered = [];

      try {
        seedStatus.textContent = 'Generating seeds…';
        const data = await postJSON('/api/narrative-seeds', payload, 180000);
        seedStatus.textContent = '';

        if (Array.isArray(data.seeds)) {
          if (!data.seeds.length) { seedStatus.textContent = 'No seeds returned.'; return; }

          data.seeds.forEach(s => {
            // Build anchor to dirt.html with whatever we have; upgrade to sid later if missing
            const href = linkHref(narrativeId, dimensionId, s.id || null);
            const a = el('a', { className: 'seedlink', attrs: { href, target: '_blank', rel: 'noopener' } });

            const seed = el('div', { className: 'seed' });
            seed.innerHTML =
              `<strong>A (Problem):</strong> ${escapeHtml(s.problem || '')}<br>` +
              `<strong>B (Objective):</strong> ${escapeHtml(s.objective || '')}<br>` +
              `<strong>Solution (Link):</strong> ${escapeHtml(s.solution || '')}` +
              (s.provider ? `<br><small>provider: ${escapeHtml(s.provider)}</small>` : '') +
              (s.created_at ? `<br><small>${escapeHtml(s.created_at)}</small>` : '');

            // Keep raw fields for post-match if id was not returned
            seed.dataset.problem = (s.problem || '');
            seed.dataset.objective = (s.objective || '');
            seed.dataset.solution = (s.solution || '');
            seed.dataset.hasId = s.id ? '1' : '0';

            a.appendChild(seed);
            seedWrap.appendChild(a);
            seedsRendered.push(a);
          });

          // If any seed ids were missing, reconcile against canonical GET list
          if (dimensionId && seedsRendered.some(a => a.firstChild?.dataset?.hasId === '0')) {
            await reconcileSeedLinks(narrativeId, dimensionId, seedsRendered);
          }
        } else if (data.raw) {
          const pre = el('pre'); pre.textContent = data.raw;
          seedWrap.appendChild(pre);
          seedStatus.textContent = 'Model returned raw text; parsing failed upstream.';
        } else {
          const pre = el('pre'); pre.textContent = JSON.stringify(data, null, 2);
          seedWrap.appendChild(pre);
          seedStatus.textContent = 'Unexpected response shape.';
        }
      } catch (e) {
        if (tries > 0) {
          seedStatus.textContent = 'Retrying…';
          await sleep(1200);
          return createSeedsForDimension(payload, ui, extras, tries - 1);
        }
        seedStatus.className = 'seed-error';
        seedStatus.textContent = `Seed request failed: ${e.message || e}`;
      }
    }


    // ---------- one provider run for a domain ----------
    async function runProviderForDomain(domain, provider, providerUI) {
      const { status, grid } = providerUI;
      status.textContent = 'Generating dimensions…';

      let dimData;
      try {
        const em = currentEmail();
        dimData = await postJSON('/api/narrative-dimensions', { domain, provider, email: em }, 180000);
      } catch (e) {
        status.textContent = `Failed: ${e.message || e}`;
        return;
      }

      const dims = Array.isArray(dimData?.dimensions) ? dimData.dimensions : [];
      status.textContent = `Dimensions: ${dims.length}`;
      if (!dims.length) return;

      // Resolve narrative id (by title) once
      const narrativeId = getNarrativeIdForTitle(dimData.domain || domain);

      const cards = dims.map((dim, idx) => {
        const card = renderDimensionCard(idx, dim, dimData.domain || domain, provider);
        card._narrativeId = narrativeId || null;
        grid.appendChild(card);
        return card;
      });

      let i = 0, ok = 0, fail = 0;
      async function seedWorker() {
        while (i < cards.length) {
          const idx = i++;
          const card = cards[idx];
          try {
            await createSeedsForDimension(
              card._seedPayload,
              card._seedUI,
              { narrativeId: card._narrativeId, dimensionId: card._dimId }
            );
            ok++;
            status.textContent = `Seeds: ${ok}/${cards.length}${fail ? ` (${fail} failed)` : ''}`;
          } catch {
            fail++;
            status.textContent = `Seeds: ${ok}/${cards.length} (${fail} failed)`;
          }
        }
      }
      await Promise.all(
        Array.from({ length: Math.min(MAX_SEED_CONCURRENCY, cards.length) }, () => seedWorker())
      );
      status.textContent = `Done — dims ${cards.length}, seeds ${ok}/${cards.length}${fail ? `, ${fail} failed` : ''}`;
    }

    // Save button: persist email locally
    saveEmailBtn?.addEventListener('click', () => {
      const em = (document.getElementById('emailInput')?.value || '').trim().toLowerCase();
      if (!em) { alert('Enter an email to save.'); return; }
      saveEmailToStorage(em);
      const old = saveEmailBtn.textContent;
      saveEmailBtn.textContent = 'Saved';
      setTimeout(() => { saveEmailBtn.textContent = old; }, 1200);
    });



    // ---------- orchestrator ----------
    form.addEventListener('submit', async (e) => {
      const emAtSubmit = currentEmail();
      if (emAtSubmit) saveEmailToStorage(emAtSubmit);
      e.preventDefault();
      container.innerHTML = '';
      globalStatus.textContent = '';

      const em = currentEmail();
      if (!em) {
        globalStatus.textContent = 'No email entered — results will be generated but NOT saved.';
      }

      const domains = (multiDomainsInput.value || '')
        .split('\n').map(s => s.trim()).filter(Boolean);

      if (!domains.length) {
        globalStatus.textContent = 'Please enter at least one domain.';
        return;
      }

      const selectedProviders = getSelectedProviders();
      if (!selectedProviders.length) {
        globalStatus.textContent = 'Please select at least one provider.';
        return;
      }

        // NEW: load narratives once so we can deep-link with IDs
      try { await ensureNarrativesCache(); } catch { /* non-fatal */ }

      for (let di = 0; di < domains.length; di++) {
        const domain = domains[di];
        globalStatus.textContent = `Processing ${di + 1} of ${domains.length}: ${domain}`;

        const ui = makeDomainSection(domain);

        // Create blocks for selected providers
        const providerBlocks = {};
        selectedProviders.forEach(p => {
          const pb = makeProviderBlock(p);
          ui.providersWrap.appendChild(pb.block);
          ui.providersWrap.appendChild(el('div', { className: 'pro-sep' }));
          providerBlocks[p] = pb;
        });

        // Run providers sequentially to avoid stampede; switch to Promise.all(...) to parallelize.
        for (const p of selectedProviders) {
          await runProviderForDomain(domain, p, providerBlocks[p]);
        }
      }

      globalStatus.textContent = `Done. Processed ${domains.length} domain(s).`;
    });

    function linkHref(nid, did, sid) {
      const p = new URLSearchParams();
      if (nid) p.set('nid', String(nid));
      if (did) p.set('did', String(did));
      if (sid) p.set('sid', String(sid));
      return `dirt.html${p.toString() ? `?${p.toString()}` : ''}`;
    }
    function norm(s) {
      return String(s || '').replace(/\s+/g,' ').trim().toLowerCase();
    }
    async function reconcileSeedLinks(narrativeId, dimensionId, anchors) {
      try {
        const data = await getJSON(`/api/dimensions/${encodeURIComponent(dimensionId)}/seeds?email=${encodeURIComponent(em)}`);
        const list = Array.isArray(data?.seeds) ? data.seeds : [];
        const byKey = new Map(list.map(row => {
          const k = [row.problem, row.objective, row.solution].map(norm).join('||');
          return [k, row.id];
        }));

        anchors.forEach(a => {
          const seed = a.firstChild;
          if (!seed || seed.dataset.hasId === '1') return; // already has id
          const k = [seed.dataset.problem, seed.dataset.objective, seed.dataset.solution].map(norm).join('||');
          const sid = byKey.get(k);
          if (sid) {
            a.setAttribute('href', linkHref(narrativeId, dimensionId, sid));
            seed.dataset.hasId = '1';
          }
        });
      } catch {
        // If GET fails, leave links at nid/did level.
      }
    }

    prefillEmailFromStorage();
    // initialize “Select all” state (already checked) to non-indeterminate
    allProvidersCb.indeterminate = false;
  </script>
</body>
</html>
