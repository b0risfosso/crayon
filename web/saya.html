<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Company Evaluation Agent</title>
<style>
  :root { color-scheme: light dark; }
  body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; margin: 2rem; }
  h1 { font-size: 1.1rem; margin: 0 0 1rem; }
  .controls { display: flex; gap: .5rem; flex-wrap: wrap; align-items: center; margin-bottom: .5rem; }
  input[type="text"] { padding: .6rem .7rem; min-width: 18rem; border: 1px solid #ccc; border-radius: .5rem; }
  button { padding: .6rem .9rem; border: 0; border-radius: .5rem; cursor: pointer; background: #0b5cff; color: #fff; }
  button[disabled] { opacity: .6; cursor: not-allowed; }
  #status, #llmStatus, #peStatus, #revStatus, #fragStatus, #allStatus { font-size: .9rem; margin: .5rem 0 0; min-height: 1.2em; opacity: .85; }
  pre, textarea { margin-top: .75rem; padding: .75rem; background: rgba(0,0,0,.05); border-radius: .5rem; overflow: auto; width: 100%; }
  textarea { min-height: 200px; }
  .row { display: grid; grid-template-columns: 1fr; gap: 1rem; }
  @media (min-width: 900px) { .row { grid-template-columns: 1fr 1fr; } }
  details { margin-top: .75rem; }
</style>
</head>
<body>
  <h1>cea (Company Evaluation Agent)</h1>

  <p>Search company (using company name or stock ticker) and return Moat Score™, Performance Pulse™, and Fragility Rating™</p>

  <div class="controls">
    <input id="q" type="text" placeholder="e.g., Apple, Salesforce, Spotify" required autofocus />
    <button id="go">Run Backbone & Analyses</button>
    <button id="cancel" disabled>Cancel</button>
  </div>

  <div id="status"></div>
  <div id="allStatus" style="font-size:.9rem; margin-top:.4rem; opacity:.85; min-height:1.2em;"></div>
  <pre id="out">{}</pre>

  <hr style="margin:1.25rem 0" />
  <h1>Moat Score™</h1>
  <div class="row">
    <div>
      <div id="llmStatus"></div>
      <pre id="llmOut"><!-- LLM JSON will appear here --></pre>
    </div>
  </div>

  <hr style="margin:1.25rem 0" />
  <h1>Performance Pulse™</h1>

  <div>
    <div id="peStatus"></div>
    <pre id="peOut"><!-- P/E JSON will appear here --></pre>
  </div>

  <div style="margin-top:1.5rem">
    <div id="revStatus"></div>
    <pre id="revOut"><!-- Revenue JSON will appear here --></pre>
  </div>

  <hr style="margin:1.25rem 0" />
  <h1>Fragility Rating™</h1>
  <div class="row">
    <div>
      <div id="fragStatus"></div>
      <pre id="fragOut"><!-- Fragility JSON will appear here --></pre>
    </div>
  </div>

<script>
(() => {
  const $ = s => document.querySelector(s);
  const input = $("#q"), out = $("#out"), status = $("#status");
  const goBtn = $("#go"), allStatus = $("#allStatus");
  const llmOut = $("#llmOut"), llmStatus = $("#llmStatus");
  const peOut = $("#peOut"), peStatus = $("#peStatus");
  const revOut = $("#revOut"), revStatus = $("#revStatus");
  const fragOut = $("#fragOut"), fragStatus = $("#fragStatus");
  const cancelBtn = document.querySelector('#cancel');

  const pretty = o => JSON.stringify(o, null, 2);

  async function fetchJson(url, {signal, method = 'GET', body} = {}) {
    const res = await fetch(url, {
      credentials: "include",
      signal, method,
      headers: { 'Content-Type': 'application/json' },
      body
    });
    const text = await res.text();
    const info = { url, status: res.status, ok: res.ok, raw: text };
    try {
      const data = JSON.parse(text);
      if (!res.ok) throw Object.assign(new Error(data?.detail || res.statusText), { ...info, data });
      return data;
    } catch {
      if (!res.ok) throw Object.assign(new Error("Non-JSON response"), info);
      // Successful but non-JSON
      return { raw: text };
    }
  }


  const LLM_ENDPOINT = '/api/moat_evaluation';
  const CANCEL_ENDPOINT = (rid) => `/api/cancel/${encodeURIComponent(rid)}`;


  const inflight = new Map(); // rid -> { controller, label }

  // keep the button enabled only when there are in-flight tasks
  function updateCancelBtn() {
    try { cancelBtn.disabled = (inflight.size === 0); }
    catch { cancelBtn.disabled = true; } // if inflight isn't defined yet
  }


  async function postPrompt(prompt, {signal} = {}) {
    return await fetchJson(LLM_ENDPOINT, {
      method: 'POST',
      signal,
      body: JSON.stringify({ prompt })
    });
  }

  function newRid() {
  return (crypto && crypto.randomUUID) ? crypto.randomUUID() :
         'rid_' + Math.random().toString(36).slice(2);
  }


  function registerInflight(rid, controller, label) {
    inflight.set(rid, { controller, label });
    updateCancelBtn(); // <-- add this
  }

  function dropInflight(rid) {
    inflight.delete(rid);
    updateCancelBtn(); // <-- add this
  }

  // Send best-effort cancel to server even during unload
  function beaconCancel(rid) {
    const url = `/api/cancel/${encodeURIComponent(rid)}`;

    try {
      // Minimal payload to satisfy some servers; MIME type shouldn't matter
      const ok = navigator.sendBeacon(url, new Blob([], { type: 'text/plain' }));
      if (!ok) throw new Error('beacon refused');
    } catch {
      // Fallback for Safari/edge cases: keepalive POST with cookies
      fetch(url, {
        method: 'POST',
        credentials: 'include',   // send session cookie
        keepalive: true,          // allows request to complete during unload
        headers: { 'Content-Type': 'text/plain' },
        body: ''                  // no JSON required
      }).catch(() => {/* ignore */});
    }
  }


  // Abort + beacon for all
  function cancelAllInflight() {
    for (const [rid, { controller }] of inflight.entries()) {
      console.log('[LLM CANCEL] rid=', rid, 'label=', label);
      try { controller.abort(); } catch {}
      beaconCancel(rid);
      inflight.delete(rid);
    }
    updateCancelBtn(); // <-- add this
  }

  cancelBtn.addEventListener('click', () => {
    // Optional: reflect cancelling in the UI immediately
    const sEls = [document.querySelector('#llmStatus'),
                  document.querySelector('#peStatus'),
                  document.querySelector('#revStatus'),
                  document.querySelector('#fragStatus'),
                  document.querySelector('#allStatus')].filter(Boolean);
    sEls.forEach(el => { if (el && el.textContent) el.textContent = 'Cancelling…'; });
    

    // Abort on the client and notify server
    try { cancelAllInflight(); } catch {}

    // Disable button now; it'll stay disabled until new tasks are started
    updateCancelBtn();
  });

  updateCancelBtn();


  // Auto-cancel on navigation/reload/close (covers bfcache too)
  window.addEventListener('pagehide', cancelAllInflight, { capture: true });
  window.addEventListener('beforeunload', cancelAllInflight, { capture: true });


  // ---- Wrapped LLM poster that supports cancel ----
  async function postPromptCancellable({ prompt, label }) {
    const rid = newRid();
    const controller = new AbortController();
    registerInflight(rid, controller, label);
    console.log('[LLM START]', label, 'rid=', rid);

    try {
      const res = await fetch(LLM_ENDPOINT, {
        method: 'POST',
        credentials: 'include',
        signal: controller.signal,
        // keepalive allows long POSTs in the unload phase (fallback; beacon is primary)
        keepalive: true,
        headers: { 'Content-Type': 'application/json', 'X-Request-Id': rid },
        body: JSON.stringify({ prompt, rid, tool: label })
      });

      const txt = await res.text();
      // attempt JSON, show detailed error otherwise
      let data;
      try { data = JSON.parse(txt); } catch { data = { raw: txt }; }
      if (!res.ok) {
        const err = new Error(data?.detail || res.statusText);
        err.status = res.status; err.data = data; err.url = LLM_ENDPOINT;
        throw err;
      }
      return data;
    } finally {
      dropInflight(rid);
    }
  }



  function makeTimer(el, label='Thinking/Searching'){
    let start=0, id=null;
    const fmt = s => `${label}… ${s}s`;
    return {
      start(){ start=Date.now(); el.textContent = fmt(0);
        id=setInterval(()=>{ el.textContent = fmt(Math.floor((Date.now()-start)/1000)); },1000);
      },
      stop(msg){ if(id) clearInterval(id); if(msg) el.textContent = msg; }
    };
  }

  
  async function runOne({label, prompt, statusEl, outEl}) {
    const timer = makeTimer(statusEl, label);
    outEl.textContent = '';
    timer.start();

    try {
      const data = await postPromptCancellable({ prompt, label });
      const text = typeof data?.output_text === 'string'
        ? data.output_text
        : (data.raw || JSON.stringify(data));
      outEl.textContent = text;
      timer.stop('Done.');
    } catch (err) {
      outEl.textContent = JSON.stringify({
        error: err?.message || `${label} failed`,
        status: err?.status ?? null,
        url: err?.url ?? null,
        data: err?.data ?? null
      }, null, 2);
      timer.stop('Failed.');
    }
  }


  // ---- Concurrency limiter (2 at a time) ----
  async function runWithLimit(tasks, limit=2){
    const results = new Array(tasks.length);
    let i = 0;
    async function worker(){
      while (i < tasks.length){
        const idx = i++;
        try { results[idx] = await tasks[idx](); }
        catch (e){ results[idx] = e; }
      }
    }
    const workers = Array.from({length: Math.min(limit, tasks.length)}, worker);
    await Promise.all(workers);
    return results;
  }

  function pickTicker(bb){
    const arr = Array.isArray(bb?.tickers) ? bb.tickers : [];
    if (arr.length && arr[0]?.symbol) return arr[0].symbol.toUpperCase();
    return null;
  }

  function buildMoatPrompt(companyJson) {
    const bb = companyJson?.backbone || {};
    const name = bb.canonical_name || companyJson?.query || "<unknown>";
    const aliases = Array.isArray(bb.aliases) ? bb.aliases : [];
    const domain = bb.domain || "";

    let scopeLine = `Task: Produce a Moat Score for the company referenced in the JSON (focus on ${name}).`;
    const looksLikeSlack = /slack/i.test(domain) || aliases.some(a => /slack/i.test(a));
    const looksLikeSalesforce = /salesforce/i.test(name);
    if (looksLikeSlack && looksLikeSalesforce) {
      scopeLine = `Task: Produce a Moat Score focusing on the Slack product/business within Salesforce (CRM). Where appropriate, distinguish Slack-specific vs. Salesforce corporate-level dynamics.`;
    }

    const prompt = `\nYou are an equity research assistant. Use web search to verify all claims and provide citations.\nCompany input (JSON):\n${pretty(companyJson)}\n\n${scopeLine}\nScore nine criteria (0–10 each), with 1–3 sentences of rationale per criterion and reputable citations ("receipts"). Then provide a short synthesis explaining the overall moat.\n\nScoring criteria (each 0–10):\n1) Market leadership & sustainable share\n2) Network effects & switching costs\n3) Valuable IP & patents\n4) Brand strength & customer loyalty\n5) Durable cost advantages (scale, proprietary tech)\n6) Regulatory barriers & exclusive licenses\n7) Distribution network (direct, partners, enterprise channel)\n8) Pricing power (sustained ability to raise price/mix)\n9) Consistent, impactful innovation & R&D\n\nOutput format (JSON only):\n{\n  "moat_score": <0-100 integer, average of the 9 criteria × 10, round to nearest whole>,\n  "criteria": [ ... ],\n  "summary": "<3–5 sentence synthesis>",\n  "notes": {\n    "what_is_scope": "${looksLikeSlack && looksLikeSalesforce ? 'Slack within Salesforce' : name}",\n    "data_as_of": "<today’s date in YYYY-MM-DD>",\n    "method": "Each criterion scored 0–10 using public sources; average × 10 → Moat Score."\n  }\n}\n\nInstructions & constraints:\n- Treat the JSON as the resolved identity.\n- ALWAYS use web_search to confirm market share, DAU/MAU, retention, pricing, competition, distribution/partners, and regulatory issues.\n- Prefer primary/authoritative sources (investor materials, regulatory docs, Gartner/IDC/Forrester, WSJ/FT/Bloomberg).\n- Provide ≥1 citation per criterion (≥2 for market share & network effects).\n- Keep each rationale crisp (≤60 words). Avoid marketing language. Do not output anything except the JSON block.`;
    return prompt;
  }

  function buildPEPrompt(companyJson){
    const bb = companyJson?.backbone || {};
    const aliases = Array.isArray(bb.aliases) ? bb.aliases : [];
    const ticker = pickTicker(bb);
    const isSlackInsideSalesforce = (/slack/i.test(bb?.domain||"") || aliases.some(a=>/slack/i.test(a))) && /salesforce/i.test(bb?.canonical_name||"");
    const parentTicker = isSlackInsideSalesforce ? 'CRM' : (ticker || 'N/A');
    const pyLikeJSON = pretty({ query: companyJson.query, backbone: bb });

    const prompt = `\nYou are a capital-markets analyst. Use web_search to retrieve fresh figures and cite your sources.\n\nCompany input (JSON):\n${pyLikeJSON}\n\nTask: Return **Price/Earnings (P/E) ratios** for the *public parent issuer*. Detected ticker: **${parentTicker}**. Report: PE 2Y ago, PE 1Y ago, Trailing P/E (current TTM), Forward P/E (FY+1), 2-Year Forward P/E (FY+2).\n\n**Requirements**\n1) Identity resolution as above. If private, return N/A with explanation.\n2) Sources: Macrotrends, Yahoo/Nasdaq, filings, or major financial press. Direct URLs.\n3) Method: use a single current price source; anchor historical to nearest quarter-ends; show EPS used for forward P/Es.\n\n**Output format (JSON only)**:\n{ ... same as your spec ... }\n\nConstraints:\n- Output only the JSON block.`;
    return prompt;
  }

  function buildRevenuePrompt(companyJson){
    const bb = companyJson?.backbone || {};
    const aliases = Array.isArray(bb.aliases) ? bb.aliases : [];
    const isSlackInsideSalesforce = (/slack/i.test(bb?.domain||"") || aliases.some(a=>/slack/i.test(a))) && /salesforce/i.test(bb?.canonical_name||"");
    const pyLikeJSON = pretty({ query: companyJson.query, backbone: bb });

    const prompt = `\nYou are a capital-markets analyst bot. Use web_search to pull authoritative figures and citations.\n\nCompany input (JSON):\n${pyLikeJSON}\n\nObjective:\nReturn the company's **Trailing 12-Month (TTM) revenue** and **TTM revenue YoY growth** for the **last 17 fiscal quarters**, plus **projected revenues for the next 4 quarters**. If the input refers to a product/brand inside a public parent${isSlackInsideSalesforce ? ' (Slack inside Salesforce)' : ''}, compute using the **public parent ticker**. If the entity is private and does not publish quarterly financials, return an explanation and do not fabricate numbers.\n\nKey rules:\n1) Identity resolution as above.\n2) Use the company's own reporting basis for top-line and keep it consistent. State the basis.\n3) TTM computation: sum last 4 quarters; YoY vs TTM 4 quarters prior; align to fiscal quarters.\n4) Sources preference: filings/press releases/IR; SEC; reputable aggregators; direct URLs.\n5) Forecasts: quarterly consensus; if only annual, distribute by seasonality with explanation; else nulls.\n6) Currency/units: return currency and common unit; include fiscal quarter end dates.\n7) Data as-of: include retrieval timestamp and most recent quarter label.\n8) No fabrication: if private with no data, explain and leave arrays empty.\n\nOutput format (JSON only):\n{ ... same as your spec ... }\n\nConstraints:\n- Use web_search to find sources for every number.\n- Do not output anything except the JSON block.`;
    return prompt;
  }

  function buildFragilityPrompt(companyJson){
    const bb = companyJson?.backbone || {};
    const pyJson = JSON.stringify({ query: companyJson.query, backbone: bb }, null, 2);
    return `
You are a forensic-equity and credit risk analyst. Use web_search to verify all claims and provide citations.
Your task: compute a **Fragility Rating** for the resolved entity in the JSON below. If the input refers to a product/brand,
map to the public parent issuer for financials. If the company is private and lacks disclosures, return N/A for
quantitative fields and provide a qualitative read with sources.

Company input (JSON):
${pyJson}

## Definition — Fragility Rating (0–100; higher = more fragile)
Aggregate nine sub-scores (0–10 each), then scale: Fragility Rating = round( average(subscores) * 10 ).
Also report a **Confidence (0–100)** reflecting data quality/coverage.

### Sub-score dimensions (0–10 each)
1) **Leverage & Coverage Risk** — Net debt / EBITDA, interest coverage (EBIT/Interest), debt maturity wall ≤ 36 months.
   - Scoring guide: 0–2 (net cash, IC > 8×), 3–5 (ND/EBITDA 0–1.5×, IC 4–8×), 6–8 (1.5–3×, IC 2–4×), 9–10 (>3×, IC < 2× or maturities bunching).
2) **Liquidity & Cash Burn** — Cash runway (cash + undrawn RCF vs. FCF burn), working-cap volatility, revolver usage.
3) **Revenue Concentration** — Top customer % of revenue; top-3 product or geo concentration; dependency on single platform/distributor.
4) **Margin Volatility & Operating Leverage** — Gross/EBIT margin variance (5y), fixed/variable cost mix, cyclicality.
5) **Regulatory/Legal Exposure** — Active investigations, fines, licensing risk, DSA/DMA/antitrust, sector-specific caps.
6) **Supply Chain & Key-Supplier Dependence** — Single-source inputs, commodity exposure, logistics/geopolitical chokepoints.
7) **Key-Man/Talent & Org Fragility** — Founder/CEO dependence, attrition spikes, union actions, immigration dependencies.
8) **Competitive Moat Erosion Risk** — Switching costs, network effects pressure, disruptive entrants, pricing power erosion.
9) **Non-GAAP/Quality-of-Earnings Risk** — Aggressive adjustments, capitalized costs, stock-comp reliance, working-cap driven FCF.

### Data requirements & methods
- **Primary sources first**: 10-K/20-F/10-Q, earnings PRs, IR decks, audited financials; then EDGAR; then top-tier press/industry (FT, WSJ, Bloomberg, Reuters), then reputable aggregators (MarketScreener, Macrotrends, Yahoo/Nasdaq for consensus).
- Compute most recent **TTM** metrics for leverage, coverage, margins; disclose formulas and values used.
- For concentration, cite disclosed customer % (or state “not disclosed” and infer *qualitatively* from contracts/management commentary).
- Flag **binary red flags**: covenant breaches, going-concern language, auditor emphasis, material weaknesses in ICFR, credit downgrades, covenant-lite term loans with ticking maturities, large legal contingencies.
- If numbers differ across sources, pick the most authoritative and mention the range.

### Output format (JSON only)
{
  "entity": {
    "name": "<resolved entity name>",
    "ticker": "<ticker or 'N/A'>",
    "is_public": <true|false>,
    "reporting_currency": "<e.g., USD>"
  },
  "as_of": "<YYYY-MM-DD HH:MM TZ>",
  "inputs_used": {
    "periods": ["<TTM end date>", "<prior periods if used>"],
    "source_docs": ["<primary filing/url>", "<supporting urls>"]
  },
  "metrics": {
    "net_debt_to_ebitda": <float or "N/A">,
    "interest_coverage": <float or "N/A">,
    "debt_maturities_0_36m": "<brief text or 'N/A'>",
    "cash_and_rcf_liquidity": "<value + brief method or 'N/A'>",
    "cash_runway_months": <float or "N/A">,
    "top_customer_revenue_pct": <float or "N/A">,
    "top_geo_revenue_pct": <float or "N/A">,
    "gross_margin_ttm": <float or "N/A">,
    "ebit_margin_ttm": <float or "N/A">,
    "margin_volatility_5y_std": <float or "N/A">
  },
  "subscores": [
    {"name":"Leverage & Coverage Risk","score":<0-10>,"rationale":"<≤60 words>","citations":["<url1>","<url2>"]}},
    {"name":"Liquidity & Cash Burn","score":<0-10>,"rationale":"<≤60 words>","citations":["<url1>"]}},
    {"name":"Revenue Concentration","score":<0-10>,"rationale":"<≤60 words>","citations":["<url1>"]}},
    {"name":"Margin Volatility & Op. Leverage","score":<0-10>,"rationale":"<≤60 words>","citations":["<url1>"]}},
    {"name":"Regulatory/Legal Exposure","score":<0-10>,"rationale":"<≤60 words>","citations":["<url1>"]}},
    {"name":"Supply Chain & Supplier Dependence","score":<0-10>,"rationale":"<≤60 words>","citations":["<url1>"]}},
    {"name":"Key-Man/Talent & Org Fragility","score":<0-10>,"rationale":"<≤60 words>","citations":["<url1>"]}},
    {"name":"Moat Erosion Risk","score":<0-10>,"rationale":"<≤60 words>","citations":["<url1>"]}},
    {"name":"Non-GAAP/Quality-of-Earnings Risk","score":<0-10>,"rationale":"<≤60 words>","citations":["<url1>"]}}
  ],
  "fragility_rating": <0-100>,
  "confidence": <0-100>,
  "red_flags": [
    "<e.g., going-concern language>",
    "<e.g., auditor emphasis paragraph>",
    "<e.g., covenant breach disclosure>"
  ],
  "summary": "<3–6 sentence synthesis: where fragility concentrates, catalysts in next 12–18 months, what could de-risk the profile>"
}

### Strict constraints
- ALWAYS use web_search to retrieve/confirm figures and link to exact filings/articles.
- Do NOT fabricate undisclosed customer percentages or debt schedules—state 'not disclosed' and assess qualitatively.
- Keep every rationale concise (≤60 words). Provide at least one citation per subscore.
- Output **only** the JSON block. No prose outside JSON.

Return only the JSON.`;
  }

  async function runPipeline() {
    const name = input.value.trim();
    if (!name) { input.focus(); return; }

    // Reset UI
    status.textContent = "Fetching backbone…";
    allStatus.textContent = "";
    [llmOut, peOut, revOut, fragOut].forEach(el => el.textContent = "");
    [llmStatus, peStatus, revStatus, fragStatus].forEach(el => el.textContent = "");
    out.textContent = "{}";
    goBtn.disabled = true;

    // Backbone lookup (keep your existing /api/backbone code)
    const ctl = new AbortController();
    const t = setTimeout(() => ctl.abort(), 180000);
    try {
      const u = new URL("/api/backbone", window.location.origin);
      u.searchParams.set("company_name", name);
      const bb = await fetchJson(u.toString(), { signal: ctl.signal });
      const companyJson = { query: name, backbone: bb };
      out.textContent = pretty(companyJson);
      status.textContent = "Backbone: Done.";

      // Build prompts
      const moatPrompt = buildMoatPrompt(companyJson);
      const pePrompt   = buildPEPrompt(companyJson);
      const revPrompt  = buildRevenuePrompt(companyJson);
      const fragPrompt = buildFragilityPrompt(companyJson);

      allStatus.textContent = "Running all analyses… (2 at a time)";
      // Prepare tasks but do NOT start yet
      const tasks = [
        () => runOne({ label: 'Moat Score™',                    prompt: moatPrompt, statusEl: llmStatus,  outEl: llmOut }),
        () => runOne({ label: 'Performance Pulse™ – Valuation', prompt: pePrompt,   statusEl: peStatus,   outEl: peOut }),
        () => runOne({ label: 'Performance Pulse™ – Revenue',   prompt: revPrompt,  statusEl: revStatus,  outEl: revOut }),
        () => runOne({ label: 'Fragility Rating™',              prompt: fragPrompt, statusEl: fragStatus, outEl: fragOut }),
      ];

      const results = await runWithLimit(tasks, 2);
      const anyError = results.some(r => r instanceof Error);
      allStatus.textContent = anyError ? "Finished with errors." : "All analyses complete.";
    } catch (err) {
      out.textContent = pretty({
        error: err?.message || "Backbone request failed",
        url: err?.url || "/api/backbone",
        status: err?.status ?? null,
        raw: err?.raw ?? null
      });
      status.textContent = "Backbone: Failed.";
    } finally {
      clearTimeout(t);
      goBtn.disabled = false;
    }
  }

  // Single entrypoint: click or press Enter
  goBtn.addEventListener('click', runPipeline);
  input.addEventListener("keydown", (e) => { if (e.key === "Enter") runPipeline(); });
})();
</script>
</body>
</html>
