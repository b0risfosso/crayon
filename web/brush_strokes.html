<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Brush Strokes</title>
  <style>
    body { margin: 0; font-family: "Inter", "Segoe UI", sans-serif; background: #f6f7fb; color: #111; }
    .page { max-width: 1100px; margin: 0 auto; padding: 20px; }
    h1 { margin: 0 0 8px 0; }
    .muted { color: #6b7280; font-size: 13px; }
    .card {
      background: #fff;
      border: 1px solid #dfe3eb;
      border-radius: 12px;
      padding: 14px;
      box-shadow: 0 12px 40px rgba(0,0,0,0.04);
      margin-bottom: 14px;
    }
    .section-title { display:flex; justify-content: space-between; align-items:center; gap:10px; }
    textarea {
      width: 100%; box-sizing: border-box; padding: 10px;
      border-radius: 8px; border: 1px solid #dfe3eb; font-family: inherit;
      background: #f9fafb;
    }
    .art-block { white-space: pre-wrap; border: 1px solid #e5e7eb; background: #f9fafb; border-radius: 8px; padding: 10px; margin-top: 8px; }
    .controls { display:flex; gap: 8px; align-items:center; flex-wrap: wrap; }
    button { padding: 8px 12px; border-radius: 8px; border: 1px solid #dfe3eb; background: #fff; cursor: pointer; font-weight: 600; }
    button.primary { background: #1f7ae0; color: #fff; border-color: #1f7ae0; }
    button:disabled { opacity: 0.6; cursor: not-allowed; }
    input[type="number"] { width: 80px; padding: 6px 8px; border-radius: 6px; border: 1px solid #dfe3eb; }
    .list { display: flex; flex-direction: column; gap: 8px; margin-top: 10px; }
    .pill { display:inline-block; padding:4px 8px; border-radius: 999px; background:#eef2ff; border:1px solid #dcdffa; font-size:12px; color:#3847a3; }
    .status { font-size: 12px; color: #333; white-space: pre-wrap; margin-top: 6px; }
    .dirt-item, .instrument-item { border:1px solid #e5e7eb; border-radius:10px; padding:8px 10px; background:#fff; }
    .output { white-space: pre-wrap; margin-top: 6px; border-top:1px solid #eee; padding-top:6px; }
    details.collapsible { border: 1px solid #e5e7eb; border-radius: 10px; padding: 8px 10px; background: #fff; }
    summary.chevron { cursor: pointer; display: flex; align-items: center; gap: 8px; list-style: none; font-weight: 700; }
    summary.chevron::-webkit-details-marker { display: none; }
    .chev { font-size: 12px; color: #666; }
  </style>
</head>
<body>
  <div class="page">
    <h1>Brush Strokes</h1>
    <div class="muted" id="crumbs"></div>

    <div class="card">
      <div class="section-title">
        <h2 style="margin:0;">Art & Color</h2>
        <div class="controls">
          <button onclick="window.open('make-art.html', '_blank')">Back to Art</button>
          <button onclick="refreshAll()">Refresh</button>
        </div>
      </div>
      <div class="muted">Art</div>
      <div id="art-meta" class="muted"></div>
      <div id="art-text" class="art-block">Loading art…</div>
      <div class="muted" style="margin-top:8px;">Color (build_thought)</div>
      <div id="color-meta" class="muted"></div>
      <div id="color-text" class="art-block">Loading color…</div>
    </div>

    <div class="card">
      <div class="section-title">
        <h2 style="margin:0;">Create Dirt</h2>
        <div class="muted">Randomly run N analyses</div>
      </div>
      <div class="controls" style="margin-top:6px;">
        <label class="muted">N <input id="numAnalyses" type="number" min="1" max="10" value="3" /></label>
        <button class="primary" id="createDirtBtn" onclick="createRandomDirt()">Create dirt</button>
      </div>
      <!-- Hide analysis catalog from view but keep for selection -->
      <div id="analysisList" class="list" style="display:none;"></div>
      <div id="dirtStatus" class="status"></div>
    </div>

    <div class="card">
      <div class="section-title">
        <h2 style="margin:0;">Dirt</h2>
        <div class="controls">
          <label class="muted">M dirt <input id="numDirt" type="number" min="1" max="20" value="2" /></label>
          <label class="muted">P instruments <input id="numInstruments" type="number" min="1" max="10" value="2" /></label>
          <button class="primary" id="brushBtn" onclick="createBrushStrokes()">Create brush strokes</button>
        </div>
      </div>
      <details class="collapsible" id="dirtDetails">
        <summary class="chevron"><span class="chev">▸</span> Dirt / Analyses</summary>
        <div id="dirtList" class="list" style="margin-top:8px;">Loading dirt…</div>
      </details>

      <details class="collapsible" id="instrumentDetails" style="margin-top:10px;">
        <summary class="chevron"><span class="chev">▸</span> Instruments</summary>
        <div class="muted" style="margin-top:6px;">Loaded from /instruments</div>
        <div id="instrumentList" class="list" style="margin-top:6px;"></div>
      </details>

      <div id="brushStatus" class="status"></div>

      <details class="collapsible" id="outputsDetails" style="margin-top:10px;">
        <summary class="chevron"><span class="chev">▸</span> Brush Strokes / Scenarios</summary>
        <div id="brushOutputs" class="list" style="margin-top:8px;"></div>
      </details>
    </div>
  </div>

  <script>
    const params = new URLSearchParams(window.location.search);
    const artId = parseInt(params.get('art_id') || '', 10);
    const colorId = parseInt(params.get('color_id') || '', 10);
    const ANALYSES = [
      { key: "entities_processes_phenomena", label: "Entities / Processes / Phenomena" },
      { key: "abstractions_metaphors", label: "Abstractions & Metaphors" },
      { key: "processes_forces_interactions", label: "Processes / Forces / Interactions" },
      { key: "theories", label: "Theories" },
      { key: "companies", label: "Companies" },
      { key: "historical_context", label: "Historical Context" },
      { key: "levers", label: "Levers" },
      { key: "intelligence", label: "Intelligence" },
      { key: "experiments", label: "Experiments" },
      { key: "physical_build", label: "Physical Build" },
      { key: "codebases", label: "Codebases" },
      { key: "datasets", label: "Datasets" },
      { key: "value_exchange", label: "Value Exchange" },
      { key: "value_added", label: "Value Added" },
      { key: "science", label: "Science" },
      { key: "heart", label: "Heart" },
      { key: "environment", label: "Environment" },
      { key: "imagination", label: "Imagination" },
      { key: "music", label: "Music" },
      { key: "infinity", label: "Infinity" },
    ];

    let artText = "";
    let colorText = "";
    let colorBoxSlug = "";
    let dirtRows = [];
    let instruments = [];
    let savedBrushStrokes = [];

    if (!artId || !colorId) {
      document.getElementById('art-text').textContent = 'Missing art_id or color_id.';
      document.getElementById('createDirtBtn').disabled = true;
      document.getElementById('brushBtn').disabled = true;
    } else {
      document.getElementById('crumbs').textContent = `Art #${artId} · Color #${colorId}`;
      refreshAll();
    }

    async function refreshAll() {
      await Promise.all([loadArt(), loadColor(), loadDirt(), loadInstruments(), loadSavedBrushStrokes()]);
      renderAnalyses();
    }

    async function loadArt() {
      try {
        const res = await fetch(`/art/api/art/${artId}`);
        const data = await res.json();
        if (!res.ok) throw new Error(data.message || 'Failed to load art');
        artText = data.art || '';
        document.getElementById('art-meta').textContent = `Email: ${data.email || ''} · Created: ${data.created_at || ''}`;
        document.getElementById('art-text').textContent = artText;
      } catch (e) {
        document.getElementById('art-text').textContent = `Error: ${e.message || e}`;
      }
    }

    async function loadColor() {
      try {
        // Fetch all colors (manual + build_thought) for this art, then match by id.
        const res = await fetch(`/colors/by_art/${artId}`);
        const rows = await res.json();
        if (!res.ok) throw new Error(rows.message || 'Failed to load colors');
        const match = (Array.isArray(rows) ? rows : []).find(r => Number(r.id) === colorId);
        if (!match) throw new Error('Color not found for this art');
        colorText = match.output_text || '';
        document.getElementById('color-meta').textContent = `${match.model || ''} · ${match.created_at || ''}`;
        document.getElementById('color-text').textContent = colorText;

        // Ensure a dirt box exists for this color
        const boxRes = await fetch(`/dirt/bridge/color/${colorId}/box`, { method: 'POST' });
        const boxData = await boxRes.json();
        if (!boxRes.ok) throw new Error(boxData.message || boxData.error || 'Failed to ensure dirt box');
        colorBoxSlug = boxData.slug || '';
      } catch (e) {
        document.getElementById('color-text').textContent = `Error: ${e.message || e}`;
        document.getElementById('createDirtBtn').disabled = true;
        document.getElementById('brushBtn').disabled = true;
      }
    }

    async function loadDirt() {
      const list = document.getElementById('dirtList');
      list.textContent = 'Loading dirt…';
      try {
        const res = await fetch(`/dirt/bridge/color/${colorId}/analyses`);
        const rows = await res.json();
        if (!res.ok) throw new Error(rows.message || rows.error || 'Failed to load dirt');
        dirtRows = Array.isArray(rows) ? rows : [];
        renderDirt();
      } catch (e) {
        list.textContent = `Error: ${e.message || e}`;
      }
    }

    async function loadInstruments() {
      const list = document.getElementById('instrumentList');
      list.textContent = 'Loading instruments…';
      try {
        const res = await fetch('/instruments');
        const rows = await res.json();
        if (!res.ok) throw new Error(rows.message || 'Failed to load instruments');
        instruments = Array.isArray(rows) ? rows : [];
        renderInstruments();
      } catch (e) {
        list.textContent = `Error: ${e.message || e}`;
      }
    }

    async function loadSavedBrushStrokes() {
      const list = document.getElementById('brushOutputs');
      list.innerHTML = '';
      try {
        const res = await fetch(`/colors/brush_strokes?art_id=${artId}&color_id=${colorId}`);
        const rows = await res.json();
        if (!res.ok) throw new Error(rows.message || rows.error || 'Failed to load brush strokes');
        savedBrushStrokes = Array.isArray(rows) ? rows : [];
        renderSavedBrushStrokes();
      } catch (e) {
        list.innerHTML = `<div class="status">Error loading brush strokes: ${escapeHtml(e.message || e)}</div>`;
      }
    }

    function renderAnalyses() {
      const container = document.getElementById('analysisList');
      container.innerHTML = '';
      ANALYSES.forEach(a => {
        const div = document.createElement('div');
        div.className = 'dirt-item';
        div.innerHTML = `<strong>${a.label}</strong><div class="muted">${a.key}</div>`;
        container.appendChild(div);
      });
    }

    function renderDirt() {
      const list = document.getElementById('dirtList');
      list.innerHTML = '';
      if (!dirtRows.length) {
        list.textContent = 'No dirt yet for this color.';
        return;
      }
      dirtRows.forEach(d => {
        const div = document.createElement('div');
        div.className = 'dirt-item';

        const header = document.createElement('div');
        header.style.display = 'flex';
        header.style.justifyContent = 'space-between';
        header.style.alignItems = 'center';
        header.style.cursor = 'pointer';
        const title = document.createElement('div');
        title.innerHTML = `<strong>Dirt #${d.id}</strong> <span class="muted">${d.created_at || ''}</span>`;
        const meta = document.createElement('div');
        meta.className = 'muted';
        meta.textContent = d.name || '';
        const caret = document.createElement('span');
        caret.className = 'caret';
        caret.textContent = '▸';
        header.appendChild(title);
        header.appendChild(meta);
        header.appendChild(caret);

        const body = document.createElement('div');
        body.className = 'output';
        body.style.display = 'none';
        body.innerHTML = escapeHtml(d.content || d.output_text || '');

        header.addEventListener('click', () => {
          const open = body.style.display === 'none';
          body.style.display = open ? 'block' : 'none';
          caret.textContent = open ? '▾' : '▸';
        });

        // expand first item by default
        if (dirtRows[0] === d) {
          body.style.display = 'block';
          caret.textContent = '▾';
        }

        div.appendChild(header);
        div.appendChild(body);
        list.appendChild(div);
      });
      // keep collapsed by default
    }

    function renderInstruments() {
      const list = document.getElementById('instrumentList');
      list.innerHTML = '';
      if (!instruments.length) {
        list.textContent = 'No instruments found.';
        return;
      }
      instruments.forEach(inst => {
        const div = document.createElement('div');
        div.className = 'instrument-item';
        div.innerHTML = `
          <div><strong>${escapeHtml(inst.name || '')}</strong> <span class="muted">#${inst.id}</span></div>
          <div class="muted">${escapeHtml(inst.description || '')}</div>
        `;
        list.appendChild(div);
      });
    }

    function randomSubset(arr, n) {
      const copy = [...arr];
      for (let i = copy.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [copy[i], copy[j]] = [copy[j], copy[i]];
      }
      return copy.slice(0, Math.max(0, Math.min(n, copy.length)));
    }

    async function createRandomDirt() {
      const status = document.getElementById('dirtStatus');
      status.textContent = '';
      const n = parseInt(document.getElementById('numAnalyses').value || '0', 10);
      if (!n || !artId || !colorId) return;
      const selected = randomSubset(ANALYSES, n);
      status.textContent = `Running ${selected.length} analyses…`;
      try {
        const res = await fetch(`/dirt/bridge/color/${colorId}/analyses`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ keys: selected.map(a => a.key) })
        });
        const data = await res.json();
        if (!res.ok) throw new Error(data.message || data.error || 'Failed to queue analyses');
        status.textContent = `Queued ${selected.length} analyses. Refreshing shortly…`;
        setTimeout(() => loadDirt(), 3000);
      } catch (e) {
        status.textContent = `Error: ${e.message || e}`;
      }
    }

    async function createBrushStrokes() {
      const status = document.getElementById('brushStatus');
      const outputs = document.getElementById('brushOutputs');
      status.textContent = '';
      outputs.innerHTML = '';
      if (!dirtRows.length || !instruments.length) {
        status.textContent = 'Need dirt and instruments to create brush strokes.';
        return;
      }
      const m = Math.max(1, parseInt(document.getElementById('numDirt').value || '1', 10));
      const p = Math.max(1, parseInt(document.getElementById('numInstruments').value || '1', 10));
      const selectedDirt = randomSubset(dirtRows, m);
      const selectedInstruments = randomSubset(instruments, p);

      status.textContent = `Running ${selectedDirt.length * selectedInstruments.length} instrument synths…`;

      const tasks = [];
      for (const d of selectedDirt) {
        for (const inst of selectedInstruments) {
          tasks.push(
            (async () => {
              try {
                const run = await enqueueBrush(inst, d);
                const result = await pollInstrumentTask(run.task_id);
                renderBrushOutput(outputs, inst, d, result);
              } catch (e) {
                renderBrushOutput(outputs, inst, d, null, e);
              }
            })()
          );
        }
      }

      // Run all in parallel and wait for completion
      await Promise.allSettled(tasks);
      status.textContent = 'Brush strokes complete.';
      openOutputsPanel();
    }

    async function enqueueBrush(inst, dirt) {
      const payload = {
        instrument_id: inst.id,
        system_description: `${artText}\n\nColor:\n${colorText}`,
        system_feature: dirt.content || dirt.output_text || '',
        instrument_name: inst.name,
        instrument_description: inst.description || ''
      };
      const res = await fetch('/instruments/synthesize', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload),
      });
      const data = await res.json();
      if (!res.ok) throw new Error(data.message || 'Failed to enqueue synth');
      return data;
    }

    async function pollInstrumentTask(taskId) {
      while (true) {
        const r = await fetch(`/instruments/llm/tasks/${encodeURIComponent(taskId)}`);
        const t = await r.json();
        if (!r.ok) throw new Error(t.message || 'Task poll failed');
        if (t.status === 'done') return t.result;
        if (t.status === 'error') throw new Error(t.error || 'Task error');
        await new Promise(ok => setTimeout(ok, 1200));
      }
    }

    function renderBrushOutput(container, inst, dirt, result, error) {
      const wrapper = document.createElement('div');
      wrapper.className = 'dirt-item';

      const header = document.createElement('div');
      header.style.display = 'flex';
      header.style.justifyContent = 'space-between';
      header.style.alignItems = 'center';
      header.style.cursor = 'pointer';

      const title = document.createElement('div');
      title.innerHTML = `<strong>${escapeHtml(inst.name || '')}</strong> on dirt #${dirt.id}`;
      const meta = document.createElement('div');
      meta.className = 'muted';
      meta.textContent = error ? 'error' : `Tokens: ${result?.usage?.total_tokens ?? ''}`;
      const caret = document.createElement('span');
      caret.className = 'chev';
      caret.textContent = '▸';

      header.appendChild(title);
      header.appendChild(meta);
      header.appendChild(caret);

      const body = document.createElement('div');
      body.className = 'output';
      body.style.display = 'none';
      body.innerHTML = error
        ? `<div class="status">Error: ${escapeHtml(error.message || error)}</div>`
        : escapeHtml(result?.output || '');

      header.addEventListener('click', () => {
        const open = body.style.display === 'none';
        body.style.display = open ? 'block' : 'none';
        caret.textContent = open ? '▾' : '▸';
      });

      // open first output by default
      if (!container.hasChildNodes()) {
        body.style.display = 'block';
        caret.textContent = '▾';
      }

      wrapper.appendChild(header);
      wrapper.appendChild(body);
      container.appendChild(wrapper);
      // persist to DB if we have a result
      if (!error && result) {
        saveBrushStroke(inst, dirt, result).catch(() => {});
      }
    }

    function renderSavedBrushStrokes() {
      const container = document.getElementById('brushOutputs');
      // Keep existing runtime outputs; append saved ones first
      savedBrushStrokes.forEach(row => {
        const wrapper = document.createElement('div');
        wrapper.className = 'dirt-item';

        const header = document.createElement('div');
        header.style.display = 'flex';
        header.style.justifyContent = 'space-between';
        header.style.alignItems = 'center';
        header.style.cursor = 'pointer';

        const title = document.createElement('div');
        title.innerHTML = `<strong>${escapeHtml((row.metadata || {}).instrument_name || '')}</strong> on dirt #${row.dirt_id}`;
        const meta = document.createElement('div');
        meta.className = 'muted';
        meta.textContent = row.created_at || '';
        const caret = document.createElement('span');
        caret.className = 'chev';
        caret.textContent = '▸';

        header.appendChild(title);
        header.appendChild(meta);
        header.appendChild(caret);

        const body = document.createElement('div');
        body.className = 'output';
        body.style.display = 'none';
        body.innerHTML = escapeHtml(row.output_text || '');

        header.addEventListener('click', () => {
          const open = body.style.display === 'none';
          body.style.display = open ? 'block' : 'none';
          caret.textContent = open ? '▾' : '▸';
        });

        wrapper.appendChild(header);
        wrapper.appendChild(body);
        container.appendChild(wrapper);
      });
    }

    function escapeHtml(str) {
      return String(str || "")
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/"/g, "&quot;")
        .replace(/'/g, "&#39;");
    }

    async function saveBrushStroke(inst, dirt, result) {
      try {
        await fetch('/colors/brush_strokes', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            art_id: artId,
            color_id: colorId,
            dirt_id: dirt.id,
            instrument_id: inst.id,
            instrument_task_id: result?.task_id,
            instrument_run_id: result?.run_id,
            output_text: result?.output || '',
            metadata: {
              instrument_name: inst.name,
              instrument_description: inst.description,
              tokens: result?.usage,
            },
          }),
        });
      } catch (_e) {
        // ignore save errors to avoid blocking UI
      }
    }

    function wireChevron(detailsEl) {
      const summary = detailsEl.querySelector('summary.chevron');
      if (!summary) return;
      const chev = summary.querySelector('.chev');
      summary.addEventListener('click', () => {
        setTimeout(() => {
          if (chev) chev.textContent = detailsEl.open ? '▾' : '▸';
        }, 0);
      });
    }

    function openOutputsPanel() {
      const outputs = document.getElementById('outputsDetails');
      if (outputs && !outputs.open) {
        outputs.open = true;
        const chev = outputs.querySelector('.chev');
        if (chev) chev.textContent = '▾';
      }
    }

    // wire chevrons on load
    document.addEventListener('DOMContentLoaded', () => {
      ['dirtDetails','instrumentDetails','outputsDetails'].forEach(id => {
        const el = document.getElementById(id);
        if (el) wireChevron(el);
      });
    });
  </script>
</body>
</html>
