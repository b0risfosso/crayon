<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Thought</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<style>
  :root {
    font-family: system-ui, sans-serif;
    --text: #111;
    --text-soft: #666;
    --bg: #ffffff;
    --bg-elevated: #f7f7f9;
    --border: #dddddd;
    --accent: #6a4dff;
  }

  body {
    margin: 0;
    background: var(--bg);
    color: var(--text);
    display: flex;
    justify-content: center;
    padding: 40px 20px;
  }

  .container {
    width: 100%;
    max-width: 800px;
    background: var(--bg-elevated);
    border: 1px solid var(--border);
    border-radius: 16px;
    padding: 24px 30px;
    box-shadow: 0 10px 22px rgba(0, 0, 0, 0.06);
  }

  h1 {
    margin-top: 0;
    font-size: 24px;
    color: var(--text);
  }

  .meta {
    margin-top: 6px;
    margin-bottom: 20px;
    font-size: 12px;
    color: var(--text-soft);
  }

  .text {
    white-space: pre-wrap;
    line-height: 1.55;
    font-size: 15px;
  }

  .status {
    margin-top: 10px;
    font-size: 12px;
    color: var(--text-soft);
  }

  .core-ideas-section {
    margin-top: 24px;
    padding-top: 16px;
    border-top: 1px solid var(--border);
  }

  .core-ideas-header {
    display: flex;
    align-items: center;
    gap: 8px;
    flex-wrap: wrap;
    margin-bottom: 8px;
  }

  .core-ideas-header h2 {
    margin: 0;
    font-size: 16px;
    flex: 1;
  }

  button {
    border-radius: 999px;
    border: 1px solid var(--border);
    padding: 4px 10px;
    background: #ffffff;
    cursor: pointer;
    font-size: 12px;
  }

  button.primary {
    background: var(--accent);
    color: #fff;
    border-color: var(--accent);
  }

  button[disabled] {
    opacity: 0.6;
    cursor: default;
  }

  ul.core-ideas-list {
    list-style: none;
    margin: 8px 0 0 0;
    padding: 0;
  }

  .core-idea-item {
    padding: 8px 10px;
    border-radius: 10px;
    border: 1px solid var(--border);
    background: #fff;
    margin-bottom: 6px;
  }

  .core-idea-text {
    font-size: 14px;
    white-space: pre-wrap;
  }

  .core-idea-meta {
    font-size: 11px;
    color: var(--text-soft);
    margin-top: 4px;
  }

  .core-idea-header-row {
    display: flex;
    align-items: flex-start;
    justify-content: space-between;
    gap: 8px;
  }

  .core-idea-actions {
    display: flex;
    flex-direction: column;
    gap: 4px;
    flex-shrink: 0;
  }

  .core-idea-actions button {
    font-size: 11px;
    padding: 3px 8px;
  }

  .visions-container {
    margin-top: 6px;
    padding-top: 6px;
    border-top: 1px dashed var(--border);
  }

  .visions-status {
    font-size: 11px;
    color: var(--text-soft);
    margin-bottom: 4px;
  }

  .visions-list {
    list-style: none;
    margin: 0;
    padding-left: 0;
  }

  .vision-item {
    margin-bottom: 8px;
    padding: 6px 8px;
    border-radius: 8px;
    border: 1px solid var(--border);
    background: #fafafa;
  }

  .vision-item-title {
    font-weight: 600;
    font-size: 13px;
  }

  .vision-item-text {
    font-size: 13px;
    white-space: pre-wrap;
    margin-top: 2px;
  }

  .vision-actions {
    display: flex;
    gap: 6px;
    margin-top: 6px;
    flex-wrap: wrap;
  }

  .vision-actions button {
    font-size: 11px;
    padding: 3px 8px;
  }

  .world-container {
    margin-top: 6px;
    padding-top: 6px;
    border-top: 1px dashed var(--border);
  }

  .world-status {
    font-size: 11px;
    color: var(--text-soft);
    margin-bottom: 4px;
  }

  .world-list {
    list-style: none;
    margin: 0;
    padding-left: 0;
  }

  .world-item {
    margin-bottom: 6px;
  }

  .world-item-title {
    font-weight: 600;
    font-size: 12px;
  }

  .world-item-text {
    font-size: 12px;
    white-space: pre-wrap;
    margin-top: 2px;
  }

  .manual-core-idea {
    margin-top: 8px;
    display: flex;
    gap: 8px;
    align-items: flex-start;
  }

  .manual-core-idea textarea {
    flex: 1;
    min-height: 42px;
    font-size: 13px;
    border-radius: 10px;
    border: 1px solid var(--border);
    padding: 6px 8px;
    resize: vertical;
  }

  .manual-core-idea button {
    align-self: stretch;
    font-size: 12px;
    padding: 6px 10px;
  }

  .core-idea-item.editing .core-idea-text {
    display: none;
  }

  .core-idea-edit-input {
    width: 100%;
    margin-top: 4px;
    font-size: 13px;
    padding: 4px 6px;
    border-radius: 8px;
    border: 1px solid var(--border);
    resize: vertical;
  }

  .core-idea-edit-actions {
    display: flex;
    gap: 4px;
    margin-top: 4px;
  }

  .core-idea-edit-actions button {
    font-size: 11px;
    padding: 3px 8px;
  }
</style>
</head>

<body>
<div class="container">
  <h1 id="title">(loading...)</h1>
  <div class="meta">
    <span id="collection"></span>
    <span id="timestamp"></span>
  </div>

  <div class="text" id="text"></div>
  <div class="status" id="status"></div>

  <div class="core-ideas-section">
    <div class="core-ideas-header">
      <h2>Core ideas for this thought</h2>
      <button type="button" class="primary" id="btn-generate-core-ideas">
        Generate core ideas (THINK)
      </button>
      <button type="button" id="btn-refresh-core-ideas">
        Refresh
      </button>
      <button type="button" id="btn-generate-visions-for-core-ideas">
        Generate visions
      </button>
    </div>
  
    <div class="manual-core-idea">
      <textarea
        id="manual-core-idea-input"
        placeholder="Type a core idea you want to attach to this thought…"
      ></textarea>
      <button type="button" id="btn-add-core-idea">
        Add
      </button>
    </div>
  
    <div class="status" id="core-ideas-status"></div>
    <ul class="core-ideas-list" id="core-ideas-list"></ul>
  </div>
</div>

<script>
  const API_BASE  = "/scribble/api";   // scribble.py
  const JID_BASE  = "/jid";            // jid.py
  const READ_BASE = "/read";           // read.py
  const THINK_BASE = "/think";         // think.py

  let currentThought = null;
  let currentId = null;

  let currentCoreIdeas = [];

  function getQueryParam(name) {
    const params = new URLSearchParams(window.location.search);
    return params.get(name);
  }

  function setStatus(text) {
    document.getElementById("status").textContent = text || "";
  }

  function setCoreIdeasStatus(text) {
    document.getElementById("core-ideas-status").textContent = text || "";
  }

  function setCoreIdeasButtonsDisabled(disabled) {
    document.getElementById("btn-generate-core-ideas").disabled = disabled;
    document.getElementById("btn-refresh-core-ideas").disabled = disabled;
    const visionsBtn = document.getElementById("btn-generate-visions-for-core-ideas");
    if (visionsBtn) visionsBtn.disabled = disabled;
  }

  async function addManualCoreIdea() {
    if (!currentId) {
      setCoreIdeasStatus("No thought loaded.");
      return;
    }

    const input = document.getElementById("manual-core-idea-input");
    const coreText = (input.value || "").trim();
    if (!coreText) {
      alert("Please enter a core idea first.");
      return;
    }

    try {
      setCoreIdeasStatus("Saving core idea…");

      const payload = {
        core_idea: coreText,
        email: "",
      };

      const res = await fetch(
        `${API_BASE}/thoughts/${encodeURIComponent(currentId)}/core_ideas`,
        {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(payload),
        }
      );

      if (!res.ok) {
        let msg = "HTTP " + res.status;
        try {
          const errBody = await res.json();
          if (errBody && errBody.error) msg = errBody.error;
        } catch (_) {}
        throw new Error(msg);
      }

      await res.json().catch(() => ({}));

      input.value = "";
      await loadCoreIdeasFromRead();
      setCoreIdeasStatus("Core idea added.");
    } catch (err) {
      console.error(err);
      setCoreIdeasStatus("Error adding core idea: " + err.message);
    }
  }

  async function apiUpdateCoreIdea(coreIdeaId, newText) {
    const payload = { core_idea: newText };

    const res = await fetch(
      `${API_BASE}/core_ideas/${encodeURIComponent(coreIdeaId)}`,
      {
        method: "PUT",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(payload),
      }
    );

    if (!res.ok) {
      let msg = "HTTP " + res.status;
      try {
        const errBody = await res.json();
        if (errBody && errBody.error) msg = errBody.error;
      } catch (_) {}
      throw new Error(msg);
    }

    return res.json().catch(() => ({}));
  }

  async function apiDeleteCoreIdea(coreIdeaId) {
    const res = await fetch(
      `${API_BASE}/core_ideas/${encodeURIComponent(coreIdeaId)}`,
      { method: "DELETE" }
    );

    if (!res.ok) {
      let msg = "HTTP " + res.status;
      try {
        const errBody = await res.json();
        if (errBody && errBody.error) msg = errBody.error;
      } catch (_) {}
      throw new Error(msg);
    }

    return res.json().catch(() => ({}));
  }

  function enterEditModeForCoreIdea(li, item) {
    if (li.classList.contains("editing")) return;
    li.classList.add("editing");

    const textDiv = li.querySelector(".core-idea-text");
    const actionsDiv = li.querySelector(".core-idea-actions");

    const textarea = document.createElement("textarea");
    textarea.className = "core-idea-edit-input";
    textarea.value = item.core_idea || "";
    textarea.rows = Math.min(5, Math.max(2, (textarea.value.split("\n").length || 1)));

    textDiv.insertAdjacentElement("afterend", textarea);

    const originalButtons = Array.from(actionsDiv.children);
    originalButtons.forEach((btn) => {
      btn.dataset._origDisplay = btn.style.display || "";
      btn.style.display = "none";
    });

    const editActions = document.createElement("div");
    editActions.className = "core-idea-edit-actions";

    const saveBtn = document.createElement("button");
    saveBtn.type = "button";
    saveBtn.textContent = "Save";

    const cancelBtn = document.createElement("button");
    cancelBtn.type = "button";
    cancelBtn.textContent = "Cancel";

    editActions.appendChild(saveBtn);
    editActions.appendChild(cancelBtn);
    actionsDiv.appendChild(editActions);

    function exitEditMode() {
      li.classList.remove("editing");
      textarea.remove();
      editActions.remove();
      originalButtons.forEach((btn) => {
        btn.style.display = btn.dataset._origDisplay || "";
        delete btn.dataset._origDisplay;
      });
    }

    saveBtn.addEventListener("click", async () => {
      const newText = (textarea.value || "").trim();
      if (!newText) {
        alert("Core idea cannot be empty.");
        return;
      }

      try {
        setCoreIdeasStatus("Updating core idea…");
        const updated = await apiUpdateCoreIdea(item.id, newText);
        item.core_idea = updated.core_idea || newText;
        textDiv.textContent = item.core_idea;
        currentCoreIdeas = currentCoreIdeas.map((ci) =>
          ci.id === item.id ? { ...ci, core_idea: item.core_idea } : ci
        );
        setCoreIdeasStatus("Core idea updated.");
        exitEditMode();
      } catch (err) {
        console.error(err);
        setCoreIdeasStatus("Error updating core idea: " + err.message);
      }
    });

    cancelBtn.addEventListener("click", () => {
      exitEditMode();
      setCoreIdeasStatus("");
    });

    textarea.focus();
    textarea.select();
  }

  async function deleteCoreIdeaFromUI(coreIdeaId) {
    const li = document.querySelector(
      `.core-ideas-list li.core-idea-item[data-core-idea-id="${coreIdeaId}"]`
    );

    const text =
      li?.querySelector(".core-idea-text")?.textContent?.trim() || "this core idea";

    if (!confirm(`Delete "${text}"?\n\nThis cannot be undone.`)) {
      return;
    }

    try {
      setCoreIdeasStatus("Deleting core idea…");
      const result = await apiDeleteCoreIdea(coreIdeaId);
      if (!result.deleted) {
        throw new Error(result.error || "Delete failed");
      }

      if (li && li.parentElement) {
        li.parentElement.removeChild(li);
      }

      currentCoreIdeas = currentCoreIdeas.filter((ci) => ci.id !== coreIdeaId);

      setCoreIdeasStatus(
        currentCoreIdeas.length
          ? `Loaded ${currentCoreIdeas.length} core idea(s).`
          : "No core ideas yet."
      );
    } catch (err) {
      console.error(err);
      setCoreIdeasStatus("Error deleting core idea: " + err.message);
    }
  }

  async function loadThought() {
    const id = getQueryParam("id");
    if (!id) {
      setStatus("No thought id provided.");
      return;
    }

    try {
      setStatus("Loading thought…");
      const res = await fetch(`${API_BASE}/thoughts/${id}`);
      if (!res.ok) throw new Error("HTTP " + res.status);
      const t = await res.json();

      currentThought = t;
      currentId = t.id;

      document.getElementById("title").textContent =
        t.title || "(untitled thought)";

      document.getElementById("collection").textContent =
        t.collection ? `Collection: ${t.collection}` : "";

      document.getElementById("timestamp").textContent =
        t.created_at ? ` · ${t.created_at}` : "";

      document.getElementById("text").textContent = t.text || "";
      setStatus("");

      await loadCoreIdeasFromRead();
    } catch (err) {
      console.error(err);
      setStatus("Error loading thought.");
    }
  }

  async function loadWorldContextsForVision(visionId, listEl, statusEl) {
    if (!visionId) {
      statusEl.textContent = "No vision_id.";
      return;
    }

    statusEl.textContent = "Loading worlds…";
    listEl.innerHTML = "";

    try {
      const url = `${READ_BASE}/world_contexts_by_vision?vision_id=${encodeURIComponent(
        visionId
      )}&limit=50`;
      const res = await fetch(url);
      if (!res.ok) {
        statusEl.textContent = `Error loading worlds (HTTP ${res.status}).`;
        return;
      }

      const data = await res.json().catch(() => ({}));
      const items = data.items || [];

      if (!items.length) {
        statusEl.textContent = "No world contexts for this vision yet.";
        return;
      }

      statusEl.textContent = `Loaded ${items.length} world context(s).`;

      items.forEach(w => {
        const li = document.createElement("li");
        li.className = "world-item";

        const titleDiv = document.createElement("div");
        titleDiv.className = "world-item-title";
        titleDiv.textContent = w.title || "(untitled world)";

        const textDiv = document.createElement("div");
        textDiv.className = "world-item-text";
        const text = (w.text || "").trim();
        textDiv.textContent = text || "(no text)";

        li.appendChild(titleDiv);
        li.appendChild(textDiv);
        listEl.appendChild(li);
      });
    } catch (err) {
      console.error(err);
      statusEl.textContent = "Error loading worlds: " + err.message;
    }
  }

  async function queueWorldContextForVision(visionId, statusEl) {
    if (!visionId) {
      if (statusEl) statusEl.textContent = "Cannot queue world: missing vision_id.";
      return;
    }

    try {
      if (statusEl) statusEl.textContent = "Queuing world-context job…";

      const payload = {
        vision_id: visionId,
        email: ""
      };

      const res = await fetch(`${JID_BASE}/generate_world_context_for_vision`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(payload)
      });

      if (!res.ok) {
        let msg = "HTTP " + res.status;
        try {
          const errBody = await res.json();
          if (errBody && errBody.error) msg = errBody.error;
        } catch (_) {}
        throw new Error(msg);
      }

      const body = await res.json().catch(() => ({}));
      const taskId = body.task_id;
      if (statusEl) {
        if (taskId) {
          statusEl.textContent =
            `World-context job queued for vision_id=${visionId} (task_id=${taskId}).`;
        } else {
          statusEl.textContent =
            `World-context job queued for vision_id=${visionId} (no task_id returned).`;
        }
      }
    } catch (err) {
      console.error(err);
      if (statusEl) {
        statusEl.textContent =
          "Error queueing world-context job: " + err.message;
      }
    }
  }

  async function loadVisionsForCoreIdea(coreIdeaId, listEl, statusEl) {
    if (!coreIdeaId) {
      statusEl.textContent = "No core_idea_id.";
      return;
    }

    statusEl.textContent = "Loading visions…";
    listEl.innerHTML = "";

    try {
      const url = `${READ_BASE}/visions_by_core_idea?core_idea_id=${encodeURIComponent(
        coreIdeaId
      )}&limit=50`;
      const res = await fetch(url);
      if (!res.ok) {
        statusEl.textContent = `Error loading visions (HTTP ${res.status}).`;
        return;
      }

      const data = await res.json().catch(() => ({}));
      const items = data.items || [];

      if (!items.length) {
        statusEl.textContent = "No visions for this core idea yet.";
        return;
      }

      statusEl.textContent = `Loaded ${items.length} vision(s).`;
      listEl.innerHTML = "";

      items.forEach(v => {
        const li = document.createElement("li");
        li.className = "vision-item";

        const titleDiv = document.createElement("div");
        titleDiv.className = "vision-item-title";
        titleDiv.textContent = v.title || "(untitled vision)";

        const textDiv = document.createElement("div");
        textDiv.className = "vision-item-text";
        const vision = (v.text || "").trim();
        const realization = (v.realization || "").trim();

        let body = "";
        if (vision) {
          body += "Vision:\n" + vision;
        }
        if (realization) {
          body += "\n\nRealization:\n" + realization;
        }

        textDiv.textContent = body || "(no text)";

        const actionsDiv = document.createElement("div");
        actionsDiv.className = "vision-actions";

        const genWorldBtn = document.createElement("button");
        genWorldBtn.type = "button";
        genWorldBtn.textContent = "Generate world";

        const toggleWorldsBtn = document.createElement("button");
        toggleWorldsBtn.type = "button";
        toggleWorldsBtn.textContent = "Show worlds";

        const worldContainer = document.createElement("div");
        worldContainer.className = "world-container";
        worldContainer.style.display = "none";

        const worldStatus = document.createElement("div");
        worldStatus.className = "world-status";
        worldStatus.textContent = "";

        const worldList = document.createElement("ul");
        worldList.className = "world-list";

        worldContainer.appendChild(worldStatus);
        worldContainer.appendChild(worldList);

        genWorldBtn.addEventListener("click", async () => {
          await queueWorldContextForVision(v.id, worldStatus);
        });

        toggleWorldsBtn.addEventListener("click", async () => {
          if (worldContainer.style.display === "none") {
            worldContainer.style.display = "block";
            toggleWorldsBtn.textContent = "Hide worlds";
            await loadWorldContextsForVision(v.id, worldList, worldStatus);
          } else {
            worldContainer.style.display = "none";
            toggleWorldsBtn.textContent = "Show worlds";
          }
        });

        actionsDiv.appendChild(genWorldBtn);
        actionsDiv.appendChild(toggleWorldsBtn);

        li.appendChild(titleDiv);
        li.appendChild(textDiv);
        li.appendChild(actionsDiv);
        li.appendChild(worldContainer);

        listEl.appendChild(li);
      });
    } catch (err) {
      console.error(err);
      statusEl.textContent = "Error loading visions: " + err.message;
    }
  }

  function renderCoreIdeas(items) {
    currentCoreIdeas = items || [];

    const list = document.getElementById("core-ideas-list");
    list.innerHTML = "";

    items.forEach(item => {
      const li = document.createElement("li");
      li.className = "core-idea-item";
      li.dataset.coreIdeaId = item.id;

      const textDiv = document.createElement("div");
      textDiv.className = "core-idea-text";
      textDiv.textContent = item.core_idea || "";

      const metaDiv = document.createElement("div");
      metaDiv.className = "core-idea-meta";
      metaDiv.textContent = [
        item.id != null ? `id: ${item.id}` : "",
        item.created_at || ""
      ].filter(Boolean).join(" · ");

      const actionsDiv = document.createElement("div");
      actionsDiv.className = "core-idea-actions";

      const openWorldBtn = document.createElement("button");
      openWorldBtn.type = "button";
      openWorldBtn.textContent = "Open world";
      openWorldBtn.addEventListener("click", () => {
        const url = `/world.html?core_idea_id=${encodeURIComponent(
          item.id
        )}&core_idea=${encodeURIComponent(item.core_idea || "")}&thought_id=${encodeURIComponent(currentId)}`;
        window.location.href = url;
      });

      const editBtn = document.createElement("button");
      editBtn.type = "button";
      editBtn.textContent = "Edit";
      editBtn.addEventListener("click", () => {
        enterEditModeForCoreIdea(li, item);
      });

      const deleteBtn = document.createElement("button");
      deleteBtn.type = "button";
      deleteBtn.textContent = "Delete";
      deleteBtn.addEventListener("click", () => {
        deleteCoreIdeaFromUI(item.id);
      });

      actionsDiv.appendChild(openWorldBtn);
      actionsDiv.appendChild(editBtn);
      actionsDiv.appendChild(deleteBtn);

      const headerRow = document.createElement("div");
      headerRow.className = "core-idea-header-row";
      headerRow.appendChild(textDiv);
      headerRow.appendChild(actionsDiv);

      li.appendChild(headerRow);
      li.appendChild(metaDiv);

      list.appendChild(li);
    });
  }

  async function loadCoreIdeasFromRead() {
    if (!currentId) return;

    try {
      setCoreIdeasStatus("Loading core ideas…");
      const src = encodeURIComponent(`thought:${currentId}`);
      const res = await fetch(
        `${READ_BASE}/core_ideas?source_like=${src}&limit=50`
      );
      if (!res.ok) throw new Error("HTTP " + res.status);
      const data = await res.json();
      const items = data.items || [];
      renderCoreIdeas(items);
      setCoreIdeasStatus(
        items.length ? `Loaded ${items.length} core idea(s).` : "No core ideas yet."
      );
    } catch (err) {
      console.error(err);
      setCoreIdeasStatus("Error loading core ideas.");
    }
  }

  async function queueVisionForSingleCoreIdea(coreIdeaId) {
    if (!coreIdeaId) {
      setCoreIdeasStatus("Cannot queue visions: missing core_idea_id.");
      return;
    }

    try {
      const payload = {
        core_idea_id: coreIdeaId,
        email: ""
      };

      const res = await fetch(`${JID_BASE}/generate_visions_from_core_idea`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(payload)
      });

      if (!res.ok) {
        let msg = "HTTP " + res.status;
        try {
          const errBody = await res.json();
          if (errBody && errBody.error) msg = errBody.error;
        } catch (_) {}
        throw new Error(msg);
      }

      const body = await res.json().catch(() => ({}));
      const taskId = body.task_id;
      if (taskId) {
        setCoreIdeasStatus(
          `Queued visions job for core_idea_id=${coreIdeaId} (task_id=${taskId}).`
        );
      } else {
        setCoreIdeasStatus(
          `Queued visions job for core_idea_id=${coreIdeaId} (no task_id returned).`
        );
      }
    } catch (err) {
      console.error(err);
      setCoreIdeasStatus(
        `Error queueing visions for core_idea_id=${coreIdeaId}: ` + err.message
      );
    }
  }

  async function queueVisionsForAllCoreIdeas() {
    if (!currentCoreIdeas.length) {
      setCoreIdeasStatus("No core ideas to generate visions for.");
      return;
    }

    setCoreIdeasStatus("Queuing visions for all loaded core ideas…");

    let success = 0;
    let fails = 0;

    for (const item of currentCoreIdeas) {
      if (!item.id) continue;
      try {
        await queueVisionForSingleCoreIdea(item.id);
        success += 1;
      } catch {
        fails += 1;
      }
    }

    let msg = `Queued visions for ${success} core idea(s).`;
    if (fails) msg += ` ${fails} failed.`;
    setCoreIdeasStatus(msg);
  }

  // --- NEW: core ideas generation via /think/core_ideas --------------------

  async function generateCoreIdeas() {
    if (!currentThought || !currentThought.text) {
      setCoreIdeasStatus("No thought text to send.");
      return;
    }
    if (!currentId) {
      setCoreIdeasStatus("No thought loaded.");
      return;
    }

    try {
      setCoreIdeasButtonsDisabled(true);
      setCoreIdeasStatus("Calling THINK to generate core ideas…");

      // 1) Call /think/core_ideas
      const thinkRes = await fetch(`${THINK_BASE}/core_ideas`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ thought: currentThought.text })
      });

      if (!thinkRes.ok) {
        let msg = "HTTP " + thinkRes.status;
        try {
          const errBody = await thinkRes.json();
          if (errBody && errBody.error) msg = errBody.error;
        } catch (_) {}
        throw new Error(msg);
      }

      const thinkData = await thinkRes.json().catch(() => ({}));
      const seeds = Array.isArray(thinkData.core_ideas)
        ? thinkData.core_ideas
        : [];

      if (!seeds.length) {
        setCoreIdeasStatus("THINK returned no core ideas.");
        setCoreIdeasButtonsDisabled(false);
        return;
      }

      setCoreIdeasStatus(
        `Received ${seeds.length} core idea(s) from THINK. Saving to picture.db…`
      );

      // 2) Save each core idea via scribble API so it lands in picture.db
      let saved = 0;
      for (const seed of seeds) {
        const text = (seed.text || "").trim();
        if (!text) continue;

        const payload = {
          core_idea: text,
          email: "",
          origin: "think"
        };

        const res = await fetch(
          `${API_BASE}/thoughts/${encodeURIComponent(currentId)}/core_ideas`,
          {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(payload)
          }
        );

        if (!res.ok) {
          // log but continue
          let msg = "HTTP " + res.status;
          try {
            const errBody = await res.json();
            if (errBody && errBody.error) msg = errBody.error;
          } catch (_) {}
          console.error("Error saving core idea:", msg);
          continue;
        }

        await res.json().catch(() => ({}));
        saved += 1;
      }

      setCoreIdeasStatus(
        `Saved ${saved} core idea(s) to picture.db. Reloading from /read/core_ideas…`
      );

      // 3) Reload from /read
      await loadCoreIdeasFromRead();

      setCoreIdeasStatus(
        currentCoreIdeas.length
          ? `Loaded ${currentCoreIdeas.length} core idea(s).`
          : "No core ideas yet."
      );
    } catch (err) {
      console.error(err);
      setCoreIdeasStatus("Error generating core ideas: " + err.message);
    } finally {
      setCoreIdeasButtonsDisabled(false);
    }
  }

  document.addEventListener("DOMContentLoaded", () => {
    document
      .getElementById("btn-generate-core-ideas")
      .addEventListener("click", generateCoreIdeas);

    document
      .getElementById("btn-refresh-core-ideas")
      .addEventListener("click", loadCoreIdeasFromRead);

    document
      .getElementById("btn-add-core-idea")
      .addEventListener("click", addManualCoreIdea);

    document
      .getElementById("btn-generate-visions-for-core-ideas")
      .addEventListener("click", queueVisionsForAllCoreIdeas);

    loadThought();
  });
</script>
</body>
</html>
