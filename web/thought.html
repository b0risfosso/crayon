<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Thought</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<style>
  :root {
    font-family: system-ui, sans-serif;
    --text: #111;
    --text-soft: #666;
    --bg: #ffffff;
    --bg-elevated: #f7f7f9;
    --border: #dddddd;
    --accent: #6a4dff;
  }

  body {
    margin: 0;
    background: var(--bg);
    color: var(--text);
    display: flex;
    justify-content: center;
    padding: 40px 20px;
  }

  .container {
    width: 100%;
    max-width: 800px;
    background: var(--bg-elevated);
    border: 1px solid var(--border);
    border-radius: 16px;
    padding: 24px 30px;
    box-shadow: 0 10px 22px rgba(0, 0, 0, 0.06);
  }

  h1 {
    margin-top: 0;
    font-size: 24px;
    color: var(--text);
  }

  .meta {
    margin-top: 6px;
    margin-bottom: 20px;
    font-size: 12px;
    color: var(--text-soft);
  }

  .text {
    white-space: pre-wrap;
    line-height: 1.55;
    font-size: 15px;
  }

  .status {
    margin-top: 10px;
    font-size: 12px;
    color: var(--text-soft);
  }

  .core-ideas-section {
    margin-top: 24px;
    padding-top: 16px;
    border-top: 1px solid var(--border);
  }

  .core-ideas-header {
    display: flex;
    align-items: center;
    gap: 8px;
    flex-wrap: wrap;
    margin-bottom: 8px;
  }

  .core-ideas-header h2 {
    margin: 0;
    font-size: 16px;
    flex: 1;
  }

  button {
    border-radius: 999px;
    border: 1px solid var(--border);
    padding: 4px 10px;
    background: #ffffff;
    cursor: pointer;
    font-size: 12px;
  }

  button.primary {
    background: var(--accent);
    color: #fff;
    border-color: var(--accent);
  }

  button[disabled] {
    opacity: 0.6;
    cursor: default;
  }

  ul.core-ideas-list {
    list-style: none;
    margin: 8px 0 0 0;
    padding: 0;
  }

  .core-idea-item {
    padding: 8px 10px;
    border-radius: 10px;
    border: 1px solid var(--border);
    background: #fff;
    margin-bottom: 6px;
  }

  .core-idea-text {
    font-size: 14px;
    white-space: pre-wrap;
  }

  .core-idea-meta {
    font-size: 11px;
    color: var(--text-soft);
    margin-top: 4px;
  }

  /* New: layout and styles for visions per core idea */
  .core-idea-header-row {
    display: flex;
    align-items: flex-start;
    justify-content: space-between;
    gap: 8px;
  }

  .core-idea-actions {
    display: flex;
    flex-direction: column;
    gap: 4px;
    flex-shrink: 0;
  }

  .core-idea-actions button {
    font-size: 11px;
    padding: 3px 8px;
  }

  .visions-container {
    margin-top: 6px;
    padding-top: 6px;
    border-top: 1px dashed var(--border);
  }

  .visions-status {
    font-size: 11px;
    color: var(--text-soft);
    margin-bottom: 4px;
  }

  .visions-list {
    list-style: none;
    margin: 0;
    padding-left: 0;
  }

  .vision-item {
    margin-bottom: 8px;
    padding: 6px 8px;
    border-radius: 8px;
    border: 1px solid var(--border);
    background: #fafafa;
  }

  .vision-item-title {
    font-weight: 600;
    font-size: 13px;
  }

  .vision-item-text {
    font-size: 13px;
    white-space: pre-wrap;
    margin-top: 2px;
  }

  /* NEW: actions + world-context styles for visions */
  .vision-actions {
    display: flex;
    gap: 6px;
    margin-top: 6px;
    flex-wrap: wrap;
  }

  .vision-actions button {
    font-size: 11px;
    padding: 3px 8px;
  }

  .world-container {
    margin-top: 6px;
    padding-top: 6px;
    border-top: 1px dashed var(--border);
  }

  .world-status {
    font-size: 11px;
    color: var(--text-soft);
    margin-bottom: 4px;
  }

  .world-list {
    list-style: none;
    margin: 0;
    padding-left: 0;
  }

  .world-item {
    margin-bottom: 6px;
  }

  .world-item-title {
    font-weight: 600;
    font-size: 12px;
  }

  .world-item-text {
    font-size: 12px;
    white-space: pre-wrap;
    margin-top: 2px;
  }

  .manual-core-idea {
    margin-top: 8px;
    display: flex;
    gap: 8px;
    align-items: flex-start;
  }

  .manual-core-idea textarea {
    flex: 1;
    min-height: 42px;
    font-size: 13px;
    border-radius: 10px;
    border: 1px solid var(--border);
    padding: 6px 8px;
    resize: vertical;
  }

  .manual-core-idea button {
    align-self: stretch;
    font-size: 12px;
    padding: 6px 10px;
  }

</style>
</head>

<body>
<div class="container">
  <h1 id="title">(loading...)</h1>
  <div class="meta">
    <span id="collection"></span>
    <span id="timestamp"></span>
  </div>

  <div class="text" id="text"></div>
  <div class="status" id="status"></div>

  <div class="core-ideas-section">
    <div class="core-ideas-header">
      <h2>Core ideas for this thought</h2>
      <button type="button" class="primary" id="btn-generate-core-ideas">
        Generate core ideas
      </button>
      <button type="button" id="btn-refresh-core-ideas">
        Refresh
      </button>
      <!-- generate visions for all loaded core ideas -->
      <button type="button" id="btn-generate-visions-for-core-ideas">
        Generate visions
      </button>
    </div>
  
    <!-- NEW: manual core idea input -->
    <div class="manual-core-idea">
      <textarea
        id="manual-core-idea-input"
        placeholder="Type a core idea you want to attach to this thought…"
      ></textarea>
      <button type="button" id="btn-add-core-idea">
        Add
      </button>
    </div>
  
    <div class="status" id="core-ideas-status"></div>
    <ul class="core-ideas-list" id="core-ideas-list"></ul>
  </div>
  
</div>

<script>
  const API_BASE  = "/scribble/api";   // scribble.py
  const JID_BASE  = "/jid";            // jid.py
  const READ_BASE = "/read";           // read.py

  let currentThought = null;   // full thought row from /scribble/api/thoughts/<id>
  let currentId = null;

  // track polling for the core-ideas queue
  let coreIdeasTaskId = null;
  let coreIdeasPollTimer = null;

  // track currently rendered core ideas so we can queue visions for them
  let currentCoreIdeas = [];

  function getQueryParam(name) {
    const params = new URLSearchParams(window.location.search);
    return params.get(name);
  }

  function setStatus(text) {
    document.getElementById("status").textContent = text || "";
  }

  function setCoreIdeasStatus(text) {
    document.getElementById("core-ideas-status").textContent = text || "";
  }

  function setCoreIdeasButtonsDisabled(disabled) {
    document.getElementById("btn-generate-core-ideas").disabled = disabled;
    document.getElementById("btn-refresh-core-ideas").disabled =
      disabled && !!coreIdeasTaskId;

    const visionsBtn = document.getElementById("btn-generate-visions-for-core-ideas");
    if (visionsBtn) visionsBtn.disabled = disabled;
  }

  async function addManualCoreIdea() {
    if (!currentId) {
      setCoreIdeasStatus("No thought loaded.");
      return;
    }

    const input = document.getElementById("manual-core-idea-input");
    const coreText = (input.value || "").trim();
    if (!coreText) {
      alert("Please enter a core idea first.");
      return;
    }

    try {
      setCoreIdeasStatus("Saving core idea…");

      const payload = {
        core_idea: coreText,
        // optional email if you want per-user scoping; empty string is fine
        email: ""
      };

      const res = await fetch(
        `${API_BASE}/thoughts/${encodeURIComponent(currentId)}/core_ideas`,
        {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(payload)
        }
      );

      if (!res.ok) {
        let msg = "HTTP " + res.status;
        try {
          const errBody = await res.json();
          if (errBody && errBody.error) msg = errBody.error;
        } catch (_) {}
        throw new Error(msg);
      }

      const saved = await res.json().catch(() => ({}));

      input.value = "";
      // reload the list so the new core idea appears with proper metadata
      await loadCoreIdeasFromRead();
      setCoreIdeasStatus(
        saved && saved.id
          ? `Core idea added (id=${saved.id}).`
          : "Core idea added."
      );
    } catch (err) {
      console.error(err);
      setCoreIdeasStatus("Error adding core idea: " + err.message);
    }
  }


  async function loadThought() {
    const id = getQueryParam("id");
    if (!id) {
      setStatus("No thought id provided.");
      return;
    }

    try {
      setStatus("Loading thought…");
      const res = await fetch(`${API_BASE}/thoughts/${id}`);
      if (!res.ok) throw new Error("HTTP " + res.status);
      const t = await res.json();

      currentThought = t;
      currentId = t.id;

      document.getElementById("title").textContent =
        t.title || "(untitled thought)";

      document.getElementById("collection").textContent =
        t.collection ? `Collection: ${t.collection}` : "";

      document.getElementById("timestamp").textContent =
        t.created_at ? ` · ${t.created_at}` : "";

      document.getElementById("text").textContent = t.text || "";
      setStatus("");

      // After loading the thought, load any existing core ideas for it
      await loadCoreIdeasFromRead();
    } catch (err) {
      console.error(err);
      setStatus("Error loading thought.");
    }
  }

  // --- World contexts loading per vision ----------------------------------

  async function loadWorldContextsForVision(visionId, listEl, statusEl) {
    if (!visionId) {
      statusEl.textContent = "No vision_id.";
      return;
    }

    statusEl.textContent = "Loading worlds…";
    listEl.innerHTML = "";

    try {
      const url = `${READ_BASE}/world_contexts_by_vision?vision_id=${encodeURIComponent(
        visionId
      )}&limit=50`;
      const res = await fetch(url);
      if (!res.ok) {
        statusEl.textContent = `Error loading worlds (HTTP ${res.status}).`;
        return;
      }

      const data = await res.json().catch(() => ({}));
      const items = data.items || [];

      if (!items.length) {
        statusEl.textContent = "No world contexts for this vision yet.";
        return;
      }

      statusEl.textContent = `Loaded ${items.length} world context(s).`;

      items.forEach(w => {
        const li = document.createElement("li");
        li.className = "world-item";

        const titleDiv = document.createElement("div");
        titleDiv.className = "world-item-title";
        titleDiv.textContent = w.title || "(untitled world)";

        const textDiv = document.createElement("div");
        textDiv.className = "world-item-text";
        const text = (w.text || "").trim();
        textDiv.textContent = text || "(no text)";

        li.appendChild(titleDiv);
        li.appendChild(textDiv);
        listEl.appendChild(li);
      });
    } catch (err) {
      console.error(err);
      statusEl.textContent = "Error loading worlds: " + err.message;
    }
  }

  async function queueWorldContextForVision(visionId, statusEl) {
    if (!visionId) {
      if (statusEl) statusEl.textContent = "Cannot queue world: missing vision_id.";
      return;
    }

    try {
      if (statusEl) statusEl.textContent = "Queuing world-context job…";

      const payload = {
        vision_id: visionId,
        email: "" // optional, fill for tracing if desired
      };

      const res = await fetch(`${JID_BASE}/generate_world_context_for_vision`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(payload)
      });

      if (!res.ok) {
        let msg = "HTTP " + res.status;
        try {
          const errBody = await res.json();
          if (errBody && errBody.error) msg = errBody.error;
        } catch (_) {}
        throw new Error(msg);
      }

      const body = await res.json().catch(() => ({}));
      const taskId = body.task_id;
      if (statusEl) {
        if (taskId) {
          statusEl.textContent =
            `World-context job queued for vision_id=${visionId} (task_id=${taskId}).`;
        } else {
          statusEl.textContent =
            `World-context job queued for vision_id=${visionId} (no task_id returned).`;
        }
      }
    } catch (err) {
      console.error(err);
      if (statusEl) {
        statusEl.textContent =
          "Error queueing world-context job: " + err.message;
      }
    }
  }

  // --- Visions loading per core idea --------------------------------------

  async function loadVisionsForCoreIdea(coreIdeaId, listEl, statusEl) {
    if (!coreIdeaId) {
      statusEl.textContent = "No core_idea_id.";
      return;
    }

    statusEl.textContent = "Loading visions…";
    listEl.innerHTML = "";

    try {
      const url = `${READ_BASE}/visions_by_core_idea?core_idea_id=${encodeURIComponent(
        coreIdeaId
      )}&limit=50`;
      const res = await fetch(url);
      if (!res.ok) {
        statusEl.textContent = `Error loading visions (HTTP ${res.status}).`;
        return;
      }

      const data = await res.json().catch(() => ({}));
      const items = data.items || [];

      if (!items.length) {
        statusEl.textContent = "No visions for this core idea yet.";
        return;
      }

      statusEl.textContent = `Loaded ${items.length} vision(s).`;
      listEl.innerHTML = "";

      items.forEach(v => {
        const li = document.createElement("li");
        li.className = "vision-item";

        const titleDiv = document.createElement("div");
        titleDiv.className = "vision-item-title";
        titleDiv.textContent = v.title || "(untitled vision)";

        const textDiv = document.createElement("div");
        textDiv.className = "vision-item-text";
        const vision = (v.text || "").trim();
        const realization = (v.realization || "").trim();

        let body = "";
        if (vision) {
          body += "Vision:\n" + vision;
        }
        if (realization) {
          body += "\n\nRealization:\n" + realization;
        }

        textDiv.textContent = body || "(no text)";

        // Actions: generate world + toggle worlds
        const actionsDiv = document.createElement("div");
        actionsDiv.className = "vision-actions";

        const genWorldBtn = document.createElement("button");
        genWorldBtn.type = "button";
        genWorldBtn.textContent = "Generate world";

        const toggleWorldsBtn = document.createElement("button");
        toggleWorldsBtn.type = "button";
        toggleWorldsBtn.textContent = "Show worlds";

        // World container (hidden by default)
        const worldContainer = document.createElement("div");
        worldContainer.className = "world-container";
        worldContainer.style.display = "none";

        const worldStatus = document.createElement("div");
        worldStatus.className = "world-status";
        worldStatus.textContent = "";

        const worldList = document.createElement("ul");
        worldList.className = "world-list";

        worldContainer.appendChild(worldStatus);
        worldContainer.appendChild(worldList);

        genWorldBtn.addEventListener("click", async () => {
          await queueWorldContextForVision(v.id, worldStatus);
        });

        toggleWorldsBtn.addEventListener("click", async () => {
          if (worldContainer.style.display === "none") {
            worldContainer.style.display = "block";
            toggleWorldsBtn.textContent = "Hide worlds";
            await loadWorldContextsForVision(v.id, worldList, worldStatus);
          } else {
            worldContainer.style.display = "none";
            toggleWorldsBtn.textContent = "Show worlds";
          }
        });

        actionsDiv.appendChild(genWorldBtn);
        actionsDiv.appendChild(toggleWorldsBtn);

        li.appendChild(titleDiv);
        li.appendChild(textDiv);
        li.appendChild(actionsDiv);
        li.appendChild(worldContainer);

        listEl.appendChild(li);
      });
    } catch (err) {
      console.error(err);
      statusEl.textContent = "Error loading visions: " + err.message;
    }
  }

  // --- Core ideas rendering ------------------------------------------------

  function renderCoreIdeas(items) {
    currentCoreIdeas = items || [];

    const list = document.getElementById("core-ideas-list");
    list.innerHTML = "";

    items.forEach(item => {
      const li = document.createElement("li");
      li.className = "core-idea-item";
      li.dataset.coreIdeaId = item.id;

      const textDiv = document.createElement("div");
      textDiv.className = "core-idea-text";
      textDiv.textContent = item.core_idea || "";

      const metaDiv = document.createElement("div");
      metaDiv.className = "core-idea-meta";
      metaDiv.textContent = [
        item.id != null ? `id: ${item.id}` : "",
        item.created_at || ""
      ].filter(Boolean).join(" · ");

      // visions container (hidden by default)
      const visionsContainer = document.createElement("div");
      visionsContainer.className = "visions-container";
      visionsContainer.style.display = "none";

      const visionsStatus = document.createElement("div");
      visionsStatus.className = "visions-status";
      visionsStatus.textContent = "";

      const visionsList = document.createElement("ul");
      visionsList.className = "visions-list";

      visionsContainer.appendChild(visionsStatus);
      visionsContainer.appendChild(visionsList);

      // actions on the right: toggle + per-core "Gen visions"
      const actionsDiv = document.createElement("div");
      actionsDiv.className = "core-idea-actions";

      const toggleBtn = document.createElement("button");
      toggleBtn.type = "button";
      toggleBtn.textContent = "Show visions";

      toggleBtn.addEventListener("click", async () => {
        if (visionsContainer.style.display === "none") {
          visionsContainer.style.display = "block";
          toggleBtn.textContent = "Hide visions";
          await loadVisionsForCoreIdea(item.id, visionsList, visionsStatus);
        } else {
          visionsContainer.style.display = "none";
          toggleBtn.textContent = "Show visions";
        }
      });

      const genVisionsBtn = document.createElement("button");
      genVisionsBtn.type = "button";
      genVisionsBtn.textContent = "Gen visions";
      genVisionsBtn.addEventListener("click", async () => {
        await queueVisionForSingleCoreIdea(item.id);
      });

      actionsDiv.appendChild(toggleBtn);
      actionsDiv.appendChild(genVisionsBtn);

      const headerRow = document.createElement("div");
      headerRow.className = "core-idea-header-row";
      headerRow.appendChild(textDiv);
      headerRow.appendChild(actionsDiv);

      li.appendChild(headerRow);
      li.appendChild(metaDiv);
      li.appendChild(visionsContainer);

      list.appendChild(li);
    });
  }

  async function loadCoreIdeasFromRead() {
    if (!currentId) return;

    try {
      setCoreIdeasStatus("Loading core ideas…");
      const src = encodeURIComponent(`thought:${currentId}`);
      const res = await fetch(
        `${READ_BASE}/core_ideas?source_like=${src}&limit=50`
      );
      if (!res.ok) throw new Error("HTTP " + res.status);
      const data = await res.json();
      const items = data.items || [];
      renderCoreIdeas(items);
      setCoreIdeasStatus(
        items.length ? `Loaded ${items.length} core idea(s).` : "No core ideas yet."
      );
    } catch (err) {
      console.error(err);
      setCoreIdeasStatus("Error loading core ideas.");
    }
  }

  // --- Queueing visions generation ----------------------------------------

  async function queueVisionForSingleCoreIdea(coreIdeaId) {
    if (!coreIdeaId) {
      setCoreIdeasStatus("Cannot queue visions: missing core_idea_id.");
      return;
    }

    try {
      const payload = {
        core_idea_id: coreIdeaId,
        email: ""   // optional, fill if you want tracing
      };

      const res = await fetch(`${JID_BASE}/generate_visions_from_core_idea`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(payload)
      });

      if (!res.ok) {
        let msg = "HTTP " + res.status;
        try {
          const errBody = await res.json();
          if (errBody && errBody.error) msg = errBody.error;
        } catch (_) {}
        throw new Error(msg);
      }

      const body = await res.json().catch(() => ({}));
      const taskId = body.task_id;
      if (taskId) {
        setCoreIdeasStatus(
          `Queued visions job for core_idea_id=${coreIdeaId} (task_id=${taskId}).`
        );
      } else {
        setCoreIdeasStatus(
          `Queued visions job for core_idea_id=${coreIdeaId} (no task_id returned).`
        );
      }
    } catch (err) {
      console.error(err);
      setCoreIdeasStatus(
        `Error queueing visions for core_idea_id=${coreIdeaId}: ` + err.message
      );
    }
  }

  async function queueVisionsForAllCoreIdeas() {
    if (!currentCoreIdeas.length) {
      setCoreIdeasStatus("No core ideas to generate visions for.");
      return;
    }

    setCoreIdeasStatus("Queuing visions for all loaded core ideas…");

    let success = 0;
    let fails = 0;

    // sequential is simplest; if you like you can use Promise.all
    for (const item of currentCoreIdeas) {
      if (!item.id) continue;
      try {
        await queueVisionForSingleCoreIdea(item.id);
        success += 1;
      } catch {
        fails += 1;
      }
    }

    let msg = `Queued visions for ${success} core idea(s).`;
    if (fails) msg += ` ${fails} failed.`;
    setCoreIdeasStatus(msg);
  }

  // --- Core ideas generation via queue (existing) --------------------------

  // Poll a queued job until it finishes.
  async function pollCoreIdeasTask(taskId, attempt = 0) {
    coreIdeasTaskId = taskId;

    const maxAttempts = 120;       // fail-safe (~3 minutes if 1.5s interval)
    const delayMs = 1500;

    try {
      const url = `${JID_BASE}/create_pictures/result` +
                  `?task_id=${encodeURIComponent(taskId)}&wrapper=true`;
      const res = await fetch(url);

      // Task not finished yet
      if (res.status === 202) {
        const body = await res.json().catch(() => ({}));
        const status = body.status || "queued/running";
        setCoreIdeasStatus(`Core-ideas task ${status}… (task_id=${taskId})`);

        if (attempt >= maxAttempts) {
          setCoreIdeasStatus("Core-ideas task timed out.");
          setCoreIdeasButtonsDisabled(false);
          coreIdeasTaskId = null;
          return;
        }

        coreIdeasPollTimer = setTimeout(
          () => pollCoreIdeasTask(taskId, attempt + 1),
          delayMs
        );
        return;
      }

      // Hard error (404 or others)
      if (!res.ok && res.status !== 500) {
        let msg = `Queue error (HTTP ${res.status})`;
        try {
          const errBody = await res.json();
          if (errBody && errBody.error) msg = errBody.error;
        } catch (_) {}
        setCoreIdeasStatus(msg);
        setCoreIdeasButtonsDisabled(false);
        coreIdeasTaskId = null;
        return;
      }

      const body = await res.json().catch(() => ({}));

      // If wrapper+error
      if (body.status === "error") {
        const msg = body.error || "Core-ideas task failed.";
        setCoreIdeasStatus(msg);
        setCoreIdeasButtonsDisabled(false);
        coreIdeasTaskId = null;
        return;
      }

      // Done
      setCoreIdeasStatus("Core ideas generated. Reloading from DB…");
      await loadCoreIdeasFromRead();
      setCoreIdeasStatus("Core ideas generated and loaded.");
      setCoreIdeasButtonsDisabled(false);
      coreIdeasTaskId = null;
    } catch (err) {
      console.error(err);
      setCoreIdeasStatus("Error polling core-ideas task: " + err.message);
      setCoreIdeasButtonsDisabled(false);
      coreIdeasTaskId = null;
    }
  }

  async function generateCoreIdeas() {
    if (!currentThought || !currentThought.text) {
      setCoreIdeasStatus("No thought text to send.");
      return;
    }

    // Clear any previous polling
    if (coreIdeasPollTimer) {
      clearTimeout(coreIdeasPollTimer);
      coreIdeasPollTimer = null;
    }
    coreIdeasTaskId = null;

    try {
      setCoreIdeasButtonsDisabled(true);
      setCoreIdeasStatus("Submitting core-ideas job to queue…");

      const payload = {
        text: currentThought.text,
        // tie core_ideas to this specific thought so /read/core_ideas can find them
        source: `thought:${currentThought.id}`,
        // optional email for tracing
        email: ""
      };

      const res = await fetch(`${JID_BASE}/create_core_ideas`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(payload)
      });

      if (!res.ok) {
        let msg = "HTTP " + res.status;
        try {
          const errBody = await res.json();
          if (errBody && errBody.error) msg = errBody.error;
        } catch (_) {}
        throw new Error(msg);
      }

      const body = await res.json().catch(() => ({}));
      const taskId = body.task_id;
      if (!taskId) {
        setCoreIdeasButtonsDisabled(false);
        throw new Error("Queue did not return task_id.");
      }

      setCoreIdeasStatus(
        `Core-ideas job queued (task_id=${taskId}). Waiting for completion…`
      );

      // Start polling queue for completion
      pollCoreIdeasTask(taskId, 0);
    } catch (err) {
      console.error(err);
      setCoreIdeasStatus("Error generating core ideas: " + err.message);
      setCoreIdeasButtonsDisabled(false);
    }
  }

  document.addEventListener("DOMContentLoaded", () => {
    document
      .getElementById("btn-generate-core-ideas")
      .addEventListener("click", generateCoreIdeas);

    document
      .getElementById("btn-refresh-core-ideas")
      .addEventListener("click", loadCoreIdeasFromRead);

    document
      .getElementById("btn-generate-visions-for-core-ideas")
      .addEventListener("click", queueVisionsForAllCoreIdeas);

    // NEW: manual core idea submit
    document
      .getElementById("btn-add-core-idea")
      .addEventListener("click", addManualCoreIdea);

    loadThought();
  });

</script>
</body>
</html>
