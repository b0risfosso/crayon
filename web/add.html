<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Add | Creations & Prompts</title>
  <style>
    :root {
      --border-color: #000;
      --bg-main: #fff;
      --text-muted: #444;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: var(--bg-main);
      color: #000;
    }

    main {
      max-width: 900px;
      margin: 0 auto;
      padding: 1rem;
    }

    nav {
      display: flex;
      gap: 0.75rem;
      margin-bottom: 1rem;
      flex-wrap: wrap;
      font-size: 0.95rem;
    }

    nav a {
      color: inherit;
      text-decoration: none;
      padding: 0.25rem 0.5rem;
      border-radius: 4px;
      border: 1px solid transparent;
    }

    nav a:hover {
      border-color: var(--border-color);
    }

    h1 {
      font-size: 1.5rem;
      margin: 0 0 1rem;
    }

    h2 {
      font-size: 1.25rem;
      margin: 1.5rem 0 0.75rem;
    }

    .section-card {
      border: 1px solid var(--border-color);
      padding: 0.75rem;
      border-radius: 6px;
      margin-bottom: 1rem;
    }

    .section-title {
      font-weight: 600;
      margin-bottom: 0.5rem;
    }

    label {
      display: block;
      font-size: 0.9rem;
      margin-top: 0.5rem;
      margin-bottom: 0.25rem;
    }

    input[type="text"],
    textarea,
    select {
      width: 100%;
      padding: 0.4rem 0.5rem;
      border-radius: 4px;
      border: 1px solid #000;
      font: inherit;
    }

    textarea {
      min-height: 5rem;
      resize: vertical;
    }

    button {
      font: inherit;
      border-radius: 4px;
      border: 1px solid #000;
      padding: 0.4rem 0.8rem;
      cursor: pointer;
      background: #000;
      color: #fff;
    }

    button.secondary {
      background: #fff;
      color: #000;
    }

    button.secondary:hover {
      background: #000;
      color: #fff;
    }

    button:disabled {
      opacity: 0.6;
      cursor: default;
    }

    .row {
      display: flex;
      gap: 0.5rem;
      align-items: center;
      flex-wrap: wrap;
    }

    .muted {
      color: var(--text-muted);
      font-size: 0.9rem;
    }

    .list {
      margin-top: 0.5rem;
      max-height: 260px;
      overflow-y: auto;
      border-top: 1px solid #ddd;
      padding-top: 0.5rem;
    }

    .list-item {
      padding: 0.25rem 0;
      border-bottom: 1px solid #eee;
    }

    .list-title {
      font-weight: 600;
      font-size: 0.95rem;
    }

    .list-meta {
      font-size: 0.8rem;
      color: var(--text-muted);
      margin-top: 0.15rem;
    }

    /* Type chips list (for writing types) */
    .types-list {
      max-height: none;
      border-top: none;
      padding-top: 0.25rem;
      display: flex;
      flex-wrap: wrap;
      gap: 0.35rem;
    }

    .type-chip {
      border: 1px solid #000;
      border-radius: 999px;
      padding: 0.15rem 0.6rem;
      font-size: 0.85rem;
      cursor: pointer;
      background: #fff;
      color: #000;     /* ← force black text */
    }

    .type-chip:hover {
      background: #000;
      color: #fff;
    }

    .type-chip.active-target {
      border-style: dashed;
    }
  </style>
</head>
<body>
  <main>
    <nav>
      <a href="/index.html">Home</a>
      <a href="/lang.html">Runs</a>
      <a href="/writings.html">Writings</a>
      <a href="/add.html"><strong>Add</strong></a>
    </nav>

    <h1>Add creations & prompts</h1>

    <!-- Creations -->
    <section>
      <h2>Creations</h2>

      <div class="section-card">
        <div class="section-title">Add creation</div>
        <label for="creation-name">Creation name</label>
        <input id="creation-name" type="text" placeholder="Creation name" />

        <label for="creation-desc">Creation description</label>
        <textarea id="creation-desc" placeholder="Creation description"></textarea>

        <div class="row" style="margin-top: 0.5rem;">
          <button type="button" id="add-creation-btn">Add creation</button>
        </div>
        <div id="creation-status" class="muted" style="margin-top: 0.35rem;"></div>
      </div>

      <div class="section-card">
        <div class="section-title">Existing creations</div>
        <div id="creations-list" class="list"></div>
      </div>
    </section>

    <!-- Prompts -->
    <section>
      <h2>Prompts</h2>

      <!-- NEW: existing writing types (from writings table, via /api/writing-types) -->
      <div class="section-card">
        <div class="section-title">Existing writing types</div>
        <div class="muted">
          These are all distinct <code>type</code> values in the <code>writings</code> table.
          Click a type to fill the <strong>Input type</strong> or
          <strong>Output type</strong> fields (whichever you last focused).
        </div>
        <div id="types-list" class="types-list"></div>
      </div>

      <div class="section-card">
        <div class="section-title">Add prompt</div>

        <label for="prompt-input-type">Input type</label>
        <input
          id="prompt-input-type"
          type="text"
          placeholder="e.g. lang, words, summary, outline"
        />

        <label for="prompt-output-type">Output type</label>
        <input
          id="prompt-output-type"
          type="text"
          placeholder="e.g. words, outline, summary"
        />

        <label for="prompt-text">Prompt text</label>
        <textarea
          id="prompt-text"
          placeholder="Write the instruction that will be sent to the LLM..."
        ></textarea>

        <div class="row" style="margin-top: 0.5rem;">
          <button type="button" id="add-prompt-btn">Add prompt</button>
        </div>
        <div id="prompt-status" class="muted" style="margin-top: 0.35rem;"></div>
      </div>

      <div class="section-card">
        <div class="section-title">Existing prompts</div>
        <div id="prompts-list" class="list"></div>
      </div>
    </section>
  </main>

  <script>
    const creationNameEl = document.getElementById('creation-name');
    const creationDescEl = document.getElementById('creation-desc');
    const addCreationBtn = document.getElementById('add-creation-btn');
    const creationStatusEl = document.getElementById('creation-status');
    const creationsListEl = document.getElementById('creations-list');

    const promptInputTypeEl = document.getElementById('prompt-input-type');
    const promptOutputTypeEl = document.getElementById('prompt-output-type');
    const promptTextEl = document.getElementById('prompt-text');
    const addPromptBtn = document.getElementById('add-prompt-btn');
    const promptStatusEl = document.getElementById('prompt-status');
    const promptsListEl = document.getElementById('prompts-list');

    const typesListEl = document.getElementById('types-list');

    // Track which field (input or output type) is the current target for type clicks
    let lastTypeTarget = 'input'; // 'input' or 'output'

    promptInputTypeEl.addEventListener('focus', () => {
      lastTypeTarget = 'input';
    });

    promptOutputTypeEl.addEventListener('focus', () => {
      lastTypeTarget = 'output';
    });

    async function loadCreations() {
      creationsListEl.textContent = 'Loading…';
      try {
        const res = await fetch('/api/creations');
        if (!res.ok) throw new Error('Failed to load creations');
        const data = await res.json();

        creationsListEl.textContent = '';
        if (!data.length) {
          creationsListEl.textContent = 'No creations yet.';
          return;
        }

        data.forEach((item) => {
          const div = document.createElement('div');
          div.className = 'list-item';

          const title = document.createElement('div');
          title.className = 'list-title';
          title.textContent = item.name || '(unnamed creation)';
          div.appendChild(title);

          if (item.description) {
            const desc = document.createElement('div');
            desc.textContent = item.description;
            desc.style.fontSize = '0.9rem';
            desc.style.marginTop = '0.15rem';
            div.appendChild(desc);
          }

          const meta = document.createElement('div');
          meta.className = 'list-meta';
          meta.textContent = `#${item.id} · created ${item.created_at || ''}`;
          div.appendChild(meta);

          creationsListEl.appendChild(div);
        });
      } catch (err) {
        creationsListEl.textContent = `Error: ${err.message}`;
      }
    }

    async function addCreation() {
      const name = creationNameEl.value.trim();
      const description = creationDescEl.value.trim();
      if (!name && !description) {
        creationStatusEl.textContent = 'Enter a name or description first.';
        return;
      }
      creationStatusEl.textContent = 'Saving…';
      try {
        const res = await fetch('/api/creations', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ name, description }),
        });
        if (!res.ok) {
          const err = await res.json().catch(() => ({}));
          throw new Error(err.error || 'Failed to add creation');
        }
        creationNameEl.value = '';
        creationDescEl.value = '';
        creationStatusEl.textContent = 'Creation added.';
        await loadCreations();
      } catch (err) {
        creationStatusEl.textContent = `Error: ${err.message}`;
      }
    }

    async function loadPrompts() {
      promptsListEl.textContent = 'Loading…';
      try {
        const res = await fetch('/api/prompts');
        if (!res.ok) throw new Error('Failed to load prompts');
        const data = await res.json();

        promptsListEl.textContent = '';
        if (!data.length) {
          promptsListEl.textContent = 'No prompts yet.';
          return;
        }

        data.forEach((p) => {
          const div = document.createElement('div');
          div.className = 'list-item';

          const title = document.createElement('div');
          title.className = 'list-title';
          title.textContent = `[${p.input_type}] → ${p.output_type}`;
          div.appendChild(title);

          const text = document.createElement('div');
          text.textContent = p.prompt_text;
          text.style.fontSize = '0.9rem';
          text.style.marginTop = '0.15rem';
          div.appendChild(text);

          const meta = document.createElement('div');
          meta.className = 'list-meta';
          meta.textContent = `#${p.id}`;
          div.appendChild(meta);

          promptsListEl.appendChild(div);
        });
      } catch (err) {
        promptsListEl.textContent = `Error: ${err.message}`;
      }
    }

    async function addPrompt() {
      const inputType = promptInputTypeEl.value.trim();
      const outputType = promptOutputTypeEl.value.trim();
      const promptText = promptTextEl.value.trim();

      if (!inputType) {
        promptStatusEl.textContent = 'Input type is required.';
        return;
      }
      if (!outputType) {
        promptStatusEl.textContent = 'Output type is required.';
        return;
      }
      if (!promptText) {
        promptStatusEl.textContent = 'Prompt text is required.';
        return;
      }

      promptStatusEl.textContent = 'Saving…';
      try {
        const res = await fetch('/api/prompts', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            input_type: inputType,
            output_type: outputType,
            prompt_text: promptText,
          }),
        });
        if (!res.ok) {
          const err = await res.json().catch(() => ({}));
          throw new Error(err.error || 'Failed to add prompt');
        }

        promptStatusEl.textContent = 'Prompt added.';
        promptTextEl.value = '';
        await loadPrompts();
      } catch (err) {
        promptStatusEl.textContent = `Error: ${err.message}`;
      }
    }

    // NEW: load all distinct types from writings table via /api/writing-types
    async function loadWritingTypes() {
      typesListEl.textContent = 'Loading…';
      try {
        const res = await fetch('/api/writing-types');
        if (!res.ok) throw new Error('Failed to load writing types');
        const data = await res.json();
        if (!Array.isArray(data)) {
          typesListEl.textContent = 'No types data.';
          return;
        }

        const types = data.filter((t) => t && typeof t === 'string');
        typesListEl.textContent = '';

        if (!types.length) {
          const span = document.createElement('span');
          span.className = 'muted';
          span.textContent = 'No writing types yet.';
          typesListEl.appendChild(span);
          return;
        }

        types.forEach((type) => {
          const chip = document.createElement('button');
          chip.type = 'button';
          chip.className = 'type-chip';
          chip.textContent = type;
          chip.addEventListener('click', () => {
            if (lastTypeTarget === 'output') {
              promptOutputTypeEl.value = type;
              promptOutputTypeEl.focus();
            } else {
              promptInputTypeEl.value = type;
              promptInputTypeEl.focus();
            }
          });
          typesListEl.appendChild(chip);
        });
      } catch (err) {
        typesListEl.textContent = `Error: ${err.message}`;
      }
    }

    addCreationBtn.addEventListener('click', addCreation);
    addPromptBtn.addEventListener('click', addPrompt);

    (async function init() {
      await loadCreations();
      await loadPrompts();
      await loadWritingTypes(); // show all types from writings table
    })();
  </script>
</body>
</html>
