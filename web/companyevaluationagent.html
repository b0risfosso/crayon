<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Company Evaluation Agent</title>
<style>
  :root { color-scheme: light dark; }
  body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; margin: 2rem; }
  h1 { font-size: 1.1rem; margin: 0 0 1rem; }
  form { display: flex; gap: .5rem; flex-wrap: wrap; align-items: center; margin-bottom: .5rem; }
  input[type="text"] { padding: .6rem .7rem; min-width: 18rem; border: 1px solid #ccc; border-radius: .5rem; }
  button { padding: .6rem .9rem; border: 0; border-radius: .5rem; cursor: pointer; background: #0b5cff; color: #fff; }
  button[disabled] { opacity: .6; cursor: not-allowed; }
  #status, #llmStatus, #peStatus, #revStatus { font-size: .9rem; margin: .5rem 0 0; min-height: 1.2em; opacity: .85; }
  pre, textarea { margin-top: .75rem; padding: .75rem; background: rgba(0,0,0,.05); border-radius: .5rem; overflow: auto; width: 100%; }
  textarea { min-height: 200px; }
  .row { display: grid; grid-template-columns: 1fr; gap: 1rem; }
  @media (min-width: 900px) { .row { grid-template-columns: 1fr 1fr; } }
  details { margin-top: .75rem; }
</style>
</head>
<body>
  <h1>Backbone Lookup</h1>

  <form id="f">
    <input id="q" type="text" placeholder="e.g., Apple, Salesforce, Spotify" required autofocus />
    <button type="submit">Fetch Backbone</button>
  </form>

  <div id="status"></div>
  <pre id="out">{}</pre>

  <hr style="margin:1.25rem 0" />
  <h1>Moat LLM</h1>
  <div class="row">
    <div>
      <button id="runLLM" disabled>Run Moat LLM</button>
      <div id="llmStatus"></div>
      <pre id="llmOut"><!-- LLM JSON will appear here --></pre>
    </div>
    <div>
      <details>
        <summary>Show generated Moat prompt (copy/paste for Python)</summary>
        <textarea id="promptBox" readonly></textarea>
      </details>
    </div>
  </div>

  <hr style="margin:1.25rem 0" />
  <h1>P/E LLM</h1>
  <div class="row">
    <div>
      <button id="runPE" disabled>Run P/E LLM</button>
      <div id="peStatus"></div>
      <pre id="peOut"><!-- P/E JSON will appear here --></pre>
    </div>
    <div>
      <details>
        <summary>Show generated P/E prompt (copy/paste for Python)</summary>
        <textarea id="pePromptBox" readonly></textarea>
      </details>
    </div>
  </div>

  <hr style="margin:1.25rem 0" />
  <h1>TTM Revenue LLM</h1>
  <div class="row">
    <div>
      <button id="runREV" disabled>Run TTM Revenue LLM</button>
      <div id="revStatus"></div>
      <pre id="revOut"><!-- Revenue JSON will appear here --></pre>
    </div>
    <div>
      <details>
        <summary>Show generated Revenue prompt (copy/paste for Python)</summary>
        <textarea id="revPromptBox" readonly></textarea>
      </details>
    </div>
  </div>

<script>
(() => {
  const $ = s => document.querySelector(s);
  const form = $("#f"), input = $("#q"), out = $("#out"), status = $("#status");
  const runBtn = $("#runLLM"), llmOut = $("#llmOut"), llmStatus = $("#llmStatus"), promptBox = $("#promptBox");
  const runPEBtn = $("#runPE"), peOut = $("#peOut"), peStatus = $("#peStatus"), pePromptBox = $("#pePromptBox");
  const runREVBtn = $("#runREV"), revOut = $("#revOut"), revStatus = $("#revStatus"), revPromptBox = $("#revPromptBox");

  const api = (path, params) => {
    const u = new URL(path, window.location.origin);
    Object.entries(params || {}).forEach(([k,v]) => u.searchParams.set(k, v));
    return u.toString();
  };
  const pretty = obj => JSON.stringify(obj, null, 2);

  async function fetchJson(url, {signal, method = 'GET', body} = {}) {
    const res = await fetch(url, { credentials: "include", signal, method, headers: { 'Content-Type': 'application/json' }, body });
    const text = await res.text();
    try {
      const data = JSON.parse(text);
      if (!res.ok) throw Object.assign(new Error(data?.detail || res.statusText), { status: res.status, data });
      return data;
    } catch {
      if (!res.ok) throw Object.assign(new Error("Non-JSON response"), { status: res.status, raw: text });
      return { raw: text };
    }
  }

  // Timer utility: shows "Thinking… <secs>s" and updates every second
    function makeTimer(el, label = 'Thinking/Searching'){
    let startTs = 0, id = null;
    const fmt = (s)=> `${label}… ${s}s`;
    return {
        start(){
        startTs = Date.now();
        el.textContent = fmt(0);
        id = setInterval(()=>{
            const secs = Math.floor((Date.now()-startTs)/1000);
            el.textContent = fmt(secs);
        }, 1000);
        },
        stop(doneText){
        if (id) clearInterval(id);
        if (doneText) el.textContent = doneText;
        }
    };
    }

  // Helper to POST prompts to backend (tries both API paths)
  async function postPrompt(prompt, signal){
    const endpoints = ['/api/moat_evaluation','/moat_evaluation'];
    let lastErr = null;
    for (const ep of endpoints){
      try { return await fetchJson(ep, { method: 'POST', signal, body: JSON.stringify({ prompt }) }); }
      catch (e){ lastErr = e; }
    }
    throw lastErr || new Error('No LLM endpoint reachable');
  }

  let companyJson = null;

  // -------- Helpers --------
  function pickTicker(bb){
    const arr = Array.isArray(bb?.tickers) ? bb.tickers : [];
    if (arr.length && arr[0]?.symbol) return arr[0].symbol.toUpperCase();
    return null;
  }

  // -------- Moat prompt (dynamic scope) --------
  function buildMoatPrompt(companyJson) {
    const bb = companyJson?.backbone || {};
    const name = bb.canonical_name || companyJson?.query || "<unknown>";
    const aliases = Array.isArray(bb.aliases) ? bb.aliases : [];
    const domain = bb.domain || "";

    let scopeLine = `Task: Produce a Moat Score for the company referenced in the JSON (focus on ${name}).`;
    const looksLikeSlack = /slack/i.test(domain) || aliases.some(a => /slack/i.test(a));
    const looksLikeSalesforce = /salesforce/i.test(name);
    if (looksLikeSlack && looksLikeSalesforce) {
      scopeLine = `Task: Produce a Moat Score focusing on the Slack product/business within Salesforce (CRM). Where appropriate, distinguish Slack-specific vs. Salesforce corporate-level dynamics.`;
    }

    const prompt = `\nYou are an equity research assistant. Use web search to verify all claims and provide citations.\nCompany input (JSON):\n${pretty(companyJson)}\n\n${scopeLine}\nScore nine criteria (0–10 each), with 1–3 sentences of rationale per criterion and reputable citations (\"receipts\"). Then provide a short synthesis explaining the overall moat.\n\nScoring criteria (each 0–10):\n1) Market leadership & sustainable share\n2) Network effects & switching costs\n3) Valuable IP & patents\n4) Brand strength & customer loyalty\n5) Durable cost advantages (scale, proprietary tech)\n6) Regulatory barriers & exclusive licenses\n7) Distribution network (direct, partners, enterprise channel)\n8) Pricing power (sustained ability to raise price/mix)\n9) Consistent, impactful innovation & R&D\n\nOutput format (JSON only):\n{\n  \"moat_score\": <0-100 integer, average of the 9 criteria × 10, round to nearest whole>,\n  \"criteria\": [ ... ],\n  \"summary\": \"<3–5 sentence synthesis>\",\n  \"notes\": {\n    \"what_is_scope\": \"${looksLikeSlack && looksLikeSalesforce ? 'Slack within Salesforce' : name}\",\n    \"data_as_of\": \"<today’s date in YYYY-MM-DD>\",\n    \"method\": \"Each criterion scored 0–10 using public sources; average × 10 → Moat Score.\"\n  }\n}\n\nInstructions & constraints:\n- Treat the JSON as the resolved identity.\n- ALWAYS use web_search to confirm market share, DAU/MAU, retention, pricing, competition, distribution/partners, and regulatory issues.\n- Prefer primary/authoritative sources (investor materials, regulatory docs, Gartner/IDC/Forrester, WSJ/FT/Bloomberg).\n- Provide ≥1 citation per criterion (≥2 for market share & network effects).\n- Keep each rationale crisp (≤60 words). Avoid marketing language. Do not output anything except the JSON block.`;
    return prompt;
  }

  // -------- P/E prompt (your supplied structure) --------
  function buildPEPrompt(companyJson){
    const bb = companyJson?.backbone || {};
    const aliases = Array.isArray(bb.aliases) ? bb.aliases : [];
    const ticker = pickTicker(bb);
    const isSlackInsideSalesforce = (/slack/i.test(bb?.domain||"") || aliases.some(a=>/slack/i.test(a))) && /salesforce/i.test(bb?.canonical_name||"");
    const parentTicker = isSlackInsideSalesforce ? 'CRM' : (ticker || 'N/A');

    const pyLikeJSON = pretty({ query: companyJson.query, backbone: bb });

    const prompt = `\nYou are a capital-markets analyst. Use web_search to retrieve fresh figures and cite your sources.\n\nCompany input (JSON):\n${pyLikeJSON}\n\nTask: Return **Price/Earnings (P/E) ratios** for the *public parent issuer*. Detected ticker: **${parentTicker}**. Report: PE 2Y ago, PE 1Y ago, Trailing P/E (current TTM), Forward P/E (FY+1), 2-Year Forward P/E (FY+2).\n\n**Requirements**\n1) Identity resolution as above. If private, return N/A with explanation.\n2) Sources: Macrotrends, Yahoo/Nasdaq, filings, or major financial press. Direct URLs.\n3) Method: use a single current price source; anchor historical to nearest quarter-ends; show EPS used for forward P/Es.\n\n**Output format (JSON only)**:\n{ ... same as your spec ... }\n\nConstraints:\n- Output only the JSON block.`;

    return prompt;
  }

  // -------- TTM Revenue prompt (your supplied structure) --------
  function buildRevenuePrompt(companyJson){
    const bb = companyJson?.backbone || {};
    const aliases = Array.isArray(bb.aliases) ? bb.aliases : [];
    const isSlackInsideSalesforce = (/slack/i.test(bb?.domain||"") || aliases.some(a=>/slack/i.test(a))) && /salesforce/i.test(bb?.canonical_name||"");
    const pyLikeJSON = pretty({ query: companyJson.query, backbone: bb });

    const prompt = `\nYou are a capital-markets analyst bot. Use web_search to pull authoritative figures and citations.\n\nCompany input (JSON):\n${pyLikeJSON}\n\nObjective:\nReturn the company's **Trailing 12-Month (TTM) revenue** and **TTM revenue YoY growth** for the **last 17 fiscal quarters**, plus **projected revenues for the next 4 quarters**. If the input refers to a product/brand inside a public parent${isSlackInsideSalesforce ? ' (Slack inside Salesforce)' : ''}, compute using the **public parent ticker**. If the entity is private and does not publish quarterly financials, return an explanation and do not fabricate numbers.\n\nKey rules:\n1) Identity resolution as above.\n2) Use the company's own reporting basis for top-line and keep it consistent. State the basis.\n3) TTM computation: sum last 4 quarters; YoY vs TTM 4 quarters prior; align to fiscal quarters.\n4) Sources preference: filings/press releases/IR; SEC; reputable aggregators; direct URLs.\n5) Forecasts: quarterly consensus; if only annual, distribute by seasonality with explanation; else nulls.\n6) Currency/units: return currency and common unit; include fiscal quarter end dates.\n7) Data as-of: include retrieval timestamp and most recent quarter label.\n8) No fabrication: if private with no data, explain and leave arrays empty.\n\nOutput format (JSON only):\n{ ... same as your spec ... }\n\nConstraints:\n- Use web_search to find sources for every number.\n- Do not output anything except the JSON block.`;

    return prompt;
  }

  function enableLLM(companyJson) {
    // Build all prompts and enable all buttons
    const moatPrompt = buildMoatPrompt(companyJson);
    promptBox.value = moatPrompt;
    runBtn.disabled = false;

    const pePrompt = buildPEPrompt(companyJson);
    pePromptBox.value = pePrompt;
    runPEBtn.disabled = false;

    const revPrompt = buildRevenuePrompt(companyJson);
    revPromptBox.value = revPrompt;
    runREVBtn.disabled = false;
  }

  // -------- Backbone fetch --------
  form.addEventListener("submit", async (e) => {
    e.preventDefault();
    const name = input.value.trim(); if (!name) return;
    status.textContent = "Fetching…"; out.textContent = "{}"; llmOut.textContent = ""; peOut.textContent = ""; revOut.textContent = ""; llmStatus.textContent = ""; peStatus.textContent = ""; revStatus.textContent = ""; runBtn.disabled = true; runPEBtn.disabled = true; runREVBtn.disabled = true;

    const ctl = new AbortController();
    const t = setTimeout(() => ctl.abort(), 20000);

    try {
      const url = api("/api/backbone", { company_name: name });
      const data = await fetchJson(url, { signal: ctl.signal });
      companyJson = { query: name, backbone: data };
      out.textContent = pretty(companyJson);
      status.textContent = "Done.";
      enableLLM(companyJson);
    } catch (err) {
      out.textContent = pretty({ error: err?.message || "Request failed", detail: err?.data?.detail ?? err?.raw ?? null });
      status.textContent = "Failed.";
    } finally {
      clearTimeout(t);
    }
  });

  // -------- Moat button --------
  runBtn.addEventListener('click', async () => {
    if (!companyJson) return;
    const prompt = buildMoatPrompt(companyJson);

    const llmTimer = makeTimer(llmStatus, 'Thinking/Searching');
    llmOut.textContent = '';
    llmTimer.start();


    const ctl = new AbortController();
    const t = setTimeout(() => ctl.abort(), 600000); // 10 minutes

    try {
      const data = await postPrompt(prompt, ctl.signal);
      const text = typeof data?.output_text === 'string' ? data.output_text : (data.raw || JSON.stringify(data));
      llmOut.textContent = text;
      llmTimer.stop('Done.');
    } catch (err) {
      llmOut.textContent = pretty({ error: err?.message || 'LLM request failed', detail: err?.data?.detail ?? err?.raw ?? null });
      llmTimer.stop('Failed.');
    } finally {
      clearTimeout(t);
    }
  });

  // -------- P/E button --------
  runPEBtn.addEventListener('click', async () => {
    if (!companyJson) return;
    const prompt = buildPEPrompt(companyJson);

    const peTimer = makeTimer(peStatus, 'Thinking/Searching');
    peOut.textContent = '';
    peTimer.start();


    const ctl = new AbortController();
    const t = setTimeout(() => ctl.abort(), 600000); // 10 minutes

    try {
      const data = await postPrompt(prompt, ctl.signal);
      const text = typeof data?.output_text === 'string' ? data.output_text : (data.raw || JSON.stringify(data));
      peOut.textContent = text;
      peTimer.stop('Done.');
    } catch (err) {
      peOut.textContent = pretty({ error: err?.message || 'P/E LLM request failed', detail: err?.data?.detail ?? err?.raw ?? null });
      peTimer.stop('Failed.');
    } finally {
      clearTimeout(t);
    }
  });

  // -------- TTM Revenue button --------
  runREVBtn.addEventListener('click', async () => {
    if (!companyJson) return;
    const prompt = buildRevenuePrompt(companyJson);

    const revTimer = makeTimer(revStatus, 'Thinking/Searching');
    revOut.textContent = '';
    revTimer.start();


    const ctl = new AbortController();
    const t = setTimeout(() => ctl.abort(), 600000); // 10 minutes

    try {
      const data = await postPrompt(prompt, ctl.signal);
      const text = typeof data?.output_text === 'string' ? data.output_text : (data.raw || JSON.stringify(data));
      revOut.textContent = text;
      revTimer.stop('Done.');
    } catch (err) {
      revOut.textContent = pretty({ error: err?.message || 'Revenue LLM request failed', detail: err?.data?.detail ?? err?.raw ?? null });
      revTimer.stop('Failed.');
    } finally {
      clearTimeout(t);
    }
  });

  input.addEventListener("keydown", (e) => { if (e.key === "Enter") form.requestSubmit(); });
})();
</script>
</body>
</html>
