<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Fantasiagenesis Â· Draw</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root { color-scheme: light; }
    * { box-sizing: border-box; }
    body { font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial; margin: 20px; }
    header h1 { margin: 0 0 .25rem 0; font-size: clamp(1.2rem, 2.4vw, 1.6rem); }
    .muted { opacity: .85; }
    .row { display: flex; gap: .5rem; align-items: center; flex-wrap: wrap; }
    .panel { border: 1px solid #e3e3e6; border-radius: .6rem; padding: .9rem 1rem; background: #fafafb; }
    .panel + .panel { margin-top: .9rem; }
    input[type="text"], input[type="email"], textarea {
      width: min(92vw, 820px); padding: .6rem .7rem; border: 1px solid #cdd0d5; border-radius: .55rem; background: #fff;
    }
    input[type="text"], input[type="email"] { height: 2.4rem; }
    textarea { min-height: 7rem; }
    button { padding: .6rem .9rem; border: 0; border-radius: .55rem; cursor: pointer; background: #0b5cff; color: #fff; }
    button.secondary { background: #4b5563; }
    button.ghost { background: #eef2ff; color: #1f2937; border: 1px solid #c7d2fe; }
    .status { font-size: .92rem; margin-top: .4rem; min-height: 1.2em; }
    .status.error { color: #b00020; white-space: pre-wrap; }
    .status.ok { color: #065f46; }
    .grid { display: grid; gap: .65rem; }
    .cols { display: grid; gap: .65rem; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); }
    .card { border: 1px solid #e5e7eb; border-radius: .6rem; background: #fff; padding: .6rem .7rem; }
    .card h3 { margin: 0 0 .25rem 0; font-size: 1rem; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }
    .inline { display: inline-flex; align-items: center; gap: .5rem; }
    .hint { margin-top:.8rem; font-size:.9rem; color:#6b7280; }
    .hint a { color:#0b5cff; text-decoration:none; }
    .hint a:hover { text-decoration:underline; }
    .tasks { font-size:.9rem; margin-top:.35rem; }
    .tasks .item { padding:.2rem .35rem; border:1px dashed #cbd5e1; border-radius:.4rem; margin:.25rem 0; background:#fff; }
    .spinner { display:inline-block; width:1em; height:1em; border:.15em solid #dbeafe; border-top-color:#3b82f6; border-radius:50%; animation:spin 1s linear infinite; vertical-align:-.2em; }
    @keyframes spin { to { transform: rotate(360deg); } }

    /* repeater row */
    .vision-row { display:grid; grid-template-columns: 1fr 1fr auto; gap:.5rem; align-items:center; }
    .vision-row input[type="text"] { width: 100%; }
    .vision-actions { display:flex; gap:.4rem; }
    .remove-btn { background:#ef4444; }
  </style>
</head>
<body>
  <header class="row" style="justify-content: space-between;">
    <div>
      <h1>Fantasiagenesis Â· Draw</h1>
      <div class="muted">Create <strong>pictures</strong> and <strong>focuses</strong> from a vision via JID.</div>
    </div>
    <nav class="row">
      <a class="inline" href="/pictures" title="Paper">ðŸ“„ <span class="muted">Pictures</span></a>
    </nav>
  </header>

  <!-- Email -->
  <section class="panel">
    <div class="row">
      <input type="email" id="email" placeholder="Email (optional but recommended for persistence)" />
      <button id="saveEmail" class="secondary" type="button">Save email</button>
    </div>
    <div id="svcStatus" class="status"></div>
  </section>

  <!-- Create Pictures (multi-vision) -->
  <section class="panel">
    <h2 style="margin:.1rem 0 .6rem 0;">Create Pictures</h2>
    <div class="grid">
      <div class="row" style="justify-content: space-between;">
        <div class="muted">Submit one or more vision + focus entries.</div>
        <div class="vision-actions">
          <button id="btnAddVision" type="button" class="ghost">Add vision</button>
          <button id="btnClearVisions" type="button" class="secondary">Clear all</button>
        </div>
      </div>

      <div id="visionsMount" class="grid"></div>

      <div class="row">
        <input id="countGlobal" type="text" inputmode="numeric" pattern="[0-9]*" placeholder="Count for each (optional, e.g., 3)" style="width:14rem" />
        <button id="btnCreatePictures" type="button">Create pictures</button>
      </div>

      <div id="statusPictures" class="status"></div>
      <div id="taskList" class="tasks"></div>
      <div id="picturesOut" class="cols"></div>
      <div class="hint">Once your pictures appear, open the <a href="/pictures" target="_blank">Pictures</a> page to view or run architects for them.</div>
    </div>
  </section>

  <!-- Create Focuses -->
  <section class="panel">
    <h2 style="margin:.1rem 0 .6rem 0;">Create Focuses</h2>
    <div class="grid">
      <input id="visionInputForFocuses" type="text" placeholder="Vision (creating solar microgrids in the city of Chicago)" />
      <div class="row">
        <button id="btnCreateFocuses" type="button">Create focuses</button>
      </div>
      <div id="statusFocuses" class="status"></div>
      <div id="focusesOut" class="grid"></div>
    </div>
  </section>

  <!-- Usage -->
  <section class="panel">
    <div class="row">
      <button id="btnUsage" class="ghost" type="button" title="Show todayâ€™s token usage from JID">Show usage today</button>
      <div id="usageStatus" class="status"></div>
    </div>
    <pre id="usageOut" class="mono" style="display:none; max-width: min(92vw, 820px); overflow:auto; background:#f6f7f9; border:1px solid #e5e7eb; border-radius:.5rem; padding:.6rem .7rem;"></pre>
  </section>

  <script>
    const LS_EMAIL = 'fg_user_email';
    const EP = {
      health: '/jid/healthz',
      usageToday: '/read/usage',
      createPictures: '/jid/create_pictures',              // async submit (batch)
      statusPictures: '/jid/create_pictures/status',       // poll status
      resultPictures: '/jid/create_pictures/result',       // optional
      createFocuses: '/jid/create_focuses'
    };

    const $ = (id) => document.getElementById(id);
    function setText(el, msg, cls = '') {
      if (!el) return;
      el.className = 'status ' + (cls || '');
      el.textContent = msg || '';
    }
    async function fetchJSON(url, options = {}, timeoutMs = 600000) {
      const controller = new AbortController();
      const timer = setTimeout(() => controller.abort(), timeoutMs);
      try {
        const resp = await fetch(url, { ...options, signal: controller.signal });
        const ct = resp.headers.get('content-type') || '';
        const isJSON = ct.includes('application/json');
        const data = isJSON ? await resp.json() : await resp.text();
        if (!resp.ok) {
          const detail = isJSON ? (data?.error || data?.detail || JSON.stringify(data)) : data;
          throw new Error(detail || `HTTP ${resp.status}`);
        }
        return data;
      } finally { clearTimeout(timer); }
    }
    function postJSON(url, body, timeoutMs) {
      return fetchJSON(url, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(body || {})
      }, timeoutMs);
    }
    function loadEmail() {
      const v = (localStorage.getItem(LS_EMAIL) || '').trim().toLowerCase();
      if (v) $('email').value = v;
    }
    function saveEmail() {
      const v = ($('email').value || '').trim().toLowerCase();
      if (v) localStorage.setItem(LS_EMAIL, v);
      else localStorage.removeItem(LS_EMAIL);
    }

    // ---------- Vision rows (repeater) ----------
    function makeRow(idSuffix) {
      const wrap = document.createElement('div');
      wrap.className = 'vision-row';
      wrap.dataset.rowId = idSuffix;

      const vision = document.createElement('input');
      vision.type = 'text';
      vision.placeholder = 'Vision (e.g., Harnessing energy using dirt)';
      vision.className = 'vision-input';
      vision.autocomplete = 'off';

      const focus = document.createElement('input');
      focus.type = 'text';
      focus.placeholder = 'Focus (optional, e.g., Microbial fuel cells in campus garden)';
      focus.className = 'focus-input';
      focus.autocomplete = 'off';

      const actions = document.createElement('div');
      actions.className = 'vision-actions';

      const remove = document.createElement('button');
      remove.type = 'button';
      remove.className = 'remove-btn';
      remove.textContent = 'Remove';
      remove.addEventListener('click', () => {
        wrap.remove();
      });

      actions.appendChild(remove);
      wrap.append(vision, focus, actions);
      return wrap;
    }

    function addVisionRow(prefill = {}) {
      const idSuffix = Math.random().toString(36).slice(2, 8);
      const row = makeRow(idSuffix);
      if (prefill.vision) row.querySelector('.vision-input').value = prefill.vision;
      if (prefill.focus)  row.querySelector('.focus-input').value  = prefill.focus;
      $('visionsMount').appendChild(row);
    }

    function clearVisions() {
      $('visionsMount').innerHTML = '';
    }

    function collectVisionItems(email, countGlobal) {
      const rows = Array.from(document.querySelectorAll('#visionsMount .vision-row'));
      const items = [];
      for (const r of rows) {
        const v = (r.querySelector('.vision-input')?.value || '').trim();
        const f = (r.querySelector('.focus-input')?.value || '').trim();
        if (!v) continue; // skip empty rows
        const item = { vision: v };
        if (f) item.focus = f;
        if (email) item.email = email;
        if (!Number.isNaN(countGlobal) && countGlobal > 0) item.count = countGlobal;
        items.push(item);
      }
      return items;
    }

    // ---- Render helpers -------------------------------------------------------
    function renderPictures(block) {
      const mount = $('picturesOut'); mount.innerHTML = '';
      const pics = Array.isArray(block?.pictures) ? block.pictures : [];
      if (!pics.length) { mount.innerHTML = '<div class="muted">Done.</div>'; return; }
      for (const p of pics) {
        const card = document.createElement('div'); card.className = 'card';
        const h = document.createElement('h3'); h.textContent = p.title || 'Untitled picture';
        const d = document.createElement('div'); d.className = 'muted'; d.textContent = p.description || '';
        const fn = document.createElement('div'); fn.style.marginTop = '.35rem';
        fn.innerHTML = p.function ? `<strong>Function:</strong> ${p.function}` : '';
        const meta = document.createElement('div'); meta.style.marginTop = '.25rem';
        meta.innerHTML = [
          p.id ? `<span class="mono">id:${p.id}</span>` : '',
          p.status ? `<span class="mono">status:${p.status}</span>` : ''
        ].filter(Boolean).join(' Â· ');
        card.append(h, d);
        if (fn.innerHTML) card.append(fn);
        if (meta.innerHTML) card.append(meta);
        mount.append(card);
      }
    }

    function renderFocuses(block) {
      const mount = $('focusesOut');
      mount.innerHTML = '';
      const items = Array.isArray(block?.focuses) ? block.focuses : Array.isArray(block) ? block : [];
      if (!items.length) { mount.innerHTML = '<div class="muted">No focuses returned.</div>'; return; }
      for (let i = 0; i < items.length; i++) {
        const f = items[i] ?? {};
        const dim = f.dimension || f.title || f.name || `Focus ${i + 1}`;
        const text = (typeof f === 'string') ? f : f.focus || f.description || '';
        const card = document.createElement('div'); card.className = 'card';
        const head = document.createElement('div'); head.innerHTML = `<strong>${dim}</strong>`;
        const body = document.createElement('div'); body.className = 'muted'; body.textContent = text;
        card.append(head);
        if (text) card.append(body);
        mount.append(card);
      }
    }

    // ---- Queue/Status UI ------------------------------------------------------
    function renderTasks(taskIds, statuses) {
      const el = $('taskList');
      el.innerHTML = '';
      taskIds.forEach((id) => {
        const s = statuses[id] || 'queued';
        const row = document.createElement('div');
        row.className = 'item mono';
        row.innerHTML = `<span class="mono">task:${id}</span> Â· <strong>${s}</strong> ${s==='running'||s==='queued' ? '<span class="spinner" aria-label="loading"></span>' : ''}`;
        el.append(row);
      });
    }

    function mergePictureResults(taskBlocks) {
      const merged = { pictures: [] };
      for (const blk of taskBlocks) {
        const body = blk?.result || blk?.body || blk;
        if (body && Array.isArray(body.pictures)) merged.pictures.push(...body.pictures);
        if (body?.data && Array.isArray(body.data.pictures)) merged.pictures.push(...body.data.pictures);
      }
      return merged;
    }

    async function pollUntilDone(taskIds, onTick) {
      let delay = 1000;
      const maxDelay = 5000;
      const statuses = Object.fromEntries(taskIds.map(id => [id, 'queued']));
      const done = new Set();
      const results = [];

      while (done.size < taskIds.length) {
        const q = encodeURIComponent(taskIds.join(','));
        const payload = await fetchJSON(`${EP.statusPictures}?ids=${q}&include_result=true`, {}, 600000);
        const tasks = Array.isArray(payload?.tasks) ? payload.tasks : [];

        tasks.forEach(t => {
          statuses[t.task_id] = t.status || 'unknown';
          if ((t.status === 'done' || t.status === 'error') && !done.has(t.task_id)) {
            done.add(t.task_id);
            results.push(t);
          }
        });

        onTick(statuses, results);

        if (done.size >= taskIds.length) break;
        await new Promise(r => setTimeout(r, delay));
        delay = Math.min(maxDelay, delay + 1000);
      }
      return results;
    }

    // ---- Actions --------------------------------------------------------------
    async function doCreatePictures() {
      const email = ($('email').value || '').trim().toLowerCase();
      const countGlobal = parseInt(($('countGlobal').value || '').trim(), 10);

      // gather items
      const items = collectVisionItems(email, countGlobal);
      if (!items.length) {
        setText($('statusPictures'), 'Add at least one vision.', 'error');
        return;
      }

      // submit batch
      setText($('statusPictures'), `Submitting ${items.length} item(s) to queueâ€¦`);
      $('picturesOut').innerHTML = '';
      $('taskList').innerHTML = '';

      try {
        const submit = await postJSON(EP.createPictures, { items }, 600000);
        const taskIds = Array.isArray(submit?.task_ids) ? submit.task_ids : [];

        if (!taskIds.length) { setText($('statusPictures'), 'No task_ids returned.', 'error'); return; }

        setText($('statusPictures'), `Queued ${taskIds.length} task(s).`);
        renderTasks(taskIds, Object.fromEntries(taskIds.map(id => [id, 'queued'])));

        // poll
        const finished = await pollUntilDone(taskIds, (statuses, results) => {
          renderTasks(taskIds, statuses);
          const running = Object.values(statuses).filter(s => s === 'running' || s === 'queued').length;
          setText($('statusPictures'), running ? `Processingâ€¦ (${taskIds.length - running}/${taskIds.length} done)` : 'Finalizingâ€¦');
        });

        const anyErr = finished.find(t => t.status === 'error');
        if (anyErr) {
          setText($('statusPictures'), `One or more tasks failed: ${anyErr.error || 'unknown error'}`, 'error');
        } else {
          setText($('statusPictures'), 'Done.', 'ok');
        }

        const merged = mergePictureResults(finished);
        renderPictures(merged);

        if (email) localStorage.setItem(LS_EMAIL, email);
      } catch (e) {
        setText($('statusPictures'), `Failed: ${e.message || e}`, 'error');
      }
    }

    async function doCreateFocuses() {
      const email = ($('email').value || '').trim().toLowerCase();
      const vision = ($('visionInputForFocuses').value || '').trim();
      if (!vision) { setText($('statusFocuses'), 'Enter a vision.', 'error'); return; }
      setText($('statusFocuses'), 'Creating focusesâ€¦');
      try {
        const payload = { vision };
        if (email) payload.email = email;
        const res = await postJSON(EP.createFocuses, payload, 600000);
        renderFocuses(res?.data || res?.result || res);
        setText($('statusFocuses'), 'Done.', 'ok');
        if (email) saveEmail();
      } catch (e) {
        setText($('statusFocuses'), `Failed: ${e.message || e}`, 'error');
      }
    }

    async function doUsage() {
      setText($('usageStatus'), 'Loading usageâ€¦');
      $('usageOut').style.display = 'none';
      try {
        const d = await fetchJSON(EP.usageToday, {}, 15000);
        $('usageOut').textContent = JSON.stringify(d, null, 2);
        $('usageOut').style.display = 'block';
        setText($('usageStatus'), 'Usage loaded.', 'ok');
      } catch (e) {
        setText($('usageStatus'), `Failed: ${e.message || e}`, 'error');
      }
    }

    // ---- Init -----------------------------------------------------------------
    (function init() {
      loadEmail();
      $('saveEmail').addEventListener('click', () => { saveEmail(); setText($('svcStatus'), 'Email saved.', 'ok'); });

      $('btnAddVision').addEventListener('click', () => addVisionRow());
      $('btnClearVisions').addEventListener('click', clearVisions);
      $('btnCreatePictures').addEventListener('click', doCreatePictures);
      $('btnCreateFocuses').addEventListener('click', doCreateFocuses);
      $('btnUsage').addEventListener('click', doUsage);

      // start with one empty row for convenience
      addVisionRow();
    })();
  </script>
</body>
</html>
