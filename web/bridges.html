<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Bridge Builder</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<style>
  body {
    font-family: Arial, sans-serif;
    background: #f4f4f4;
    padding: 20px;
    color: #333;
  }
  .container {
    max-width: 1100px;
    margin: 0 auto;
    background: #fff;
    padding: 24px 32px;
    border-radius: 10px;
    box-shadow: 0 2px 8px rgba(0,0,0,0.1);
  }
  h1 {
    margin-top: 0;
  }
  .actions {
    display: flex;
    flex-wrap: wrap;
    gap: 24px;
    margin-bottom: 30px;
  }
  .card {
    flex: 1 1 320px;
    background: #fafafa;
    border: 1px solid #ddd;
    border-radius: 8px;
    padding: 16px;
  }
  label {
    font-weight: bold;
    display: block;
    margin-top: 8px;
  }
  input[type="text"], select {
    width: 100%;
    padding: 8px 10px;
    border: 1px solid #ccc;
    border-radius: 6px;
    margin-top: 4px;
    font-size: 14px;
  }
  select {
    height: 140px;
  }
  button {
    background: #0066cc;
    color: #fff;
    border: none;
    border-radius: 6px;
    padding: 10px 14px;
    cursor: pointer;
    font-size: 14px;
    margin-top: 12px;
  }
  button.secondary {
    background: #555;
  }
  button:disabled {
    opacity: 0.6;
    cursor: wait;
  }
  .status {
    margin-top: 10px;
    font-size: 14px;
  }
  .bridges-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-top: 30px;
  }
  .bridge-list {
    margin-top: 16px;
    display: flex;
    flex-direction: column;
    gap: 16px;
  }
  .bridge-item {
    border: 1px solid #ddd;
    border-radius: 8px;
    background: #fff;
    padding: 16px;
  }
  .bridge-item header {
    font-weight: bold;
    margin-bottom: 4px;
  }
  .bridge-meta {
    font-size: 13px;
    color: #555;
    margin-bottom: 10px;
  }
  details {
    margin-top: 8px;
  }
  details summary {
    cursor: pointer;
    font-weight: bold;
  }
  pre {
    background: #fafafa;
    border: 1px solid #eee;
    padding: 10px;
    border-radius: 6px;
    white-space: pre-wrap;
    max-height: 250px;
    overflow: auto;
  }
  .task-list {
    max-height: 260px;
    overflow-y: auto;
    border: 1px solid #eee;
    border-radius: 6px;
    padding: 8px;
    background: #fff;
    margin-top: 10px;
  }
  .task-item {
    border-bottom: 1px solid #f0f0f0;
    padding: 6px 0;
    font-size: 13px;
  }
  .task-item:last-child {
    border-bottom: none;
  }
  .task-item strong {
    text-transform: uppercase;
    font-size: 11px;
    letter-spacing: 0.05em;
  }
  .task-item .meta {
    display: block;
    color: #666;
    margin-top: 2px;
  }
  .status-queued strong { color: #0066cc; }
  .status-running strong { color: #cc7a00; }
  .status-done strong { color: #1a7f37; }
  .status-error strong { color: #cc0000; }
</style>
</head>
<body>
<div class="container">
  <h1>Bridge Builder</h1>
  <p>
    Select two particle files to generate a bridge using the /dirt/bridge endpoint,
    then review recent bridge outputs. <a href="/boxes.html">&larr; Back to boxes</a>
  </p>

  <div class="actions">
    <div class="card">
      <h3>Select Particles</h3>
      <label for="filterA">Filter Node A</label>
      <input id="filterA" type="text" placeholder="Search slug/path for node A">
      <select id="nodeA"></select>

      <label for="filterB">Filter Node B</label>
      <input id="filterB" type="text" placeholder="Search slug/path for node B">
      <select id="nodeB"></select>

      <button id="swapBtn" class="secondary">Swap Nodes</button>
    </div>

    <div class="card">
      <h3>Build Bridge</h3>
      <p>After loading particles, choose any two and click build.</p>
      <button id="buildBtn">Build Bridge</button>
      <div id="buildStatus" class="status"></div>
      <p style="font-size:13px;color:#666;margin-top:12px;">
        Tip: Use <a href="/particle_test.html">Particle Tester</a> to inspect file excerpts.
      </p>
    </div>

    <div class="card">
      <h3>Queue Monitor & Batch</h3>
      <div id="queueSummary" class="status"></div>
      <button id="queueRefreshBtn" class="secondary">Refresh Queue</button>
      <div id="taskList" class="task-list"></div>
      <h4 style="margin-top:16px;">Random Bridges</h4>
      <label for="randomCount">How many?</label>
      <input id="randomCount" type="number" min="1" max="50" value="3">
      <button id="randomBtn">Enqueue Random Bridges</button>
      <div id="randomStatus" class="status"></div>
    </div>
  </div>

  <div class="bridges-header">
    <h2>Recent Bridges</h2>
    <div>
      <label for="limitSelect" style="font-weight:normal;font-size:14px;margin-right:6px;">Show</label>
      <select id="limitSelect" style="width:80px;height:auto;">
        <option value="10">10</option>
        <option value="25" selected>25</option>
        <option value="50">50</option>
      </select>
      <button id="refreshBtn" class="secondary" style="margin-top:0;margin-left:8px;">Refresh</button>
    </div>
  </div>
  <div id="historyStatus" class="status"></div>
  <div id="bridgeList" class="bridge-list"></div>
</div>

<script>
const nodeASelect = document.getElementById("nodeA");
const nodeBSelect = document.getElementById("nodeB");
const filterAInput = document.getElementById("filterA");
const filterBInput = document.getElementById("filterB");
const buildBtn = document.getElementById("buildBtn");
const queueSummary = document.getElementById("queueSummary");
const taskList = document.getElementById("taskList");
const queueRefreshBtn = document.getElementById("queueRefreshBtn");
const randomCountInput = document.getElementById("randomCount");
const randomBtn = document.getElementById("randomBtn");
const randomStatus = document.getElementById("randomStatus");
const swapBtn = document.getElementById("swapBtn");
const buildStatus = document.getElementById("buildStatus");
const historyStatus = document.getElementById("historyStatus");
const limitSelect = document.getElementById("limitSelect");
const bridgeList = document.getElementById("bridgeList");
const refreshBtn = document.getElementById("refreshBtn");

let particles = [];

function setStatus(el, message, cls = "") {
  el.textContent = message || "";
  el.className = cls ? `status ${cls}` : "status";
}

function optionLabel(p) {
  return `#${p.id} · ${p.box_slug}/${p.rel_path}`;
}

function renderParticleSelect(selectEl, filterValue) {
  const lower = (filterValue || "").toLowerCase();
  const items = particles.filter(p =>
    !lower ||
    optionLabel(p).toLowerCase().includes(lower) ||
    (p.name || "").toLowerCase().includes(lower)
  );

  const current = selectEl.value;
  selectEl.innerHTML = "";
  items.forEach(p => {
    const opt = document.createElement("option");
    opt.value = String(p.id);
    opt.textContent = optionLabel(p);
    selectEl.appendChild(opt);
  });
  if (items.length && current) {
    const found = items.find(i => String(i.id) === current);
    if (found) {
      selectEl.value = current;
    }
  }
}

async function fetchJSON(url, options) {
  const res = await fetch(url, options);
  if (!res.ok) {
    const text = await res.text();
    throw new Error(text || `HTTP ${res.status}`);
  }
  return res.json();
}

async function loadParticles() {
  setStatus(buildStatus, "Loading boxes & particles…");
  try {
    const boxes = await fetchJSON("/dirt/boxes");
    const perBox = await Promise.all(
      boxes.map(box =>
        fetchJSON(`/dirt/boxes/${encodeURIComponent(box.slug)}/nodes`)
          .then(nodes => nodes.map(n => ({...n, box_slug: box.slug})))
      )
    );
    particles = perBox.flat().filter(n => n.kind === "particle");
    particles.sort((a, b) => a.id - b.id);
    renderParticleSelect(nodeASelect, filterAInput.value);
    renderParticleSelect(nodeBSelect, filterBInput.value);
    if (particles.length) {
      nodeASelect.selectedIndex = 0;
      nodeBSelect.selectedIndex = Math.min(1, particles.length - 1);
    }
    setStatus(buildStatus, `Loaded ${particles.length} particles. Ready.`);
  } catch (err) {
    console.error(err);
    setStatus(buildStatus, `Failed to load particles: ${err.message}`);
  }
}

async function buildBridge() {
  const nodeA = nodeASelect.value;
  const nodeB = nodeBSelect.value;
  if (!nodeA || !nodeB) {
    setStatus(buildStatus, "Select both node A and node B.");
    return;
  }
  if (nodeA === nodeB) {
    setStatus(buildStatus, "Pick two different nodes.");
    return;
  }

  buildBtn.disabled = true;
  setStatus(buildStatus, "Building bridge…");
  try {
    const data = await fetchJSON("/dirt/bridge", {
      method: "POST",
      headers: {"Content-Type": "application/json"},
      body: JSON.stringify({
        node_a_id: Number(nodeA),
        node_b_id: Number(nodeB)
      })
    });
    setStatus(buildStatus, `Bridge task ${data.task_id} queued.`);
    await loadQueueStatus();
    await loadBridgeHistory();
  } catch (err) {
    console.error(err);
    setStatus(buildStatus, `Bridge failed: ${err.message}`);
  } finally {
    buildBtn.disabled = false;
  }
}

function renderBridgeHistory(rows) {
  bridgeList.innerHTML = "";
  if (!rows.length) {
    bridgeList.innerHTML = "<p>No bridges yet.</p>";
    return;
  }

  rows.forEach(row => {
    const div = document.createElement("div");
    div.className = "bridge-item";
    div.innerHTML = `
      <header>Bridge #${row.id}</header>
      <div class="bridge-meta">
        ${new Date(row.created_at).toLocaleString()}<br>
        A (#${row.node_a.id}) ${row.node_a.box_slug}/${row.node_a.rel_path}<br>
        B (#${row.node_b.id}) ${row.node_b.box_slug}/${row.node_b.rel_path}
      </div>
    `;

    const promptDetails = document.createElement("details");
    const outputDetails = document.createElement("details");
    promptDetails.innerHTML = "<summary>Prompt</summary>";
    outputDetails.innerHTML = "<summary>Output</summary>";

    const promptPre = document.createElement("pre");
    promptPre.textContent = row.prompt || "(empty)";
    const outputPre = document.createElement("pre");
    outputPre.textContent = row.output || "(empty)";

    promptDetails.appendChild(promptPre);
    outputDetails.appendChild(outputPre);

    div.appendChild(promptDetails);
    div.appendChild(outputDetails);
    bridgeList.appendChild(div);
  });
}

async function loadBridgeHistory() {
  const limit = Number(limitSelect.value || 25);
  setStatus(historyStatus, "Loading bridges…");
  try {
    const rows = await fetchJSON(`/dirt/bridge?limit=${limit}`);
    renderBridgeHistory(rows);
    setStatus(historyStatus, `Showing ${rows.length} bridge(s).`);
  } catch (err) {
    console.error(err);
    setStatus(historyStatus, `Failed to load bridges: ${err.message}`);
  }
}

async function loadQueueStatus() {
  queueSummary.textContent = "Loading queue…";
  try {
    const data = await fetchJSON(`/dirt/bridge/tasks?limit=40`);
    renderQueue(data);
  } catch (err) {
    console.error(err);
    queueSummary.textContent = `Queue load failed: ${err.message}`;
  }
}

function renderQueue(data) {
  queueSummary.textContent =
    `Queue size: ${data.queue_size} | ` +
    `queued ${data.counts.queued || 0}, running ${data.counts.running || 0}, ` +
    `done ${data.counts.done || 0}, error ${data.counts.error || 0}`;

  taskList.innerHTML = "";
  if (!data.tasks.length) {
    taskList.innerHTML = "<div class=\"task-item\">No tasks yet.</div>";
    return;
  }
  data.tasks.forEach(task => {
    const div = document.createElement("div");
    div.className = `task-item status-${task.status}`;
    const nameA = task.node_a_id;
    const nameB = task.node_b_id;
    let line = `<strong>${task.status}</strong> task ${task.task_id.slice(0, 8)} `;
    if (task.bridge_id) {
      line += `→ bridge #${task.bridge_id}`;
    }
    div.innerHTML = `${line}<span class="meta">A ${nameA} ↔ B ${nameB} · ${task.created_at}</span>`;
    if (task.error) {
      const err = document.createElement("div");
      err.className = "meta";
      err.style.color = "#a40000";
      err.textContent = task.error;
      div.appendChild(err);
    }
    taskList.appendChild(div);
  });
}

async function enqueueRandomBridges() {
  let count = Number(randomCountInput.value || 1);
  if (!Number.isFinite(count) || count < 1) count = 1;
  count = Math.min(50, Math.max(1, Math.floor(count)));
  randomBtn.disabled = true;
  setStatus(randomStatus, `Queueing ${count} random bridge(s)…`);
  try {
    const data = await fetchJSON("/dirt/bridge/random_batch", {
      method: "POST",
      headers: {"Content-Type": "application/json"},
      body: JSON.stringify({ count })
    });
    setStatus(randomStatus, `Enqueued ${data.enqueued} tasks.`);
    await loadQueueStatus();
  } catch (err) {
    console.error(err);
    setStatus(randomStatus, `Random enqueue failed: ${err.message}`);
  } finally {
    randomBtn.disabled = false;
  }
}

filterAInput.addEventListener("input", () => renderParticleSelect(nodeASelect, filterAInput.value));
filterBInput.addEventListener("input", () => renderParticleSelect(nodeBSelect, filterBInput.value));
buildBtn.addEventListener("click", buildBridge);
swapBtn.addEventListener("click", () => {
  const temp = nodeASelect.value;
  nodeASelect.value = nodeBSelect.value;
  nodeBSelect.value = temp;
});
limitSelect.addEventListener("change", loadBridgeHistory);
refreshBtn.addEventListener("click", loadBridgeHistory);
queueRefreshBtn.addEventListener("click", loadQueueStatus);
randomBtn.addEventListener("click", enqueueRandomBridges);

document.addEventListener("DOMContentLoaded", async () => {
  await loadParticles();
  await loadBridgeHistory();
  await loadQueueStatus();
  setInterval(loadQueueStatus, 8000);
});
</script>
</body>
</html>
