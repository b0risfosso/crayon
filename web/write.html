<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Write | Language</title>
<style>
  :root {
    --border-color: #000;
    --bg-main: #fff;
    --text-muted: #444;
  }

  * {
    box-sizing: border-box;
  }

  body {
    font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
    margin: 0;
    padding: 2rem 1.5rem;
    background: #fff;
    color: #000;
    line-height: 1.5;
  }

  main {
    max-width: 64rem;
    margin: 0 auto;
    background: #fff;
    border: 1px solid #000;
    padding: 1.75rem 1.5rem 2.5rem;
    box-shadow: none;
  }

  nav {
    margin-bottom: 1.5rem;
    display: flex;
    gap: 0.75rem;
    align-items: center;
    font-size: 0.9rem;
  }

  nav a {
    text-decoration: none;
    color: #000;
    padding: 0.25rem 0.6rem;
    border: 1px solid #000;
  }

  nav a:hover {
    background: #000;
    color: #fff;
  }

  h1 {
    font-size: 1.6rem;
    margin: 0 0 0.4rem;
  }

  h2 {
    font-size: 1.1rem;
    margin: 1.5rem 0 0.75rem;
  }

  label {
    display: block;
    font-weight: 600;
    margin-bottom: 0.35rem;
    font-size: 0.95rem;
  }

  textarea,
  input,
  select {
    width: 100%;
    padding: 0.55rem 0.7rem;
    font: inherit;
    border: 1px solid #000;
    background: #fff;
    color: #000;
    border-radius: 0;
  }

  textarea {
    resize: vertical;
  }

  input[type="checkbox"] {
    width: auto;
  }

  input[type="number"] {
    width: 6rem;
  }

  button {
    padding: 0.5rem 0.9rem;
    font: inherit;
    border: 1px solid #000;
    background: #000;
    color: #fff;
    cursor: pointer;
    border-radius: 0;
  }

  button.secondary {
    background: #fff;
    color: #000;
  }

  button:hover:not(:disabled) {
    background: #fff;
    color: #000;
  }

  button.secondary:hover {
    background: #000;
    color: #fff;
  }

  button:disabled {
    opacity: 0.6;
    cursor: default;
  }

  .row {
    display: flex;
    gap: 0.5rem;
    align-items: center;
    flex-wrap: wrap;
  }

  .result {
    margin-top: 0.75rem;
    white-space: pre-wrap;
  }

  .muted {
    color: #444;
    font-size: 0.9rem;
  }

  /* Section cards (now simple boxes, sharp edge) */
  .section-card {
    border: 1px solid #000;
    padding: 1rem 1.1rem;
    background: #fff;
    margin-bottom: 0.75rem;
    border-radius: 0;
  }

  .section-title {
    font-size: 0.95rem;
    font-weight: 700;
    margin-bottom: 0.6rem;
  }

  /* Lists */
  .list {
    border: 1px solid #000;
    padding: 0.5rem;
    max-height: 14rem;
    overflow: auto;
    background: #fff;
    font-size: 0.9rem;
    border-radius: 0;
  }

  .list label {
    display: flex;
    gap: 0.5rem;
    align-items: flex-start;
    font-weight: 400;
    margin: 0.25rem 0;
  }

  .list label span {
    flex: 1;
    white-space: pre-wrap;
    overflow-wrap: anywhere;
  }

  /* Text B layout */
  .textb-layout {
    display: flex;
    gap: 1rem;
    align-items: flex-start;
  }

  .textb-column {
    flex: 1;
    min-width: 0;
  }

  .textb-column-title {
    font-size: 0.9rem;
    font-weight: 700;
    margin-bottom: 0.35rem;
  }

  details {
    border: 1px solid #000;
    padding: 0.45rem 0.7rem 0.6rem;
    background: #fff;
    margin-bottom: 0.5rem;
    border-radius: 0;
  }

  summary {
    cursor: pointer;
    font-weight: 600;
  }

  #erase-writing {
    background: #000;
    border-color: #000;
    color: #fff;
  }

  #erase-writing:hover {
    background: #fff;
    color: #000;
  }

  @media (max-width: 900px) {
    main {
      padding: 1.25rem 1rem 1.75rem;
    }

    .textb-layout {
      flex-direction: column;
    }
  }

  .primary-wide {
  display: block;
  width: 100%;
  padding: 1rem;
  font-size: 1.1rem;
  font-weight: 700;
}

  .type-list-block {
    margin-bottom: 0.4rem;
    font-size: 0.85rem;
  }

  .type-summary {
    padding: 0.25rem 0;
  }

  .type-summary strong {
    font-weight: 600;
  }

  /* Hide per-writing rows for other types */
  .type-list-hidden {
    display: none;
  }


</style>


</head>
<body>
  <main>
    <nav>
      <a href="/index.html">Home</a>
      <a href="/lang.html">Lang!</a>
    </nav>

    <h1>Write</h1>

    <form id="lang-form">
      <label for="text-a-name">Text A Name</label>
      <input id="text-a-name" type="text" />

      <label for="text-a-desc">Text A Description</label>
      <textarea id="text-a-desc"></textarea>

            <div class="section-card">
        <div class="section-title">Text B sources</div>

        <div class="textb-layout">
          <!-- Column 1: Creations -->
          <div class="textb-column">
            <div class="textb-column-title">From creations</div>
            <small>Select one or more saved creations.</small>
            <div id="creations-list" class="list"></div>

            <div class="row" style="margin-top: 0.5rem;">
              <input id="random-count" type="number" min="1" placeholder="N" />
              <button type="button" id="random-select" class="secondary">
                Select N random
              </button>
            </div>

            <button type="button" id="delete-creation" class="secondary" style="margin-top: 0.4rem;">
              Remove selected
            </button>
          </div>

          <!-- Column 2: Lang writings -->
          <div class="textb-column">
            <div class="textb-column-title">From lang</div>
            <small>Use previous lang writings as Text B.</small>
            <div id="lang-writings-list" class="list"></div>
          </div>

          <!-- Column 3: Other types -->
          <div class="textb-column">
            <div class="textb-column-title">From other types</div>
            <small>Use writings across types as Text B.</small>
            <select id="textb-type-select" style="display:none"></select>

            <div id="type-lists-container" class="list"></div>
          </div>
        </div>
      </div>


      <div style="margin-top: 0.75rem;">
        <button type="submit" id="write-button" class="primary-wide">
          write
        </button>
      </div>
    </form>

    <div id="status"></div>
    <div id="result" class="result"></div>
  </main>

  <script>
    const form = document.getElementById('lang-form');
    const statusEl = document.getElementById('status');
    const resultEl = document.getElementById('result');
    const creationsList = document.getElementById('creations-list');
    const deleteCreationBtn = document.getElementById('delete-creation');
    const randomCountEl = document.getElementById('random-count');
    const randomSelectBtn = document.getElementById('random-select');
    const textANameEl = document.getElementById('text-a-name');
    const textADescEl = document.getElementById('text-a-desc');

    const langWritingsList = document.getElementById('lang-writings-list');
    const textBTypeSelect = document.getElementById('textb-type-select');
    const typeListsContainer = document.getElementById('type-lists-container');



    function composeTextA(name, description) {
      const trimmedName = (name || '').trim();
      const trimmedDesc = (description || '').trim();
      if (trimmedName && trimmedDesc) return `${trimmedName}\n\n${trimmedDesc}`;
      return trimmedName || trimmedDesc || '';
    }

    let lastTextA = '';
    let lastWritingId = null;

    function splitTextA(text) {
      const lines = text.split(/\r?\n/);
      const name = (lines.shift() || '').trim() || '(untitled)';
      const description = lines.join('\n').trim();
      return { name, description };
    }

    async function ensureParentWriting(textAValue) {
      if (textAValue === lastTextA && lastWritingId) {
        return lastWritingId;
      }

      const { name, description } = splitTextA(textAValue);
      const res = await fetch('/api/writings', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        // NOTE: tag these as root writings
        body: JSON.stringify({ name, description, type: 'lang' }),
      });
      if (!res.ok) {
        const err = await res.json().catch(() => ({}));
        throw new Error(err.error || 'Failed to create writing');
      }
      const data = await res.json();
      lastTextA = textAValue;
      lastWritingId = data.id;
      return data.id;
    }

    async function loadCreations() {
      try {
        const res = await fetch('/api/creations');
        if (!res.ok) throw new Error('Failed to load creations');
        const data = await res.json();
        creationsList.textContent = '';
        if (!data.length) {
          creationsList.textContent = 'No creations yet.';
          return;
        }
        data.forEach((item) => {
          const label = document.createElement('label');
          const checkbox = document.createElement('input');
          checkbox.type = 'checkbox';
          checkbox.value = String(item.id);

          // store name + description
          checkbox.dataset.name = item.name || '';
          checkbox.dataset.description = item.description || '';

          const span = document.createElement('span');
          span.textContent = item.name || '(untitled)'; // show name only
          label.appendChild(checkbox);
          label.appendChild(span);
          creationsList.appendChild(label);
        });

      } catch (err) {
        statusEl.textContent = `Error: ${err.message}`;
      }
    }

    async function loadTextBTypes() {
      try {
        const res = await fetch('/api/writing-types/stats');
        if (!res.ok) throw new Error('Failed to load writing type stats');
        const data = await res.json();
        if (!Array.isArray(data)) return;

        // We keep the hidden select for compatibility but don't really use it
        textBTypeSelect.textContent = '';
        const placeholder = document.createElement('option');
        placeholder.value = '';
        placeholder.textContent = 'Select type…';
        textBTypeSelect.appendChild(placeholder);

        // Clear any existing list
        typeListsContainer.textContent = '';

        // Build summary blocks for all non-special types
        const types = data.filter(
          (item) =>
            item &&
            item.type &&
            item.type !== 'creations' &&
            item.type !== 'lang'
        );

        types.forEach((item) => {
          const type = item.type;
          const count = item.count || 0;

          const wrapper = document.createElement('div');
          wrapper.dataset.typeList = type;
          wrapper.dataset.total = String(count);
          wrapper.className = 'type-list-block';

          const summary = document.createElement('div');
          summary.className = 'type-summary';
          summary.innerHTML = `
            <strong>${type}</strong>:
            <span class="type-total">${count}</span> writings,
            <span class="type-selected">0</span> selected
          `;
          wrapper.appendChild(summary);

          // Hidden container to hold ONLY selected writings as checkboxes
          const selectedContainer = document.createElement('div');
          selectedContainer.className = 'type-selected-container type-list-hidden';
          wrapper.appendChild(selectedContainer);

          typeListsContainer.appendChild(wrapper);
        });
      } catch (err) {
        statusEl.textContent = `Error loading types: ${err.message}`;
      }
    }



    async function addTypeList(type) {
      if (!type) return;

      // Prevent duplicate blocks for the same type
      const existing = typeListsContainer.querySelector(
        `[data-type-list="${type}"]`
      );
      if (existing) return existing;

      const wrapper = document.createElement('div');
      wrapper.dataset.typeList = type;
      wrapper.className = 'type-list-block';

      // Summary row (visible)
      const summary = document.createElement('div');
      summary.className = 'type-summary';
      summary.innerHTML = `
        <strong>${type}</strong>:
        <span class="type-total">0</span> writings,
        <span class="type-selected">0</span> selected
      `;
      wrapper.appendChild(summary);

      // Actual list of writings (hidden, still used for selection)
      const list = document.createElement('div');
      list.className = 'list type-list-hidden';
      wrapper.appendChild(list);

      typeListsContainer.appendChild(wrapper);

      try {
        const res = await fetch(`/api/writings?type=${encodeURIComponent(type)}`);
        if (!res.ok) throw new Error(`Failed to load writings for type ${type}`);
        const data = await res.json();

        list.textContent = '';

        const totalSpan = summary.querySelector('.type-total');
        const selectedSpan = summary.querySelector('.type-selected');

        if (!data.length) {
          totalSpan.textContent = '0';
          selectedSpan.textContent = '0';
          return wrapper;
        }

        data.forEach((item) => {
          const row = document.createElement('label');
          const checkbox = document.createElement('input');
          checkbox.type = 'checkbox';
          checkbox.value = String(item.id);
          checkbox.dataset.name = item.name || '';
          checkbox.dataset.description = item.description || '';

          const span = document.createElement('span');
          span.textContent = item.name || '(untitled)';
          row.appendChild(checkbox);
          row.appendChild(span);
          list.appendChild(row);
        });

        totalSpan.textContent = String(data.length);
        selectedSpan.textContent = '0';
      } catch (err) {
        list.textContent = `Error: ${err.message}`;
      }

      return wrapper;
    }

    function updateAllTypeSummaries() {
      const blocks = typeListsContainer.querySelectorAll('.type-list-block');
      blocks.forEach((block) => {
        const selectedContainer =
          block.querySelector('.type-selected-container') ||
          block.querySelector('.list'); // fallback if needed

        const totalSpan = block.querySelector('.type-total');
        const selectedSpan = block.querySelector('.type-selected');
        if (!selectedSpan) return;

        // total comes from the data attribute, not from checkbox count
        if (totalSpan && block.dataset.total != null) {
          totalSpan.textContent = block.dataset.total;
        }

        if (!selectedContainer) {
          selectedSpan.textContent = '0';
          return;
        }

        const checkboxes = Array.from(
          selectedContainer.querySelectorAll('input[type="checkbox"]')
        );

        selectedSpan.textContent = String(
          checkboxes.filter((cb) => cb.checked).length
        );
      });
    }

    // If anything in the hidden containers is toggled (future-proof),
    // keep summaries in sync.
    typeListsContainer.addEventListener('change', (event) => {
      if (event.target && event.target.matches('input[type="checkbox"]')) {
        updateAllTypeSummaries();
      }
    });


    // If anything in the hidden lists is manually toggled (future-proof),
    // keep summaries in sync.
    typeListsContainer.addEventListener('change', (event) => {
      if (event.target && event.target.matches('input[type="checkbox"]')) {
        updateAllTypeSummaries();
      }
    });




    async function loadLangWritings() {
      try {
        const res = await fetch('/api/writings?type=lang');
        if (!res.ok) throw new Error('Failed to load lang');
        const data = await res.json();

        langWritingsList.textContent = '';
        if (!data.length) {
          langWritingsList.textContent = 'No lang yet.';
          return;
        }

        data.forEach((item) => {
          const label = document.createElement('label');
          const checkbox = document.createElement('input');
          checkbox.type = 'checkbox';
          checkbox.value = String(item.id);
          // we only *display* the name, but we store desc for later
          checkbox.dataset.name = item.name || '';
          checkbox.dataset.description = item.description || '';
          const span = document.createElement('span');
          span.textContent = item.name || '(untitled)'; // name only
          label.appendChild(checkbox);
          label.appendChild(span);
          langWritingsList.appendChild(label);
        });
      } catch (err) {
        statusEl.textContent = `Error: ${err.message}`;
      }
    }


    form.addEventListener('submit', async (event) => {
      event.preventDefault();
      statusEl.textContent = 'writing...';
      resultEl.textContent = '';

      const selectedCreations = Array.from(
  creationsList.querySelectorAll('input[type="checkbox"]:checked')
);
const selectedLang = Array.from(
  langWritingsList.querySelectorAll('input[type="checkbox"]:checked')
);

const selectedTyped = Array.from(
  typeListsContainer.querySelectorAll('input[type="checkbox"]:checked')
);

if (!selectedCreations.length && !selectedLang.length && !selectedTyped.length) {
  statusEl.textContent = 'Select at least one Text B (creation, lang, or typed writing).';
  return;
}

const textAValue = composeTextA(textANameEl.value, textADescEl.value);

try {
  const parentWritingId = await ensureParentWriting(textAValue);

  // Build all jobs (from both lists)
  const jobs = [];

  // 1) creations: use raw text_b as before
  selectedCreations.forEach((checkbox) => {
    const name = checkbox.dataset.name || '';
    const description = checkbox.dataset.description || '';
    const textBValue = composeTextA(name, description);
    jobs.push({
      text_a: textAValue,
      text_b: textBValue,
      parent_writing_id: parentWritingId,
    });
  });


  // 2) lang writings: use name + description as text_b
  selectedLang.forEach((checkbox) => {
    const name = checkbox.dataset.name || '';
    const description = checkbox.dataset.description || '';
    const textBValue = composeTextA(name, description); // same formatting
    jobs.push({
      text_a: textAValue,
      text_b: textBValue,
      parent_writing_id: parentWritingId,
    });
  });

  // 3) type-based lists: name + description
selectedTyped.forEach((checkbox) => {
  const name = checkbox.dataset.name || '';
  const description = checkbox.dataset.description || '';
  const textBValue = composeTextA(name, description);
  jobs.push({
    text_a: textAValue,
    text_b: textBValue,
    parent_writing_id: parentWritingId,
  });
});


  const results = await Promise.all(
    jobs.map(async (payload) => {
      const res = await fetch('/api/lang', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload),
      });
      if (!res.ok) {
        const err = await res.json().catch(() => ({}));
        throw new Error(err.error || 'Request failed');
      }
      return res.json();
    })
  );

      statusEl.textContent = '';
      const queued = results.filter((item) => item && item.task_id).map((item) => item.task_id);
      if (queued.length) {
        resultEl.textContent = `Queued tasks: ${queued.join(', ')}. Check /queue.html for status.`;
      } else {
        resultEl.textContent = '';
      }
    } catch (err) {
      statusEl.textContent = `Error: ${err.message}`;
    }
});



    deleteCreationBtn.addEventListener('click', async () => {
      const selected = Array.from(creationsList.querySelectorAll('input[type="checkbox"]:checked'));
      if (!selected.length) return;
      try {
        await Promise.all(selected.map(async (checkbox) => {
          const res = await fetch(`/api/creations/${checkbox.value}`, { method: 'DELETE' });
          if (!res.ok) {
            const err = await res.json().catch(() => ({}));
            throw new Error(err.error || 'Failed to delete creation');
          }
        }));
        await loadCreations();
      } catch (err) {
        statusEl.textContent = `Error: ${err.message}`;
      }
    });

    randomSelectBtn.addEventListener('click', async () => {
      const count = Number.parseInt(randomCountEl.value, 10);
      if (!Number.isFinite(count) || count <= 0) {
        return;
      }

      statusEl.textContent = 'Selecting random writings...';

      // 1) Clear all existing selections
      //    a) Creations + lang: just uncheck
      [
        ...creationsList.querySelectorAll('input[type="checkbox"]'),
        ...langWritingsList.querySelectorAll('input[type="checkbox"]'),
      ].forEach((cb) => {
        cb.checked = false;
      });

      //    b) Other types: remove any previously created selected checkboxes
      typeListsContainer
        .querySelectorAll('.type-selected-container')
        .forEach((container) => {
          container.textContent = '';
        });

      try {
        // 2) Ask the backend for a balanced selection
        const res = await fetch(
          `/api/writings/random-balanced?total=${encodeURIComponent(count)}`
        );
        if (!res.ok) {
          const err = await res.json().catch(() => ({}));
          throw new Error(err.error || 'Random selection failed');
        }
        const data = await res.json();
        if (!Array.isArray(data)) {
          throw new Error('Unexpected response from random-balanced');
        }

        // 3) Mark the returned writings as selected in the UI
        data.forEach((item) => {
          const id = String(item.id);
          const type = item.type || '';
          const name = item.name || '';
          const description = item.description || '';

          if (type === 'creations') {
            // Find the existing creations checkbox
            const cb = creationsList.querySelector(
              `input[type="checkbox"][value="${id}"]`
            );
            if (cb) {
              cb.checked = true;
              cb.dataset.name = name;
              cb.dataset.description = description;
            }
            return;
          }

          if (type === 'lang') {
            // Find the existing lang checkbox
            const cb = langWritingsList.querySelector(
              `input[type="checkbox"][value="${id}"]`
            );
            if (cb) {
              cb.checked = true;
              cb.dataset.name = name;
              cb.dataset.description = description;
            }
            return;
          }

          // Other types: create hidden checkboxes in their own container
          let block = typeListsContainer.querySelector(
            `[data-type-list="${type}"]`
          );

          // If this type wasn't in the initial stats (rare), create a block
          if (!block) {
            block = document.createElement('div');
            block.dataset.typeList = type;
            block.dataset.total = '0';
            block.className = 'type-list-block';

            const summary = document.createElement('div');
            summary.className = 'type-summary';
            summary.innerHTML = `
              <strong>${type}</strong>:
              <span class="type-total">0</span> writings,
              <span class="type-selected">0</span> selected
            `;
            block.appendChild(summary);

            const selectedContainer = document.createElement('div');
            selectedContainer.className =
              'type-selected-container type-list-hidden';
            block.appendChild(selectedContainer);

            typeListsContainer.appendChild(block);
          }

          const selectedContainer =
            block.querySelector('.type-selected-container');

          if (!selectedContainer) return;

          const label = document.createElement('label');
          const cb = document.createElement('input');
          cb.type = 'checkbox';
          cb.value = id;
          cb.checked = true; // pre-selected
          cb.dataset.name = name;
          cb.dataset.description = description;

          const span = document.createElement('span');
          span.textContent = name || '(untitled)';

          label.appendChild(cb);
          label.appendChild(span);
          selectedContainer.appendChild(label);
        });

        updateAllTypeSummaries();
        statusEl.textContent = '';
      } catch (err) {
        statusEl.textContent = `Error selecting random writings: ${err.message}`;
      }
    });



      if (!groups.length) {
        return;
      }

      // Total available across all groups
      let totalAvailable = groups.reduce(
        (sum, g) => sum + g.checkboxes.length,
        0
      );
      let remaining = Math.min(count, totalAvailable);

      // Fisher–Yates shuffle for each group
      const shuffle = (arr) => {
        for (let i = arr.length - 1; i > 0; i -= 1) {
          const j = Math.floor(Math.random() * (i + 1));
          [arr[i], arr[j]] = [arr[j], arr[i]];
        }
      };
      groups.forEach((g) => shuffle(g.checkboxes));

      // Round-robin selection across groups
      let idx = 0;
      while (remaining > 0 && groups.length > 0) {
        const group = groups[idx];
        const cb = group.checkboxes.pop();
        if (cb) {
          cb.checked = true;
          remaining -= 1;
          totalAvailable -= 1;
        }

        // If this group is exhausted, remove it
        if (!group.checkboxes.length) {
          groups.splice(idx, 1);
          if (!groups.length) break;
          idx %= groups.length;
        } else {
          idx = (idx + 1) % groups.length;
        }
      }

      // If you have a summary updater, call it here:
      updateAllTypeSummaries();
    });



    loadCreations();
    loadLangWritings();
    loadTextBTypes();
  </script>
</body>
</html>
